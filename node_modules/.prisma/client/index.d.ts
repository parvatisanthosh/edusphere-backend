
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Workspace
 * 
 */
export type Workspace = $Result.DefaultSelection<Prisma.$WorkspacePayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model Invite
 * 
 */
export type Invite = $Result.DefaultSelection<Prisma.$InvitePayload>
/**
 * Model Chat
 * 
 */
export type Chat = $Result.DefaultSelection<Prisma.$ChatPayload>
/**
 * Model Student
 * 
 */
export type Student = $Result.DefaultSelection<Prisma.$StudentPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Internship
 * 
 */
export type Internship = $Result.DefaultSelection<Prisma.$InternshipPayload>
/**
 * Model InternshipApplication
 * 
 */
export type InternshipApplication = $Result.DefaultSelection<Prisma.$InternshipApplicationPayload>
/**
 * Model InternshipEvaluation
 * 
 */
export type InternshipEvaluation = $Result.DefaultSelection<Prisma.$InternshipEvaluationPayload>
/**
 * Model Course
 * 
 */
export type Course = $Result.DefaultSelection<Prisma.$CoursePayload>
/**
 * Model CourseEnrollment
 * 
 */
export type CourseEnrollment = $Result.DefaultSelection<Prisma.$CourseEnrollmentPayload>
/**
 * Model Checkpoint
 * 
 */
export type Checkpoint = $Result.DefaultSelection<Prisma.$CheckpointPayload>
/**
 * Model PortfolioProject
 * 
 */
export type PortfolioProject = $Result.DefaultSelection<Prisma.$PortfolioProjectPayload>
/**
 * Model MentorSession
 * 
 */
export type MentorSession = $Result.DefaultSelection<Prisma.$MentorSessionPayload>
/**
 * Model MentorReview
 * 
 */
export type MentorReview = $Result.DefaultSelection<Prisma.$MentorReviewPayload>
/**
 * Model LogbookEntry
 * 
 */
export type LogbookEntry = $Result.DefaultSelection<Prisma.$LogbookEntryPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model StudentLearningProgress
 * 
 */
export type StudentLearningProgress = $Result.DefaultSelection<Prisma.$StudentLearningProgressPayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model Certification
 * 
 */
export type Certification = $Result.DefaultSelection<Prisma.$CertificationPayload>
/**
 * Model Skill
 * 
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model StudentSkill
 * 
 */
export type StudentSkill = $Result.DefaultSelection<Prisma.$StudentSkillPayload>
/**
 * Model CVGeneration
 * 
 */
export type CVGeneration = $Result.DefaultSelection<Prisma.$CVGenerationPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.workspace`: Exposes CRUD operations for the **Workspace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workspaces
    * const workspaces = await prisma.workspace.findMany()
    * ```
    */
  get workspace(): Prisma.WorkspaceDelegate<ExtArgs>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.invite`: Exposes CRUD operations for the **Invite** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invites
    * const invites = await prisma.invite.findMany()
    * ```
    */
  get invite(): Prisma.InviteDelegate<ExtArgs>;

  /**
   * `prisma.chat`: Exposes CRUD operations for the **Chat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chat.findMany()
    * ```
    */
  get chat(): Prisma.ChatDelegate<ExtArgs>;

  /**
   * `prisma.student`: Exposes CRUD operations for the **Student** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Students
    * const students = await prisma.student.findMany()
    * ```
    */
  get student(): Prisma.StudentDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.internship`: Exposes CRUD operations for the **Internship** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Internships
    * const internships = await prisma.internship.findMany()
    * ```
    */
  get internship(): Prisma.InternshipDelegate<ExtArgs>;

  /**
   * `prisma.internshipApplication`: Exposes CRUD operations for the **InternshipApplication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternshipApplications
    * const internshipApplications = await prisma.internshipApplication.findMany()
    * ```
    */
  get internshipApplication(): Prisma.InternshipApplicationDelegate<ExtArgs>;

  /**
   * `prisma.internshipEvaluation`: Exposes CRUD operations for the **InternshipEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternshipEvaluations
    * const internshipEvaluations = await prisma.internshipEvaluation.findMany()
    * ```
    */
  get internshipEvaluation(): Prisma.InternshipEvaluationDelegate<ExtArgs>;

  /**
   * `prisma.course`: Exposes CRUD operations for the **Course** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Courses
    * const courses = await prisma.course.findMany()
    * ```
    */
  get course(): Prisma.CourseDelegate<ExtArgs>;

  /**
   * `prisma.courseEnrollment`: Exposes CRUD operations for the **CourseEnrollment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CourseEnrollments
    * const courseEnrollments = await prisma.courseEnrollment.findMany()
    * ```
    */
  get courseEnrollment(): Prisma.CourseEnrollmentDelegate<ExtArgs>;

  /**
   * `prisma.checkpoint`: Exposes CRUD operations for the **Checkpoint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checkpoints
    * const checkpoints = await prisma.checkpoint.findMany()
    * ```
    */
  get checkpoint(): Prisma.CheckpointDelegate<ExtArgs>;

  /**
   * `prisma.portfolioProject`: Exposes CRUD operations for the **PortfolioProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortfolioProjects
    * const portfolioProjects = await prisma.portfolioProject.findMany()
    * ```
    */
  get portfolioProject(): Prisma.PortfolioProjectDelegate<ExtArgs>;

  /**
   * `prisma.mentorSession`: Exposes CRUD operations for the **MentorSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorSessions
    * const mentorSessions = await prisma.mentorSession.findMany()
    * ```
    */
  get mentorSession(): Prisma.MentorSessionDelegate<ExtArgs>;

  /**
   * `prisma.mentorReview`: Exposes CRUD operations for the **MentorReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MentorReviews
    * const mentorReviews = await prisma.mentorReview.findMany()
    * ```
    */
  get mentorReview(): Prisma.MentorReviewDelegate<ExtArgs>;

  /**
   * `prisma.logbookEntry`: Exposes CRUD operations for the **LogbookEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LogbookEntries
    * const logbookEntries = await prisma.logbookEntry.findMany()
    * ```
    */
  get logbookEntry(): Prisma.LogbookEntryDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.studentLearningProgress`: Exposes CRUD operations for the **StudentLearningProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentLearningProgresses
    * const studentLearningProgresses = await prisma.studentLearningProgress.findMany()
    * ```
    */
  get studentLearningProgress(): Prisma.StudentLearningProgressDelegate<ExtArgs>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs>;

  /**
   * `prisma.certification`: Exposes CRUD operations for the **Certification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certifications
    * const certifications = await prisma.certification.findMany()
    * ```
    */
  get certification(): Prisma.CertificationDelegate<ExtArgs>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs>;

  /**
   * `prisma.studentSkill`: Exposes CRUD operations for the **StudentSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentSkills
    * const studentSkills = await prisma.studentSkill.findMany()
    * ```
    */
  get studentSkill(): Prisma.StudentSkillDelegate<ExtArgs>;

  /**
   * `prisma.cVGeneration`: Exposes CRUD operations for the **CVGeneration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CVGenerations
    * const cVGenerations = await prisma.cVGeneration.findMany()
    * ```
    */
  get cVGeneration(): Prisma.CVGenerationDelegate<ExtArgs>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Workspace: 'Workspace',
    Folder: 'Folder',
    Team: 'Team',
    Invite: 'Invite',
    Chat: 'Chat',
    Student: 'Student',
    Profile: 'Profile',
    Internship: 'Internship',
    InternshipApplication: 'InternshipApplication',
    InternshipEvaluation: 'InternshipEvaluation',
    Course: 'Course',
    CourseEnrollment: 'CourseEnrollment',
    Checkpoint: 'Checkpoint',
    PortfolioProject: 'PortfolioProject',
    MentorSession: 'MentorSession',
    MentorReview: 'MentorReview',
    LogbookEntry: 'LogbookEntry',
    Certificate: 'Certificate',
    StudentLearningProgress: 'StudentLearningProgress',
    Roadmap: 'Roadmap',
    Certification: 'Certification',
    Skill: 'Skill',
    StudentSkill: 'StudentSkill',
    CVGeneration: 'CVGeneration',
    Document: 'Document'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "workspace" | "folder" | "team" | "invite" | "chat" | "student" | "profile" | "internship" | "internshipApplication" | "internshipEvaluation" | "course" | "courseEnrollment" | "checkpoint" | "portfolioProject" | "mentorSession" | "mentorReview" | "logbookEntry" | "certificate" | "studentLearningProgress" | "roadmap" | "certification" | "skill" | "studentSkill" | "cVGeneration" | "document"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Workspace: {
        payload: Prisma.$WorkspacePayload<ExtArgs>
        fields: Prisma.WorkspaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkspaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkspaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findFirst: {
            args: Prisma.WorkspaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkspaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          findMany: {
            args: Prisma.WorkspaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          create: {
            args: Prisma.WorkspaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          createMany: {
            args: Prisma.WorkspaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkspaceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>[]
          }
          delete: {
            args: Prisma.WorkspaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          update: {
            args: Prisma.WorkspaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          deleteMany: {
            args: Prisma.WorkspaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkspaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkspaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkspacePayload>
          }
          aggregate: {
            args: Prisma.WorkspaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkspace>
          }
          groupBy: {
            args: Prisma.WorkspaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkspaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkspaceCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      Invite: {
        payload: Prisma.$InvitePayload<ExtArgs>
        fields: Prisma.InviteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InviteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InviteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findFirst: {
            args: Prisma.InviteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InviteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          findMany: {
            args: Prisma.InviteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          create: {
            args: Prisma.InviteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          createMany: {
            args: Prisma.InviteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InviteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>[]
          }
          delete: {
            args: Prisma.InviteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          update: {
            args: Prisma.InviteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          deleteMany: {
            args: Prisma.InviteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InviteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InviteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitePayload>
          }
          aggregate: {
            args: Prisma.InviteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvite>
          }
          groupBy: {
            args: Prisma.InviteGroupByArgs<ExtArgs>
            result: $Utils.Optional<InviteGroupByOutputType>[]
          }
          count: {
            args: Prisma.InviteCountArgs<ExtArgs>
            result: $Utils.Optional<InviteCountAggregateOutputType> | number
          }
        }
      }
      Chat: {
        payload: Prisma.$ChatPayload<ExtArgs>
        fields: Prisma.ChatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findFirst: {
            args: Prisma.ChatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          findMany: {
            args: Prisma.ChatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          create: {
            args: Prisma.ChatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          createMany: {
            args: Prisma.ChatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>[]
          }
          delete: {
            args: Prisma.ChatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          update: {
            args: Prisma.ChatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          deleteMany: {
            args: Prisma.ChatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatPayload>
          }
          aggregate: {
            args: Prisma.ChatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat>
          }
          groupBy: {
            args: Prisma.ChatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatCountArgs<ExtArgs>
            result: $Utils.Optional<ChatCountAggregateOutputType> | number
          }
        }
      }
      Student: {
        payload: Prisma.$StudentPayload<ExtArgs>
        fields: Prisma.StudentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findFirst: {
            args: Prisma.StudentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          findMany: {
            args: Prisma.StudentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          create: {
            args: Prisma.StudentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          createMany: {
            args: Prisma.StudentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>[]
          }
          delete: {
            args: Prisma.StudentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          update: {
            args: Prisma.StudentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          deleteMany: {
            args: Prisma.StudentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentPayload>
          }
          aggregate: {
            args: Prisma.StudentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudent>
          }
          groupBy: {
            args: Prisma.StudentGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentCountArgs<ExtArgs>
            result: $Utils.Optional<StudentCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Internship: {
        payload: Prisma.$InternshipPayload<ExtArgs>
        fields: Prisma.InternshipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternshipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternshipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          findFirst: {
            args: Prisma.InternshipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternshipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          findMany: {
            args: Prisma.InternshipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>[]
          }
          create: {
            args: Prisma.InternshipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          createMany: {
            args: Prisma.InternshipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternshipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>[]
          }
          delete: {
            args: Prisma.InternshipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          update: {
            args: Prisma.InternshipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          deleteMany: {
            args: Prisma.InternshipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternshipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternshipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipPayload>
          }
          aggregate: {
            args: Prisma.InternshipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternship>
          }
          groupBy: {
            args: Prisma.InternshipGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternshipGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternshipCountArgs<ExtArgs>
            result: $Utils.Optional<InternshipCountAggregateOutputType> | number
          }
        }
      }
      InternshipApplication: {
        payload: Prisma.$InternshipApplicationPayload<ExtArgs>
        fields: Prisma.InternshipApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternshipApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternshipApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          findFirst: {
            args: Prisma.InternshipApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternshipApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          findMany: {
            args: Prisma.InternshipApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>[]
          }
          create: {
            args: Prisma.InternshipApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          createMany: {
            args: Prisma.InternshipApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternshipApplicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>[]
          }
          delete: {
            args: Prisma.InternshipApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          update: {
            args: Prisma.InternshipApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          deleteMany: {
            args: Prisma.InternshipApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternshipApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternshipApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipApplicationPayload>
          }
          aggregate: {
            args: Prisma.InternshipApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternshipApplication>
          }
          groupBy: {
            args: Prisma.InternshipApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternshipApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternshipApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<InternshipApplicationCountAggregateOutputType> | number
          }
        }
      }
      InternshipEvaluation: {
        payload: Prisma.$InternshipEvaluationPayload<ExtArgs>
        fields: Prisma.InternshipEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternshipEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternshipEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          findFirst: {
            args: Prisma.InternshipEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternshipEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          findMany: {
            args: Prisma.InternshipEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>[]
          }
          create: {
            args: Prisma.InternshipEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          createMany: {
            args: Prisma.InternshipEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InternshipEvaluationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>[]
          }
          delete: {
            args: Prisma.InternshipEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          update: {
            args: Prisma.InternshipEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.InternshipEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternshipEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternshipEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternshipEvaluationPayload>
          }
          aggregate: {
            args: Prisma.InternshipEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternshipEvaluation>
          }
          groupBy: {
            args: Prisma.InternshipEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternshipEvaluationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternshipEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<InternshipEvaluationCountAggregateOutputType> | number
          }
        }
      }
      Course: {
        payload: Prisma.$CoursePayload<ExtArgs>
        fields: Prisma.CourseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findFirst: {
            args: Prisma.CourseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          findMany: {
            args: Prisma.CourseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          create: {
            args: Prisma.CourseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          createMany: {
            args: Prisma.CourseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>[]
          }
          delete: {
            args: Prisma.CourseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          update: {
            args: Prisma.CourseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          deleteMany: {
            args: Prisma.CourseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoursePayload>
          }
          aggregate: {
            args: Prisma.CourseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourse>
          }
          groupBy: {
            args: Prisma.CourseGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseCountArgs<ExtArgs>
            result: $Utils.Optional<CourseCountAggregateOutputType> | number
          }
        }
      }
      CourseEnrollment: {
        payload: Prisma.$CourseEnrollmentPayload<ExtArgs>
        fields: Prisma.CourseEnrollmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CourseEnrollmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findFirst: {
            args: Prisma.CourseEnrollmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          findMany: {
            args: Prisma.CourseEnrollmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          create: {
            args: Prisma.CourseEnrollmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          createMany: {
            args: Prisma.CourseEnrollmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>[]
          }
          delete: {
            args: Prisma.CourseEnrollmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          update: {
            args: Prisma.CourseEnrollmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          deleteMany: {
            args: Prisma.CourseEnrollmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CourseEnrollmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CourseEnrollmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CourseEnrollmentPayload>
          }
          aggregate: {
            args: Prisma.CourseEnrollmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCourseEnrollment>
          }
          groupBy: {
            args: Prisma.CourseEnrollmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CourseEnrollmentCountArgs<ExtArgs>
            result: $Utils.Optional<CourseEnrollmentCountAggregateOutputType> | number
          }
        }
      }
      Checkpoint: {
        payload: Prisma.$CheckpointPayload<ExtArgs>
        fields: Prisma.CheckpointFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CheckpointFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CheckpointFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          findFirst: {
            args: Prisma.CheckpointFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CheckpointFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          findMany: {
            args: Prisma.CheckpointFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>[]
          }
          create: {
            args: Prisma.CheckpointCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          createMany: {
            args: Prisma.CheckpointCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CheckpointCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>[]
          }
          delete: {
            args: Prisma.CheckpointDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          update: {
            args: Prisma.CheckpointUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          deleteMany: {
            args: Prisma.CheckpointDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CheckpointUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CheckpointUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CheckpointPayload>
          }
          aggregate: {
            args: Prisma.CheckpointAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCheckpoint>
          }
          groupBy: {
            args: Prisma.CheckpointGroupByArgs<ExtArgs>
            result: $Utils.Optional<CheckpointGroupByOutputType>[]
          }
          count: {
            args: Prisma.CheckpointCountArgs<ExtArgs>
            result: $Utils.Optional<CheckpointCountAggregateOutputType> | number
          }
        }
      }
      PortfolioProject: {
        payload: Prisma.$PortfolioProjectPayload<ExtArgs>
        fields: Prisma.PortfolioProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortfolioProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortfolioProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          findFirst: {
            args: Prisma.PortfolioProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortfolioProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          findMany: {
            args: Prisma.PortfolioProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>[]
          }
          create: {
            args: Prisma.PortfolioProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          createMany: {
            args: Prisma.PortfolioProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortfolioProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>[]
          }
          delete: {
            args: Prisma.PortfolioProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          update: {
            args: Prisma.PortfolioProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          deleteMany: {
            args: Prisma.PortfolioProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortfolioProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PortfolioProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortfolioProjectPayload>
          }
          aggregate: {
            args: Prisma.PortfolioProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortfolioProject>
          }
          groupBy: {
            args: Prisma.PortfolioProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortfolioProjectCountArgs<ExtArgs>
            result: $Utils.Optional<PortfolioProjectCountAggregateOutputType> | number
          }
        }
      }
      MentorSession: {
        payload: Prisma.$MentorSessionPayload<ExtArgs>
        fields: Prisma.MentorSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          findFirst: {
            args: Prisma.MentorSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          findMany: {
            args: Prisma.MentorSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>[]
          }
          create: {
            args: Prisma.MentorSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          createMany: {
            args: Prisma.MentorSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>[]
          }
          delete: {
            args: Prisma.MentorSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          update: {
            args: Prisma.MentorSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          deleteMany: {
            args: Prisma.MentorSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentorSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorSessionPayload>
          }
          aggregate: {
            args: Prisma.MentorSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorSession>
          }
          groupBy: {
            args: Prisma.MentorSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorSessionCountArgs<ExtArgs>
            result: $Utils.Optional<MentorSessionCountAggregateOutputType> | number
          }
        }
      }
      MentorReview: {
        payload: Prisma.$MentorReviewPayload<ExtArgs>
        fields: Prisma.MentorReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MentorReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MentorReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          findFirst: {
            args: Prisma.MentorReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MentorReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          findMany: {
            args: Prisma.MentorReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>[]
          }
          create: {
            args: Prisma.MentorReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          createMany: {
            args: Prisma.MentorReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MentorReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>[]
          }
          delete: {
            args: Prisma.MentorReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          update: {
            args: Prisma.MentorReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          deleteMany: {
            args: Prisma.MentorReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MentorReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MentorReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MentorReviewPayload>
          }
          aggregate: {
            args: Prisma.MentorReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMentorReview>
          }
          groupBy: {
            args: Prisma.MentorReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<MentorReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.MentorReviewCountArgs<ExtArgs>
            result: $Utils.Optional<MentorReviewCountAggregateOutputType> | number
          }
        }
      }
      LogbookEntry: {
        payload: Prisma.$LogbookEntryPayload<ExtArgs>
        fields: Prisma.LogbookEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogbookEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogbookEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          findFirst: {
            args: Prisma.LogbookEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogbookEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          findMany: {
            args: Prisma.LogbookEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>[]
          }
          create: {
            args: Prisma.LogbookEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          createMany: {
            args: Prisma.LogbookEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogbookEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>[]
          }
          delete: {
            args: Prisma.LogbookEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          update: {
            args: Prisma.LogbookEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          deleteMany: {
            args: Prisma.LogbookEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogbookEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LogbookEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogbookEntryPayload>
          }
          aggregate: {
            args: Prisma.LogbookEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogbookEntry>
          }
          groupBy: {
            args: Prisma.LogbookEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogbookEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogbookEntryCountArgs<ExtArgs>
            result: $Utils.Optional<LogbookEntryCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      StudentLearningProgress: {
        payload: Prisma.$StudentLearningProgressPayload<ExtArgs>
        fields: Prisma.StudentLearningProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentLearningProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentLearningProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          findFirst: {
            args: Prisma.StudentLearningProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentLearningProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          findMany: {
            args: Prisma.StudentLearningProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>[]
          }
          create: {
            args: Prisma.StudentLearningProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          createMany: {
            args: Prisma.StudentLearningProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentLearningProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>[]
          }
          delete: {
            args: Prisma.StudentLearningProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          update: {
            args: Prisma.StudentLearningProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          deleteMany: {
            args: Prisma.StudentLearningProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentLearningProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentLearningProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentLearningProgressPayload>
          }
          aggregate: {
            args: Prisma.StudentLearningProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentLearningProgress>
          }
          groupBy: {
            args: Prisma.StudentLearningProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentLearningProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentLearningProgressCountArgs<ExtArgs>
            result: $Utils.Optional<StudentLearningProgressCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoadmapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      Certification: {
        payload: Prisma.$CertificationPayload<ExtArgs>
        fields: Prisma.CertificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findFirst: {
            args: Prisma.CertificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          findMany: {
            args: Prisma.CertificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          create: {
            args: Prisma.CertificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          createMany: {
            args: Prisma.CertificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CertificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>[]
          }
          delete: {
            args: Prisma.CertificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          update: {
            args: Prisma.CertificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          deleteMany: {
            args: Prisma.CertificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificationPayload>
          }
          aggregate: {
            args: Prisma.CertificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertification>
          }
          groupBy: {
            args: Prisma.CertificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificationCountArgs<ExtArgs>
            result: $Utils.Optional<CertificationCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      StudentSkill: {
        payload: Prisma.$StudentSkillPayload<ExtArgs>
        fields: Prisma.StudentSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          findFirst: {
            args: Prisma.StudentSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          findMany: {
            args: Prisma.StudentSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>[]
          }
          create: {
            args: Prisma.StudentSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          createMany: {
            args: Prisma.StudentSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>[]
          }
          delete: {
            args: Prisma.StudentSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          update: {
            args: Prisma.StudentSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          deleteMany: {
            args: Prisma.StudentSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StudentSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentSkillPayload>
          }
          aggregate: {
            args: Prisma.StudentSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentSkill>
          }
          groupBy: {
            args: Prisma.StudentSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentSkillCountArgs<ExtArgs>
            result: $Utils.Optional<StudentSkillCountAggregateOutputType> | number
          }
        }
      }
      CVGeneration: {
        payload: Prisma.$CVGenerationPayload<ExtArgs>
        fields: Prisma.CVGenerationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CVGenerationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CVGenerationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          findFirst: {
            args: Prisma.CVGenerationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CVGenerationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          findMany: {
            args: Prisma.CVGenerationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>[]
          }
          create: {
            args: Prisma.CVGenerationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          createMany: {
            args: Prisma.CVGenerationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CVGenerationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>[]
          }
          delete: {
            args: Prisma.CVGenerationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          update: {
            args: Prisma.CVGenerationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          deleteMany: {
            args: Prisma.CVGenerationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CVGenerationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CVGenerationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CVGenerationPayload>
          }
          aggregate: {
            args: Prisma.CVGenerationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCVGeneration>
          }
          groupBy: {
            args: Prisma.CVGenerationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CVGenerationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CVGenerationCountArgs<ExtArgs>
            result: $Utils.Optional<CVGenerationCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    workspaces: number
    invites: number
    teams: number
    chats: number
    documents: number
    mentorSessions: number
    evaluationsGiven: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | UserCountOutputTypeCountWorkspacesArgs
    invites?: boolean | UserCountOutputTypeCountInvitesArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    chats?: boolean | UserCountOutputTypeCountChatsArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    mentorSessions?: boolean | UserCountOutputTypeCountMentorSessionsArgs
    evaluationsGiven?: boolean | UserCountOutputTypeCountEvaluationsGivenArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEvaluationsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipEvaluationWhereInput
  }


  /**
   * Count Type WorkspaceCountOutputType
   */

  export type WorkspaceCountOutputType = {
    chats: number
    invites: number
  }

  export type WorkspaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | WorkspaceCountOutputTypeCountChatsArgs
    invites?: boolean | WorkspaceCountOutputTypeCountInvitesArgs
  }

  // Custom InputTypes
  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkspaceCountOutputType
     */
    select?: WorkspaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountChatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
  }

  /**
   * WorkspaceCountOutputType without action
   */
  export type WorkspaceCountOutputTypeCountInvitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    workspaces: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | FolderCountOutputTypeCountWorkspacesArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    workspaces: number
    users: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | TeamCountOutputTypeCountWorkspacesArgs
    users?: boolean | TeamCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountWorkspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type StudentCountOutputType
   */

  export type StudentCountOutputType = {
    applications: number
    enrollments: number
    projects: number
    mentorSessions: number
    reviews: number
    logbookEntries: number
    certificates: number
    learningProgress: number
    certifications: number
    studentSkills: number
    cvGenerations: number
  }

  export type StudentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | StudentCountOutputTypeCountApplicationsArgs
    enrollments?: boolean | StudentCountOutputTypeCountEnrollmentsArgs
    projects?: boolean | StudentCountOutputTypeCountProjectsArgs
    mentorSessions?: boolean | StudentCountOutputTypeCountMentorSessionsArgs
    reviews?: boolean | StudentCountOutputTypeCountReviewsArgs
    logbookEntries?: boolean | StudentCountOutputTypeCountLogbookEntriesArgs
    certificates?: boolean | StudentCountOutputTypeCountCertificatesArgs
    learningProgress?: boolean | StudentCountOutputTypeCountLearningProgressArgs
    certifications?: boolean | StudentCountOutputTypeCountCertificationsArgs
    studentSkills?: boolean | StudentCountOutputTypeCountStudentSkillsArgs
    cvGenerations?: boolean | StudentCountOutputTypeCountCvGenerationsArgs
  }

  // Custom InputTypes
  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentCountOutputType
     */
    select?: StudentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipApplicationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioProjectWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountMentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorSessionWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorReviewWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountLogbookEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogbookEntryWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountLearningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentLearningProgressWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCertificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountStudentSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSkillWhereInput
  }

  /**
   * StudentCountOutputType without action
   */
  export type StudentCountOutputTypeCountCvGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CVGenerationWhereInput
  }


  /**
   * Count Type InternshipCountOutputType
   */

  export type InternshipCountOutputType = {
    applications: number
    evaluations: number
  }

  export type InternshipCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | InternshipCountOutputTypeCountApplicationsArgs
    evaluations?: boolean | InternshipCountOutputTypeCountEvaluationsArgs
  }

  // Custom InputTypes
  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipCountOutputType
     */
    select?: InternshipCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipApplicationWhereInput
  }

  /**
   * InternshipCountOutputType without action
   */
  export type InternshipCountOutputTypeCountEvaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipEvaluationWhereInput
  }


  /**
   * Count Type CourseCountOutputType
   */

  export type CourseCountOutputType = {
    enrollments: number
    checkpoints: number
  }

  export type CourseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | CourseCountOutputTypeCountEnrollmentsArgs
    checkpoints?: boolean | CourseCountOutputTypeCountCheckpointsArgs
  }

  // Custom InputTypes
  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseCountOutputType
     */
    select?: CourseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountEnrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseCountOutputType without action
   */
  export type CourseCountOutputTypeCountCheckpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckpointWhereInput
  }


  /**
   * Count Type MentorSessionCountOutputType
   */

  export type MentorSessionCountOutputType = {
    reviews: number
  }

  export type MentorSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | MentorSessionCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * MentorSessionCountOutputType without action
   */
  export type MentorSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSessionCountOutputType
     */
    select?: MentorSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MentorSessionCountOutputType without action
   */
  export type MentorSessionCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorReviewWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    studentSkills: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSkills?: boolean | SkillCountOutputTypeCountStudentSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountStudentSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSkillWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    teamRole: string | null
    createdAt: Date | null
    updatedAt: Date | null
    githubUsername: string | null
    githubToken: string | null
    githubConnectedAt: Date | null
    lastGithubSync: Date | null
    profilePictureUrl: string | null
    resumeUrl: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    teamRole: string | null
    createdAt: Date | null
    updatedAt: Date | null
    githubUsername: string | null
    githubToken: string | null
    githubConnectedAt: Date | null
    lastGithubSync: Date | null
    profilePictureUrl: string | null
    resumeUrl: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    teamRole: number
    createdAt: number
    updatedAt: number
    githubUsername: number
    githubToken: number
    githubConnectedAt: number
    lastGithubSync: number
    profilePictureUrl: number
    resumeUrl: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    teamRole?: true
    createdAt?: true
    updatedAt?: true
    githubUsername?: true
    githubToken?: true
    githubConnectedAt?: true
    lastGithubSync?: true
    profilePictureUrl?: true
    resumeUrl?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    teamRole?: true
    createdAt?: true
    updatedAt?: true
    githubUsername?: true
    githubToken?: true
    githubConnectedAt?: true
    lastGithubSync?: true
    profilePictureUrl?: true
    resumeUrl?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    teamRole?: true
    createdAt?: true
    updatedAt?: true
    githubUsername?: true
    githubToken?: true
    githubConnectedAt?: true
    lastGithubSync?: true
    profilePictureUrl?: true
    resumeUrl?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    teamRole: string | null
    createdAt: Date
    updatedAt: Date
    githubUsername: string | null
    githubToken: string | null
    githubConnectedAt: Date | null
    lastGithubSync: Date | null
    profilePictureUrl: string | null
    resumeUrl: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    teamRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    githubUsername?: boolean
    githubToken?: boolean
    githubConnectedAt?: boolean
    lastGithubSync?: boolean
    profilePictureUrl?: boolean
    resumeUrl?: boolean
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    invites?: boolean | User$invitesArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    mentorSessions?: boolean | User$mentorSessionsArgs<ExtArgs>
    evaluationsGiven?: boolean | User$evaluationsGivenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    teamRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    githubUsername?: boolean
    githubToken?: boolean
    githubConnectedAt?: boolean
    lastGithubSync?: boolean
    profilePictureUrl?: boolean
    resumeUrl?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    teamRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    githubUsername?: boolean
    githubToken?: boolean
    githubConnectedAt?: boolean
    lastGithubSync?: boolean
    profilePictureUrl?: boolean
    resumeUrl?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | User$workspacesArgs<ExtArgs>
    invites?: boolean | User$invitesArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    chats?: boolean | User$chatsArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    student?: boolean | User$studentArgs<ExtArgs>
    mentorSessions?: boolean | User$mentorSessionsArgs<ExtArgs>
    evaluationsGiven?: boolean | User$evaluationsGivenArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>[]
      invites: Prisma.$InvitePayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      chats: Prisma.$ChatPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      student: Prisma.$StudentPayload<ExtArgs> | null
      mentorSessions: Prisma.$MentorSessionPayload<ExtArgs>[]
      evaluationsGiven: Prisma.$InternshipEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      teamRole: string | null
      createdAt: Date
      updatedAt: Date
      githubUsername: string | null
      githubToken: string | null
      githubConnectedAt: Date | null
      lastGithubSync: Date | null
      profilePictureUrl: string | null
      resumeUrl: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends User$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, User$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends User$invitesArgs<ExtArgs> = {}>(args?: Subset<T, User$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    chats<T extends User$chatsArgs<ExtArgs> = {}>(args?: Subset<T, User$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany"> | Null>
    student<T extends User$studentArgs<ExtArgs> = {}>(args?: Subset<T, User$studentArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    mentorSessions<T extends User$mentorSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$mentorSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findMany"> | Null>
    evaluationsGiven<T extends User$evaluationsGivenArgs<ExtArgs> = {}>(args?: Subset<T, User$evaluationsGivenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly teamRole: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly githubUsername: FieldRef<"User", 'String'>
    readonly githubToken: FieldRef<"User", 'String'>
    readonly githubConnectedAt: FieldRef<"User", 'DateTime'>
    readonly lastGithubSync: FieldRef<"User", 'DateTime'>
    readonly profilePictureUrl: FieldRef<"User", 'String'>
    readonly resumeUrl: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.workspaces
   */
  export type User$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    cursor?: WorkspaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * User.invites
   */
  export type User$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.chats
   */
  export type User$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.student
   */
  export type User$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    where?: StudentWhereInput
  }

  /**
   * User.mentorSessions
   */
  export type User$mentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    where?: MentorSessionWhereInput
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    cursor?: MentorSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[]
  }

  /**
   * User.evaluationsGiven
   */
  export type User$evaluationsGivenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    where?: InternshipEvaluationWhereInput
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    cursor?: InternshipEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipEvaluationScalarFieldEnum | InternshipEvaluationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Workspace
   */

  export type AggregateWorkspace = {
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  export type WorkspaceMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    folderId: string | null
    teamId: string | null
    userId: string | null
  }

  export type WorkspaceMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    folderId: string | null
    teamId: string | null
    userId: string | null
  }

  export type WorkspaceCountAggregateOutputType = {
    id: number
    createdAt: number
    folderId: number
    teamId: number
    userId: number
    _all: number
  }


  export type WorkspaceMinAggregateInputType = {
    id?: true
    createdAt?: true
    folderId?: true
    teamId?: true
    userId?: true
  }

  export type WorkspaceMaxAggregateInputType = {
    id?: true
    createdAt?: true
    folderId?: true
    teamId?: true
    userId?: true
  }

  export type WorkspaceCountAggregateInputType = {
    id?: true
    createdAt?: true
    folderId?: true
    teamId?: true
    userId?: true
    _all?: true
  }

  export type WorkspaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspace to aggregate.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workspaces
    **/
    _count?: true | WorkspaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkspaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkspaceMaxAggregateInputType
  }

  export type GetWorkspaceAggregateType<T extends WorkspaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkspace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkspace[P]>
      : GetScalarType<T[P], AggregateWorkspace[P]>
  }




  export type WorkspaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithAggregationInput | WorkspaceOrderByWithAggregationInput[]
    by: WorkspaceScalarFieldEnum[] | WorkspaceScalarFieldEnum
    having?: WorkspaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkspaceCountAggregateInputType | true
    _min?: WorkspaceMinAggregateInputType
    _max?: WorkspaceMaxAggregateInputType
  }

  export type WorkspaceGroupByOutputType = {
    id: string
    createdAt: Date
    folderId: string | null
    teamId: string | null
    userId: string
    _count: WorkspaceCountAggregateOutputType | null
    _min: WorkspaceMinAggregateOutputType | null
    _max: WorkspaceMaxAggregateOutputType | null
  }

  type GetWorkspaceGroupByPayload<T extends WorkspaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkspaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkspaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkspaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkspaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    folderId?: boolean
    teamId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Workspace$folderArgs<ExtArgs>
    team?: boolean | Workspace$teamArgs<ExtArgs>
    chats?: boolean | Workspace$chatsArgs<ExtArgs>
    invites?: boolean | Workspace$invitesArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    folderId?: boolean
    teamId?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Workspace$folderArgs<ExtArgs>
    team?: boolean | Workspace$teamArgs<ExtArgs>
  }, ExtArgs["result"]["workspace"]>

  export type WorkspaceSelectScalar = {
    id?: boolean
    createdAt?: boolean
    folderId?: boolean
    teamId?: boolean
    userId?: boolean
  }

  export type WorkspaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Workspace$folderArgs<ExtArgs>
    team?: boolean | Workspace$teamArgs<ExtArgs>
    chats?: boolean | Workspace$chatsArgs<ExtArgs>
    invites?: boolean | Workspace$invitesArgs<ExtArgs>
    _count?: boolean | WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WorkspaceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    folder?: boolean | Workspace$folderArgs<ExtArgs>
    team?: boolean | Workspace$teamArgs<ExtArgs>
  }

  export type $WorkspacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workspace"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs> | null
      team: Prisma.$TeamPayload<ExtArgs> | null
      chats: Prisma.$ChatPayload<ExtArgs>[]
      invites: Prisma.$InvitePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      folderId: string | null
      teamId: string | null
      userId: string
    }, ExtArgs["result"]["workspace"]>
    composites: {}
  }

  type WorkspaceGetPayload<S extends boolean | null | undefined | WorkspaceDefaultArgs> = $Result.GetResult<Prisma.$WorkspacePayload, S>

  type WorkspaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkspaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkspaceCountAggregateInputType | true
    }

  export interface WorkspaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workspace'], meta: { name: 'Workspace' } }
    /**
     * Find zero or one Workspace that matches the filter.
     * @param {WorkspaceFindUniqueArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkspaceFindUniqueArgs>(args: SelectSubset<T, WorkspaceFindUniqueArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Workspace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkspaceFindUniqueOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkspaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkspaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Workspace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkspaceFindFirstArgs>(args?: SelectSubset<T, WorkspaceFindFirstArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Workspace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindFirstOrThrowArgs} args - Arguments to find a Workspace
     * @example
     * // Get one Workspace
     * const workspace = await prisma.workspace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkspaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkspaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Workspaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workspaces
     * const workspaces = await prisma.workspace.findMany()
     * 
     * // Get first 10 Workspaces
     * const workspaces = await prisma.workspace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workspaceWithIdOnly = await prisma.workspace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkspaceFindManyArgs>(args?: SelectSubset<T, WorkspaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Workspace.
     * @param {WorkspaceCreateArgs} args - Arguments to create a Workspace.
     * @example
     * // Create one Workspace
     * const Workspace = await prisma.workspace.create({
     *   data: {
     *     // ... data to create a Workspace
     *   }
     * })
     * 
     */
    create<T extends WorkspaceCreateArgs>(args: SelectSubset<T, WorkspaceCreateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Workspaces.
     * @param {WorkspaceCreateManyArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkspaceCreateManyArgs>(args?: SelectSubset<T, WorkspaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workspaces and returns the data saved in the database.
     * @param {WorkspaceCreateManyAndReturnArgs} args - Arguments to create many Workspaces.
     * @example
     * // Create many Workspaces
     * const workspace = await prisma.workspace.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workspaces and only return the `id`
     * const workspaceWithIdOnly = await prisma.workspace.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkspaceCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkspaceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Workspace.
     * @param {WorkspaceDeleteArgs} args - Arguments to delete one Workspace.
     * @example
     * // Delete one Workspace
     * const Workspace = await prisma.workspace.delete({
     *   where: {
     *     // ... filter to delete one Workspace
     *   }
     * })
     * 
     */
    delete<T extends WorkspaceDeleteArgs>(args: SelectSubset<T, WorkspaceDeleteArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Workspace.
     * @param {WorkspaceUpdateArgs} args - Arguments to update one Workspace.
     * @example
     * // Update one Workspace
     * const workspace = await prisma.workspace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkspaceUpdateArgs>(args: SelectSubset<T, WorkspaceUpdateArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Workspaces.
     * @param {WorkspaceDeleteManyArgs} args - Arguments to filter Workspaces to delete.
     * @example
     * // Delete a few Workspaces
     * const { count } = await prisma.workspace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkspaceDeleteManyArgs>(args?: SelectSubset<T, WorkspaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workspaces
     * const workspace = await prisma.workspace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkspaceUpdateManyArgs>(args: SelectSubset<T, WorkspaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Workspace.
     * @param {WorkspaceUpsertArgs} args - Arguments to update or create a Workspace.
     * @example
     * // Update or create a Workspace
     * const workspace = await prisma.workspace.upsert({
     *   create: {
     *     // ... data to create a Workspace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workspace we want to update
     *   }
     * })
     */
    upsert<T extends WorkspaceUpsertArgs>(args: SelectSubset<T, WorkspaceUpsertArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Workspaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceCountArgs} args - Arguments to filter Workspaces to count.
     * @example
     * // Count the number of Workspaces
     * const count = await prisma.workspace.count({
     *   where: {
     *     // ... the filter for the Workspaces we want to count
     *   }
     * })
    **/
    count<T extends WorkspaceCountArgs>(
      args?: Subset<T, WorkspaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkspaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkspaceAggregateArgs>(args: Subset<T, WorkspaceAggregateArgs>): Prisma.PrismaPromise<GetWorkspaceAggregateType<T>>

    /**
     * Group by Workspace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkspaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkspaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkspaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkspaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkspaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkspaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workspace model
   */
  readonly fields: WorkspaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workspace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkspaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    folder<T extends Workspace$folderArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    team<T extends Workspace$teamArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    chats<T extends Workspace$chatsArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$chatsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany"> | Null>
    invites<T extends Workspace$invitesArgs<ExtArgs> = {}>(args?: Subset<T, Workspace$invitesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workspace model
   */ 
  interface WorkspaceFieldRefs {
    readonly id: FieldRef<"Workspace", 'String'>
    readonly createdAt: FieldRef<"Workspace", 'DateTime'>
    readonly folderId: FieldRef<"Workspace", 'String'>
    readonly teamId: FieldRef<"Workspace", 'String'>
    readonly userId: FieldRef<"Workspace", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Workspace findUnique
   */
  export type WorkspaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findUniqueOrThrow
   */
  export type WorkspaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace findFirst
   */
  export type WorkspaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findFirstOrThrow
   */
  export type WorkspaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspace to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workspaces.
     */
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace findMany
   */
  export type WorkspaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter, which Workspaces to fetch.
     */
    where?: WorkspaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workspaces to fetch.
     */
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workspaces.
     */
    cursor?: WorkspaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workspaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workspaces.
     */
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Workspace create
   */
  export type WorkspaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to create a Workspace.
     */
    data: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
  }

  /**
   * Workspace createMany
   */
  export type WorkspaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
  }

  /**
   * Workspace createManyAndReturn
   */
  export type WorkspaceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Workspaces.
     */
    data: WorkspaceCreateManyInput | WorkspaceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workspace update
   */
  export type WorkspaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The data needed to update a Workspace.
     */
    data: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
    /**
     * Choose, which Workspace to update.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace updateMany
   */
  export type WorkspaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workspaces.
     */
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyInput>
    /**
     * Filter which Workspaces to update
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace upsert
   */
  export type WorkspaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * The filter to search for the Workspace to update in case it exists.
     */
    where: WorkspaceWhereUniqueInput
    /**
     * In case the Workspace found by the `where` argument doesn't exist, create a new Workspace with this data.
     */
    create: XOR<WorkspaceCreateInput, WorkspaceUncheckedCreateInput>
    /**
     * In case the Workspace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkspaceUpdateInput, WorkspaceUncheckedUpdateInput>
  }

  /**
   * Workspace delete
   */
  export type WorkspaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    /**
     * Filter which Workspace to delete.
     */
    where: WorkspaceWhereUniqueInput
  }

  /**
   * Workspace deleteMany
   */
  export type WorkspaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workspaces to delete
     */
    where?: WorkspaceWhereInput
  }

  /**
   * Workspace.folder
   */
  export type Workspace$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Workspace.team
   */
  export type Workspace$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Workspace.chats
   */
  export type Workspace$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    cursor?: ChatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Workspace.invites
   */
  export type Workspace$invitesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    cursor?: InviteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Workspace without action
   */
  export type WorkspaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    name: string
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    workspaces?: boolean | Folder$workspacesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | Folder$workspacesArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends Folder$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, Folder$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */ 
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
  }

  /**
   * Folder.workspaces
   */
  export type Folder$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    cursor?: WorkspaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    name: string
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    workspaces?: boolean | Team$workspacesArgs<ExtArgs>
    users?: boolean | Team$usersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>

  export type TeamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["team"]>

  export type TeamSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspaces?: boolean | Team$workspacesArgs<ExtArgs>
    users?: boolean | Team$usersArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      workspaces: Prisma.$WorkspacePayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Teams and returns the data saved in the database.
     * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Teams and only return the `id`
     * const teamWithIdOnly = await prisma.team.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspaces<T extends Team$workspacesArgs<ExtArgs> = {}>(args?: Subset<T, Team$workspacesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Team$usersArgs<ExtArgs> = {}>(args?: Subset<T, Team$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly name: FieldRef<"Team", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team createManyAndReturn
   */
  export type TeamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.workspaces
   */
  export type Team$workspacesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workspace
     */
    select?: WorkspaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkspaceInclude<ExtArgs> | null
    where?: WorkspaceWhereInput
    orderBy?: WorkspaceOrderByWithRelationInput | WorkspaceOrderByWithRelationInput[]
    cursor?: WorkspaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkspaceScalarFieldEnum | WorkspaceScalarFieldEnum[]
  }

  /**
   * Team.users
   */
  export type Team$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model Invite
   */

  export type AggregateInvite = {
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  export type InviteMinAggregateOutputType = {
    id: string | null
    inviteId: string | null
    workspaceId: string | null
    type: string | null
    inviterId: string | null
  }

  export type InviteMaxAggregateOutputType = {
    id: string | null
    inviteId: string | null
    workspaceId: string | null
    type: string | null
    inviterId: string | null
  }

  export type InviteCountAggregateOutputType = {
    id: number
    inviteId: number
    workspaceId: number
    type: number
    inviterId: number
    _all: number
  }


  export type InviteMinAggregateInputType = {
    id?: true
    inviteId?: true
    workspaceId?: true
    type?: true
    inviterId?: true
  }

  export type InviteMaxAggregateInputType = {
    id?: true
    inviteId?: true
    workspaceId?: true
    type?: true
    inviterId?: true
  }

  export type InviteCountAggregateInputType = {
    id?: true
    inviteId?: true
    workspaceId?: true
    type?: true
    inviterId?: true
    _all?: true
  }

  export type InviteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invite to aggregate.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invites
    **/
    _count?: true | InviteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InviteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InviteMaxAggregateInputType
  }

  export type GetInviteAggregateType<T extends InviteAggregateArgs> = {
        [P in keyof T & keyof AggregateInvite]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvite[P]>
      : GetScalarType<T[P], AggregateInvite[P]>
  }




  export type InviteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InviteWhereInput
    orderBy?: InviteOrderByWithAggregationInput | InviteOrderByWithAggregationInput[]
    by: InviteScalarFieldEnum[] | InviteScalarFieldEnum
    having?: InviteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InviteCountAggregateInputType | true
    _min?: InviteMinAggregateInputType
    _max?: InviteMaxAggregateInputType
  }

  export type InviteGroupByOutputType = {
    id: string
    inviteId: string
    workspaceId: string
    type: string
    inviterId: string
    _count: InviteCountAggregateOutputType | null
    _min: InviteMinAggregateOutputType | null
    _max: InviteMaxAggregateOutputType | null
  }

  type GetInviteGroupByPayload<T extends InviteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InviteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InviteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InviteGroupByOutputType[P]>
            : GetScalarType<T[P], InviteGroupByOutputType[P]>
        }
      >
    >


  export type InviteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviteId?: boolean
    workspaceId?: boolean
    type?: boolean
    inviterId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    inviteId?: boolean
    workspaceId?: boolean
    type?: boolean
    inviterId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invite"]>

  export type InviteSelectScalar = {
    id?: boolean
    inviteId?: boolean
    workspaceId?: boolean
    type?: boolean
    inviterId?: boolean
  }

  export type InviteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InviteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    inviter?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvitePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invite"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      inviter: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      inviteId: string
      workspaceId: string
      type: string
      inviterId: string
    }, ExtArgs["result"]["invite"]>
    composites: {}
  }

  type InviteGetPayload<S extends boolean | null | undefined | InviteDefaultArgs> = $Result.GetResult<Prisma.$InvitePayload, S>

  type InviteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InviteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InviteCountAggregateInputType | true
    }

  export interface InviteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invite'], meta: { name: 'Invite' } }
    /**
     * Find zero or one Invite that matches the filter.
     * @param {InviteFindUniqueArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InviteFindUniqueArgs>(args: SelectSubset<T, InviteFindUniqueArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invite that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InviteFindUniqueOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InviteFindUniqueOrThrowArgs>(args: SelectSubset<T, InviteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invite that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InviteFindFirstArgs>(args?: SelectSubset<T, InviteFindFirstArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invite that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindFirstOrThrowArgs} args - Arguments to find a Invite
     * @example
     * // Get one Invite
     * const invite = await prisma.invite.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InviteFindFirstOrThrowArgs>(args?: SelectSubset<T, InviteFindFirstOrThrowArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invites that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invites
     * const invites = await prisma.invite.findMany()
     * 
     * // Get first 10 Invites
     * const invites = await prisma.invite.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inviteWithIdOnly = await prisma.invite.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InviteFindManyArgs>(args?: SelectSubset<T, InviteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invite.
     * @param {InviteCreateArgs} args - Arguments to create a Invite.
     * @example
     * // Create one Invite
     * const Invite = await prisma.invite.create({
     *   data: {
     *     // ... data to create a Invite
     *   }
     * })
     * 
     */
    create<T extends InviteCreateArgs>(args: SelectSubset<T, InviteCreateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invites.
     * @param {InviteCreateManyArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InviteCreateManyArgs>(args?: SelectSubset<T, InviteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invites and returns the data saved in the database.
     * @param {InviteCreateManyAndReturnArgs} args - Arguments to create many Invites.
     * @example
     * // Create many Invites
     * const invite = await prisma.invite.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invites and only return the `id`
     * const inviteWithIdOnly = await prisma.invite.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InviteCreateManyAndReturnArgs>(args?: SelectSubset<T, InviteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invite.
     * @param {InviteDeleteArgs} args - Arguments to delete one Invite.
     * @example
     * // Delete one Invite
     * const Invite = await prisma.invite.delete({
     *   where: {
     *     // ... filter to delete one Invite
     *   }
     * })
     * 
     */
    delete<T extends InviteDeleteArgs>(args: SelectSubset<T, InviteDeleteArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invite.
     * @param {InviteUpdateArgs} args - Arguments to update one Invite.
     * @example
     * // Update one Invite
     * const invite = await prisma.invite.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InviteUpdateArgs>(args: SelectSubset<T, InviteUpdateArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invites.
     * @param {InviteDeleteManyArgs} args - Arguments to filter Invites to delete.
     * @example
     * // Delete a few Invites
     * const { count } = await prisma.invite.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InviteDeleteManyArgs>(args?: SelectSubset<T, InviteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invites
     * const invite = await prisma.invite.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InviteUpdateManyArgs>(args: SelectSubset<T, InviteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invite.
     * @param {InviteUpsertArgs} args - Arguments to update or create a Invite.
     * @example
     * // Update or create a Invite
     * const invite = await prisma.invite.upsert({
     *   create: {
     *     // ... data to create a Invite
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invite we want to update
     *   }
     * })
     */
    upsert<T extends InviteUpsertArgs>(args: SelectSubset<T, InviteUpsertArgs<ExtArgs>>): Prisma__InviteClient<$Result.GetResult<Prisma.$InvitePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invites.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteCountArgs} args - Arguments to filter Invites to count.
     * @example
     * // Count the number of Invites
     * const count = await prisma.invite.count({
     *   where: {
     *     // ... the filter for the Invites we want to count
     *   }
     * })
    **/
    count<T extends InviteCountArgs>(
      args?: Subset<T, InviteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InviteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InviteAggregateArgs>(args: Subset<T, InviteAggregateArgs>): Prisma.PrismaPromise<GetInviteAggregateType<T>>

    /**
     * Group by Invite.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InviteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InviteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InviteGroupByArgs['orderBy'] }
        : { orderBy?: InviteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InviteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInviteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invite model
   */
  readonly fields: InviteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invite.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InviteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    inviter<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invite model
   */ 
  interface InviteFieldRefs {
    readonly id: FieldRef<"Invite", 'String'>
    readonly inviteId: FieldRef<"Invite", 'String'>
    readonly workspaceId: FieldRef<"Invite", 'String'>
    readonly type: FieldRef<"Invite", 'String'>
    readonly inviterId: FieldRef<"Invite", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Invite findUnique
   */
  export type InviteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findUniqueOrThrow
   */
  export type InviteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite findFirst
   */
  export type InviteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findFirstOrThrow
   */
  export type InviteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invite to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invites.
     */
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite findMany
   */
  export type InviteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter, which Invites to fetch.
     */
    where?: InviteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invites to fetch.
     */
    orderBy?: InviteOrderByWithRelationInput | InviteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invites.
     */
    cursor?: InviteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invites from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invites.
     */
    skip?: number
    distinct?: InviteScalarFieldEnum | InviteScalarFieldEnum[]
  }

  /**
   * Invite create
   */
  export type InviteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to create a Invite.
     */
    data: XOR<InviteCreateInput, InviteUncheckedCreateInput>
  }

  /**
   * Invite createMany
   */
  export type InviteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
  }

  /**
   * Invite createManyAndReturn
   */
  export type InviteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invites.
     */
    data: InviteCreateManyInput | InviteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invite update
   */
  export type InviteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The data needed to update a Invite.
     */
    data: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
    /**
     * Choose, which Invite to update.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite updateMany
   */
  export type InviteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invites.
     */
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyInput>
    /**
     * Filter which Invites to update
     */
    where?: InviteWhereInput
  }

  /**
   * Invite upsert
   */
  export type InviteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * The filter to search for the Invite to update in case it exists.
     */
    where: InviteWhereUniqueInput
    /**
     * In case the Invite found by the `where` argument doesn't exist, create a new Invite with this data.
     */
    create: XOR<InviteCreateInput, InviteUncheckedCreateInput>
    /**
     * In case the Invite was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InviteUpdateInput, InviteUncheckedUpdateInput>
  }

  /**
   * Invite delete
   */
  export type InviteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
    /**
     * Filter which Invite to delete.
     */
    where: InviteWhereUniqueInput
  }

  /**
   * Invite deleteMany
   */
  export type InviteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invites to delete
     */
    where?: InviteWhereInput
  }

  /**
   * Invite without action
   */
  export type InviteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invite
     */
    select?: InviteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InviteInclude<ExtArgs> | null
  }


  /**
   * Model Chat
   */

  export type AggregateChat = {
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  export type ChatAvgAggregateOutputType = {
    duration: number | null
  }

  export type ChatSumAggregateOutputType = {
    duration: number | null
  }

  export type ChatMinAggregateOutputType = {
    id: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    workspaceId: string | null
    userId: string | null
  }

  export type ChatMaxAggregateOutputType = {
    id: string | null
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    workspaceId: string | null
    userId: string | null
  }

  export type ChatCountAggregateOutputType = {
    id: number
    duration: number
    startedAt: number
    endedAt: number
    workspaceId: number
    userId: number
    _all: number
  }


  export type ChatAvgAggregateInputType = {
    duration?: true
  }

  export type ChatSumAggregateInputType = {
    duration?: true
  }

  export type ChatMinAggregateInputType = {
    id?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    workspaceId?: true
    userId?: true
  }

  export type ChatMaxAggregateInputType = {
    id?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    workspaceId?: true
    userId?: true
  }

  export type ChatCountAggregateInputType = {
    id?: true
    duration?: true
    startedAt?: true
    endedAt?: true
    workspaceId?: true
    userId?: true
    _all?: true
  }

  export type ChatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chat to aggregate.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chats
    **/
    _count?: true | ChatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMaxAggregateInputType
  }

  export type GetChatAggregateType<T extends ChatAggregateArgs> = {
        [P in keyof T & keyof AggregateChat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat[P]>
      : GetScalarType<T[P], AggregateChat[P]>
  }




  export type ChatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatWhereInput
    orderBy?: ChatOrderByWithAggregationInput | ChatOrderByWithAggregationInput[]
    by: ChatScalarFieldEnum[] | ChatScalarFieldEnum
    having?: ChatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatCountAggregateInputType | true
    _avg?: ChatAvgAggregateInputType
    _sum?: ChatSumAggregateInputType
    _min?: ChatMinAggregateInputType
    _max?: ChatMaxAggregateInputType
  }

  export type ChatGroupByOutputType = {
    id: string
    duration: number | null
    startedAt: Date | null
    endedAt: Date | null
    workspaceId: string
    userId: string
    _count: ChatCountAggregateOutputType | null
    _avg: ChatAvgAggregateOutputType | null
    _sum: ChatSumAggregateOutputType | null
    _min: ChatMinAggregateOutputType | null
    _max: ChatMaxAggregateOutputType | null
  }

  type GetChatGroupByPayload<T extends ChatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatGroupByOutputType[P]>
            : GetScalarType<T[P], ChatGroupByOutputType[P]>
        }
      >
    >


  export type ChatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    workspaceId?: boolean
    userId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    workspaceId?: boolean
    userId?: boolean
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat"]>

  export type ChatSelectScalar = {
    id?: boolean
    duration?: boolean
    startedAt?: boolean
    endedAt?: boolean
    workspaceId?: boolean
    userId?: boolean
  }

  export type ChatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ChatIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    workspace?: boolean | WorkspaceDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ChatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Chat"
    objects: {
      workspace: Prisma.$WorkspacePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      duration: number | null
      startedAt: Date | null
      endedAt: Date | null
      workspaceId: string
      userId: string
    }, ExtArgs["result"]["chat"]>
    composites: {}
  }

  type ChatGetPayload<S extends boolean | null | undefined | ChatDefaultArgs> = $Result.GetResult<Prisma.$ChatPayload, S>

  type ChatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatCountAggregateInputType | true
    }

  export interface ChatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Chat'], meta: { name: 'Chat' } }
    /**
     * Find zero or one Chat that matches the filter.
     * @param {ChatFindUniqueArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatFindUniqueArgs>(args: SelectSubset<T, ChatFindUniqueArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Chat that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatFindUniqueOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Chat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatFindFirstArgs>(args?: SelectSubset<T, ChatFindFirstArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Chat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindFirstOrThrowArgs} args - Arguments to find a Chat
     * @example
     * // Get one Chat
     * const chat = await prisma.chat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chat.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatWithIdOnly = await prisma.chat.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatFindManyArgs>(args?: SelectSubset<T, ChatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Chat.
     * @param {ChatCreateArgs} args - Arguments to create a Chat.
     * @example
     * // Create one Chat
     * const Chat = await prisma.chat.create({
     *   data: {
     *     // ... data to create a Chat
     *   }
     * })
     * 
     */
    create<T extends ChatCreateArgs>(args: SelectSubset<T, ChatCreateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Chats.
     * @param {ChatCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatCreateManyArgs>(args?: SelectSubset<T, ChatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {ChatCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chat = await prisma.chat.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatWithIdOnly = await prisma.chat.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Chat.
     * @param {ChatDeleteArgs} args - Arguments to delete one Chat.
     * @example
     * // Delete one Chat
     * const Chat = await prisma.chat.delete({
     *   where: {
     *     // ... filter to delete one Chat
     *   }
     * })
     * 
     */
    delete<T extends ChatDeleteArgs>(args: SelectSubset<T, ChatDeleteArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Chat.
     * @param {ChatUpdateArgs} args - Arguments to update one Chat.
     * @example
     * // Update one Chat
     * const chat = await prisma.chat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatUpdateArgs>(args: SelectSubset<T, ChatUpdateArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Chats.
     * @param {ChatDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatDeleteManyArgs>(args?: SelectSubset<T, ChatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chat = await prisma.chat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatUpdateManyArgs>(args: SelectSubset<T, ChatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Chat.
     * @param {ChatUpsertArgs} args - Arguments to update or create a Chat.
     * @example
     * // Update or create a Chat
     * const chat = await prisma.chat.upsert({
     *   create: {
     *     // ... data to create a Chat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat we want to update
     *   }
     * })
     */
    upsert<T extends ChatUpsertArgs>(args: SelectSubset<T, ChatUpsertArgs<ExtArgs>>): Prisma__ChatClient<$Result.GetResult<Prisma.$ChatPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chat.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends ChatCountArgs>(
      args?: Subset<T, ChatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAggregateArgs>(args: Subset<T, ChatAggregateArgs>): Prisma.PrismaPromise<GetChatAggregateType<T>>

    /**
     * Group by Chat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatGroupByArgs['orderBy'] }
        : { orderBy?: ChatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Chat model
   */
  readonly fields: ChatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    workspace<T extends WorkspaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkspaceDefaultArgs<ExtArgs>>): Prisma__WorkspaceClient<$Result.GetResult<Prisma.$WorkspacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Chat model
   */ 
  interface ChatFieldRefs {
    readonly id: FieldRef<"Chat", 'String'>
    readonly duration: FieldRef<"Chat", 'Int'>
    readonly startedAt: FieldRef<"Chat", 'DateTime'>
    readonly endedAt: FieldRef<"Chat", 'DateTime'>
    readonly workspaceId: FieldRef<"Chat", 'String'>
    readonly userId: FieldRef<"Chat", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Chat findUnique
   */
  export type ChatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findUniqueOrThrow
   */
  export type ChatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat findFirst
   */
  export type ChatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findFirstOrThrow
   */
  export type ChatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chat to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chats.
     */
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat findMany
   */
  export type ChatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter, which Chats to fetch.
     */
    where?: ChatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chats to fetch.
     */
    orderBy?: ChatOrderByWithRelationInput | ChatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chats.
     */
    cursor?: ChatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chats.
     */
    skip?: number
    distinct?: ChatScalarFieldEnum | ChatScalarFieldEnum[]
  }

  /**
   * Chat create
   */
  export type ChatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to create a Chat.
     */
    data: XOR<ChatCreateInput, ChatUncheckedCreateInput>
  }

  /**
   * Chat createMany
   */
  export type ChatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
  }

  /**
   * Chat createManyAndReturn
   */
  export type ChatCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Chats.
     */
    data: ChatCreateManyInput | ChatCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Chat update
   */
  export type ChatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The data needed to update a Chat.
     */
    data: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
    /**
     * Choose, which Chat to update.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat updateMany
   */
  export type ChatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Chats.
     */
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyInput>
    /**
     * Filter which Chats to update
     */
    where?: ChatWhereInput
  }

  /**
   * Chat upsert
   */
  export type ChatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * The filter to search for the Chat to update in case it exists.
     */
    where: ChatWhereUniqueInput
    /**
     * In case the Chat found by the `where` argument doesn't exist, create a new Chat with this data.
     */
    create: XOR<ChatCreateInput, ChatUncheckedCreateInput>
    /**
     * In case the Chat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatUpdateInput, ChatUncheckedUpdateInput>
  }

  /**
   * Chat delete
   */
  export type ChatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
    /**
     * Filter which Chat to delete.
     */
    where: ChatWhereUniqueInput
  }

  /**
   * Chat deleteMany
   */
  export type ChatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Chats to delete
     */
    where?: ChatWhereInput
  }

  /**
   * Chat without action
   */
  export type ChatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Chat
     */
    select?: ChatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatInclude<ExtArgs> | null
  }


  /**
   * Model Student
   */

  export type AggregateStudent = {
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  export type StudentAvgAggregateOutputType = {
    semester: number | null
    cgpa: number | null
  }

  export type StudentSumAggregateOutputType = {
    semester: number | null
    cgpa: number | null
  }

  export type StudentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    rollNumber: string | null
    department: string | null
    semester: number | null
    cgpa: number | null
    dateOfBirth: Date | null
    phone: string | null
    approved: boolean | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    rollNumber: string | null
    department: string | null
    semester: number | null
    cgpa: number | null
    dateOfBirth: Date | null
    phone: string | null
    approved: boolean | null
    approvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentCountAggregateOutputType = {
    id: number
    userId: number
    rollNumber: number
    department: number
    semester: number
    cgpa: number
    dateOfBirth: number
    phone: number
    approved: number
    approvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentAvgAggregateInputType = {
    semester?: true
    cgpa?: true
  }

  export type StudentSumAggregateInputType = {
    semester?: true
    cgpa?: true
  }

  export type StudentMinAggregateInputType = {
    id?: true
    userId?: true
    rollNumber?: true
    department?: true
    semester?: true
    cgpa?: true
    dateOfBirth?: true
    phone?: true
    approved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentMaxAggregateInputType = {
    id?: true
    userId?: true
    rollNumber?: true
    department?: true
    semester?: true
    cgpa?: true
    dateOfBirth?: true
    phone?: true
    approved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentCountAggregateInputType = {
    id?: true
    userId?: true
    rollNumber?: true
    department?: true
    semester?: true
    cgpa?: true
    dateOfBirth?: true
    phone?: true
    approved?: true
    approvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Student to aggregate.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Students
    **/
    _count?: true | StudentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentMaxAggregateInputType
  }

  export type GetStudentAggregateType<T extends StudentAggregateArgs> = {
        [P in keyof T & keyof AggregateStudent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudent[P]>
      : GetScalarType<T[P], AggregateStudent[P]>
  }




  export type StudentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentWhereInput
    orderBy?: StudentOrderByWithAggregationInput | StudentOrderByWithAggregationInput[]
    by: StudentScalarFieldEnum[] | StudentScalarFieldEnum
    having?: StudentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentCountAggregateInputType | true
    _avg?: StudentAvgAggregateInputType
    _sum?: StudentSumAggregateInputType
    _min?: StudentMinAggregateInputType
    _max?: StudentMaxAggregateInputType
  }

  export type StudentGroupByOutputType = {
    id: string
    userId: string
    rollNumber: string | null
    department: string | null
    semester: number | null
    cgpa: number | null
    dateOfBirth: Date | null
    phone: string | null
    approved: boolean
    approvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StudentCountAggregateOutputType | null
    _avg: StudentAvgAggregateOutputType | null
    _sum: StudentSumAggregateOutputType | null
    _min: StudentMinAggregateOutputType | null
    _max: StudentMaxAggregateOutputType | null
  }

  type GetStudentGroupByPayload<T extends StudentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentGroupByOutputType[P]>
            : GetScalarType<T[P], StudentGroupByOutputType[P]>
        }
      >
    >


  export type StudentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rollNumber?: boolean
    department?: boolean
    semester?: boolean
    cgpa?: boolean
    dateOfBirth?: boolean
    phone?: boolean
    approved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    applications?: boolean | Student$applicationsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    projects?: boolean | Student$projectsArgs<ExtArgs>
    mentorSessions?: boolean | Student$mentorSessionsArgs<ExtArgs>
    reviews?: boolean | Student$reviewsArgs<ExtArgs>
    logbookEntries?: boolean | Student$logbookEntriesArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    learningProgress?: boolean | Student$learningProgressArgs<ExtArgs>
    certifications?: boolean | Student$certificationsArgs<ExtArgs>
    studentSkills?: boolean | Student$studentSkillsArgs<ExtArgs>
    cvGenerations?: boolean | Student$cvGenerationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    rollNumber?: boolean
    department?: boolean
    semester?: boolean
    cgpa?: boolean
    dateOfBirth?: boolean
    phone?: boolean
    approved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["student"]>

  export type StudentSelectScalar = {
    id?: boolean
    userId?: boolean
    rollNumber?: boolean
    department?: boolean
    semester?: boolean
    cgpa?: boolean
    dateOfBirth?: boolean
    phone?: boolean
    approved?: boolean
    approvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | Student$profileArgs<ExtArgs>
    applications?: boolean | Student$applicationsArgs<ExtArgs>
    enrollments?: boolean | Student$enrollmentsArgs<ExtArgs>
    projects?: boolean | Student$projectsArgs<ExtArgs>
    mentorSessions?: boolean | Student$mentorSessionsArgs<ExtArgs>
    reviews?: boolean | Student$reviewsArgs<ExtArgs>
    logbookEntries?: boolean | Student$logbookEntriesArgs<ExtArgs>
    certificates?: boolean | Student$certificatesArgs<ExtArgs>
    learningProgress?: boolean | Student$learningProgressArgs<ExtArgs>
    certifications?: boolean | Student$certificationsArgs<ExtArgs>
    studentSkills?: boolean | Student$studentSkillsArgs<ExtArgs>
    cvGenerations?: boolean | Student$cvGenerationsArgs<ExtArgs>
    _count?: boolean | StudentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StudentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Student"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      applications: Prisma.$InternshipApplicationPayload<ExtArgs>[]
      enrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
      projects: Prisma.$PortfolioProjectPayload<ExtArgs>[]
      mentorSessions: Prisma.$MentorSessionPayload<ExtArgs>[]
      reviews: Prisma.$MentorReviewPayload<ExtArgs>[]
      logbookEntries: Prisma.$LogbookEntryPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      learningProgress: Prisma.$StudentLearningProgressPayload<ExtArgs>[]
      certifications: Prisma.$CertificationPayload<ExtArgs>[]
      studentSkills: Prisma.$StudentSkillPayload<ExtArgs>[]
      cvGenerations: Prisma.$CVGenerationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      rollNumber: string | null
      department: string | null
      semester: number | null
      cgpa: number | null
      dateOfBirth: Date | null
      phone: string | null
      approved: boolean
      approvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["student"]>
    composites: {}
  }

  type StudentGetPayload<S extends boolean | null | undefined | StudentDefaultArgs> = $Result.GetResult<Prisma.$StudentPayload, S>

  type StudentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentCountAggregateInputType | true
    }

  export interface StudentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Student'], meta: { name: 'Student' } }
    /**
     * Find zero or one Student that matches the filter.
     * @param {StudentFindUniqueArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentFindUniqueArgs>(args: SelectSubset<T, StudentFindUniqueArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Student that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentFindUniqueOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Student that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentFindFirstArgs>(args?: SelectSubset<T, StudentFindFirstArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Student that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindFirstOrThrowArgs} args - Arguments to find a Student
     * @example
     * // Get one Student
     * const student = await prisma.student.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Students that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Students
     * const students = await prisma.student.findMany()
     * 
     * // Get first 10 Students
     * const students = await prisma.student.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentWithIdOnly = await prisma.student.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentFindManyArgs>(args?: SelectSubset<T, StudentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Student.
     * @param {StudentCreateArgs} args - Arguments to create a Student.
     * @example
     * // Create one Student
     * const Student = await prisma.student.create({
     *   data: {
     *     // ... data to create a Student
     *   }
     * })
     * 
     */
    create<T extends StudentCreateArgs>(args: SelectSubset<T, StudentCreateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Students.
     * @param {StudentCreateManyArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentCreateManyArgs>(args?: SelectSubset<T, StudentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Students and returns the data saved in the database.
     * @param {StudentCreateManyAndReturnArgs} args - Arguments to create many Students.
     * @example
     * // Create many Students
     * const student = await prisma.student.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Students and only return the `id`
     * const studentWithIdOnly = await prisma.student.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Student.
     * @param {StudentDeleteArgs} args - Arguments to delete one Student.
     * @example
     * // Delete one Student
     * const Student = await prisma.student.delete({
     *   where: {
     *     // ... filter to delete one Student
     *   }
     * })
     * 
     */
    delete<T extends StudentDeleteArgs>(args: SelectSubset<T, StudentDeleteArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Student.
     * @param {StudentUpdateArgs} args - Arguments to update one Student.
     * @example
     * // Update one Student
     * const student = await prisma.student.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentUpdateArgs>(args: SelectSubset<T, StudentUpdateArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Students.
     * @param {StudentDeleteManyArgs} args - Arguments to filter Students to delete.
     * @example
     * // Delete a few Students
     * const { count } = await prisma.student.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentDeleteManyArgs>(args?: SelectSubset<T, StudentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Students
     * const student = await prisma.student.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentUpdateManyArgs>(args: SelectSubset<T, StudentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Student.
     * @param {StudentUpsertArgs} args - Arguments to update or create a Student.
     * @example
     * // Update or create a Student
     * const student = await prisma.student.upsert({
     *   create: {
     *     // ... data to create a Student
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Student we want to update
     *   }
     * })
     */
    upsert<T extends StudentUpsertArgs>(args: SelectSubset<T, StudentUpsertArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Students.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentCountArgs} args - Arguments to filter Students to count.
     * @example
     * // Count the number of Students
     * const count = await prisma.student.count({
     *   where: {
     *     // ... the filter for the Students we want to count
     *   }
     * })
    **/
    count<T extends StudentCountArgs>(
      args?: Subset<T, StudentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentAggregateArgs>(args: Subset<T, StudentAggregateArgs>): Prisma.PrismaPromise<GetStudentAggregateType<T>>

    /**
     * Group by Student.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentGroupByArgs['orderBy'] }
        : { orderBy?: StudentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Student model
   */
  readonly fields: StudentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Student.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    profile<T extends Student$profileArgs<ExtArgs> = {}>(args?: Subset<T, Student$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    applications<T extends Student$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    enrollments<T extends Student$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Student$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends Student$projectsArgs<ExtArgs> = {}>(args?: Subset<T, Student$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findMany"> | Null>
    mentorSessions<T extends Student$mentorSessionsArgs<ExtArgs> = {}>(args?: Subset<T, Student$mentorSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Student$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Student$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    logbookEntries<T extends Student$logbookEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Student$logbookEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Student$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Student$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    learningProgress<T extends Student$learningProgressArgs<ExtArgs> = {}>(args?: Subset<T, Student$learningProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findMany"> | Null>
    certifications<T extends Student$certificationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$certificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany"> | Null>
    studentSkills<T extends Student$studentSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Student$studentSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findMany"> | Null>
    cvGenerations<T extends Student$cvGenerationsArgs<ExtArgs> = {}>(args?: Subset<T, Student$cvGenerationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Student model
   */ 
  interface StudentFieldRefs {
    readonly id: FieldRef<"Student", 'String'>
    readonly userId: FieldRef<"Student", 'String'>
    readonly rollNumber: FieldRef<"Student", 'String'>
    readonly department: FieldRef<"Student", 'String'>
    readonly semester: FieldRef<"Student", 'Int'>
    readonly cgpa: FieldRef<"Student", 'Float'>
    readonly dateOfBirth: FieldRef<"Student", 'DateTime'>
    readonly phone: FieldRef<"Student", 'String'>
    readonly approved: FieldRef<"Student", 'Boolean'>
    readonly approvedAt: FieldRef<"Student", 'DateTime'>
    readonly createdAt: FieldRef<"Student", 'DateTime'>
    readonly updatedAt: FieldRef<"Student", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Student findUnique
   */
  export type StudentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findUniqueOrThrow
   */
  export type StudentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student findFirst
   */
  export type StudentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findFirstOrThrow
   */
  export type StudentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Student to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Students.
     */
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student findMany
   */
  export type StudentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter, which Students to fetch.
     */
    where?: StudentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Students to fetch.
     */
    orderBy?: StudentOrderByWithRelationInput | StudentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Students.
     */
    cursor?: StudentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Students from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Students.
     */
    skip?: number
    distinct?: StudentScalarFieldEnum | StudentScalarFieldEnum[]
  }

  /**
   * Student create
   */
  export type StudentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to create a Student.
     */
    data: XOR<StudentCreateInput, StudentUncheckedCreateInput>
  }

  /**
   * Student createMany
   */
  export type StudentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
  }

  /**
   * Student createManyAndReturn
   */
  export type StudentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Students.
     */
    data: StudentCreateManyInput | StudentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Student update
   */
  export type StudentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The data needed to update a Student.
     */
    data: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
    /**
     * Choose, which Student to update.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student updateMany
   */
  export type StudentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Students.
     */
    data: XOR<StudentUpdateManyMutationInput, StudentUncheckedUpdateManyInput>
    /**
     * Filter which Students to update
     */
    where?: StudentWhereInput
  }

  /**
   * Student upsert
   */
  export type StudentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * The filter to search for the Student to update in case it exists.
     */
    where: StudentWhereUniqueInput
    /**
     * In case the Student found by the `where` argument doesn't exist, create a new Student with this data.
     */
    create: XOR<StudentCreateInput, StudentUncheckedCreateInput>
    /**
     * In case the Student was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentUpdateInput, StudentUncheckedUpdateInput>
  }

  /**
   * Student delete
   */
  export type StudentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
    /**
     * Filter which Student to delete.
     */
    where: StudentWhereUniqueInput
  }

  /**
   * Student deleteMany
   */
  export type StudentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Students to delete
     */
    where?: StudentWhereInput
  }

  /**
   * Student.profile
   */
  export type Student$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Student.applications
   */
  export type Student$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    where?: InternshipApplicationWhereInput
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    cursor?: InternshipApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipApplicationScalarFieldEnum | InternshipApplicationScalarFieldEnum[]
  }

  /**
   * Student.enrollments
   */
  export type Student$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * Student.projects
   */
  export type Student$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    where?: PortfolioProjectWhereInput
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    cursor?: PortfolioProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * Student.mentorSessions
   */
  export type Student$mentorSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    where?: MentorSessionWhereInput
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    cursor?: MentorSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[]
  }

  /**
   * Student.reviews
   */
  export type Student$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    where?: MentorReviewWhereInput
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    cursor?: MentorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorReviewScalarFieldEnum | MentorReviewScalarFieldEnum[]
  }

  /**
   * Student.logbookEntries
   */
  export type Student$logbookEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    where?: LogbookEntryWhereInput
    orderBy?: LogbookEntryOrderByWithRelationInput | LogbookEntryOrderByWithRelationInput[]
    cursor?: LogbookEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogbookEntryScalarFieldEnum | LogbookEntryScalarFieldEnum[]
  }

  /**
   * Student.certificates
   */
  export type Student$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Student.learningProgress
   */
  export type Student$learningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    where?: StudentLearningProgressWhereInput
    orderBy?: StudentLearningProgressOrderByWithRelationInput | StudentLearningProgressOrderByWithRelationInput[]
    cursor?: StudentLearningProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * Student.certifications
   */
  export type Student$certificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    cursor?: CertificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Student.studentSkills
   */
  export type Student$studentSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    where?: StudentSkillWhereInput
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    cursor?: StudentSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * Student.cvGenerations
   */
  export type Student$cvGenerationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    where?: CVGenerationWhereInput
    orderBy?: CVGenerationOrderByWithRelationInput | CVGenerationOrderByWithRelationInput[]
    cursor?: CVGenerationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CVGenerationScalarFieldEnum | CVGenerationScalarFieldEnum[]
  }

  /**
   * Student without action
   */
  export type StudentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Student
     */
    select?: StudentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    bio: string | null
    gender: string | null
    dob: Date | null
    avatarUrl: string | null
    github: string | null
    linkedin: string | null
    skills: string | null
    interests: string | null
    resumeUrl: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    bio: string | null
    gender: string | null
    dob: Date | null
    avatarUrl: string | null
    github: string | null
    linkedin: string | null
    skills: string | null
    interests: string | null
    resumeUrl: string | null
    department: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    studentId: number
    bio: number
    gender: number
    dob: number
    avatarUrl: number
    github: number
    linkedin: number
    skills: number
    interests: number
    resumeUrl: number
    department: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    studentId?: true
    bio?: true
    gender?: true
    dob?: true
    avatarUrl?: true
    github?: true
    linkedin?: true
    skills?: true
    interests?: true
    resumeUrl?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    studentId?: true
    bio?: true
    gender?: true
    dob?: true
    avatarUrl?: true
    github?: true
    linkedin?: true
    skills?: true
    interests?: true
    resumeUrl?: true
    department?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    studentId?: true
    bio?: true
    gender?: true
    dob?: true
    avatarUrl?: true
    github?: true
    linkedin?: true
    skills?: true
    interests?: true
    resumeUrl?: true
    department?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    studentId: string
    bio: string | null
    gender: string | null
    dob: Date | null
    avatarUrl: string | null
    github: string | null
    linkedin: string | null
    skills: string | null
    interests: string | null
    resumeUrl: string | null
    department: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    bio?: boolean
    gender?: boolean
    dob?: boolean
    avatarUrl?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    resumeUrl?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    bio?: boolean
    gender?: boolean
    dob?: boolean
    avatarUrl?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    resumeUrl?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    studentId?: boolean
    bio?: boolean
    gender?: boolean
    dob?: boolean
    avatarUrl?: boolean
    github?: boolean
    linkedin?: boolean
    skills?: boolean
    interests?: boolean
    resumeUrl?: boolean
    department?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      bio: string | null
      gender: string | null
      dob: Date | null
      avatarUrl: string | null
      github: string | null
      linkedin: string | null
      skills: string | null
      interests: string | null
      resumeUrl: string | null
      department: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly studentId: FieldRef<"Profile", 'String'>
    readonly bio: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'String'>
    readonly dob: FieldRef<"Profile", 'DateTime'>
    readonly avatarUrl: FieldRef<"Profile", 'String'>
    readonly github: FieldRef<"Profile", 'String'>
    readonly linkedin: FieldRef<"Profile", 'String'>
    readonly skills: FieldRef<"Profile", 'String'>
    readonly interests: FieldRef<"Profile", 'String'>
    readonly resumeUrl: FieldRef<"Profile", 'String'>
    readonly department: FieldRef<"Profile", 'String'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Internship
   */

  export type AggregateInternship = {
    _count: InternshipCountAggregateOutputType | null
    _avg: InternshipAvgAggregateOutputType | null
    _sum: InternshipSumAggregateOutputType | null
    _min: InternshipMinAggregateOutputType | null
    _max: InternshipMaxAggregateOutputType | null
  }

  export type InternshipAvgAggregateOutputType = {
    duration: number | null
    stipend: number | null
  }

  export type InternshipSumAggregateOutputType = {
    duration: number | null
    stipend: number | null
  }

  export type InternshipMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    companyName: string | null
    location: string | null
    type: string | null
    duration: number | null
    stipend: number | null
    requiredSkills: string | null
    startDate: Date | null
    endDate: Date | null
    applicationDeadline: Date | null
    isActive: boolean | null
    postedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternshipMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    companyName: string | null
    location: string | null
    type: string | null
    duration: number | null
    stipend: number | null
    requiredSkills: string | null
    startDate: Date | null
    endDate: Date | null
    applicationDeadline: Date | null
    isActive: boolean | null
    postedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InternshipCountAggregateOutputType = {
    id: number
    title: number
    description: number
    companyName: number
    location: number
    type: number
    duration: number
    stipend: number
    requiredSkills: number
    startDate: number
    endDate: number
    applicationDeadline: number
    isActive: number
    postedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InternshipAvgAggregateInputType = {
    duration?: true
    stipend?: true
  }

  export type InternshipSumAggregateInputType = {
    duration?: true
    stipend?: true
  }

  export type InternshipMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    companyName?: true
    location?: true
    type?: true
    duration?: true
    stipend?: true
    requiredSkills?: true
    startDate?: true
    endDate?: true
    applicationDeadline?: true
    isActive?: true
    postedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternshipMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    companyName?: true
    location?: true
    type?: true
    duration?: true
    stipend?: true
    requiredSkills?: true
    startDate?: true
    endDate?: true
    applicationDeadline?: true
    isActive?: true
    postedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InternshipCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    companyName?: true
    location?: true
    type?: true
    duration?: true
    stipend?: true
    requiredSkills?: true
    startDate?: true
    endDate?: true
    applicationDeadline?: true
    isActive?: true
    postedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InternshipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Internship to aggregate.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Internships
    **/
    _count?: true | InternshipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternshipAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternshipSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternshipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternshipMaxAggregateInputType
  }

  export type GetInternshipAggregateType<T extends InternshipAggregateArgs> = {
        [P in keyof T & keyof AggregateInternship]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternship[P]>
      : GetScalarType<T[P], AggregateInternship[P]>
  }




  export type InternshipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipWhereInput
    orderBy?: InternshipOrderByWithAggregationInput | InternshipOrderByWithAggregationInput[]
    by: InternshipScalarFieldEnum[] | InternshipScalarFieldEnum
    having?: InternshipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternshipCountAggregateInputType | true
    _avg?: InternshipAvgAggregateInputType
    _sum?: InternshipSumAggregateInputType
    _min?: InternshipMinAggregateInputType
    _max?: InternshipMaxAggregateInputType
  }

  export type InternshipGroupByOutputType = {
    id: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend: number | null
    requiredSkills: string
    startDate: Date | null
    endDate: Date | null
    applicationDeadline: Date | null
    isActive: boolean
    postedBy: string
    createdAt: Date
    updatedAt: Date
    _count: InternshipCountAggregateOutputType | null
    _avg: InternshipAvgAggregateOutputType | null
    _sum: InternshipSumAggregateOutputType | null
    _min: InternshipMinAggregateOutputType | null
    _max: InternshipMaxAggregateOutputType | null
  }

  type GetInternshipGroupByPayload<T extends InternshipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternshipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternshipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternshipGroupByOutputType[P]>
            : GetScalarType<T[P], InternshipGroupByOutputType[P]>
        }
      >
    >


  export type InternshipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    companyName?: boolean
    location?: boolean
    type?: boolean
    duration?: boolean
    stipend?: boolean
    requiredSkills?: boolean
    startDate?: boolean
    endDate?: boolean
    applicationDeadline?: boolean
    isActive?: boolean
    postedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    applications?: boolean | Internship$applicationsArgs<ExtArgs>
    evaluations?: boolean | Internship$evaluationsArgs<ExtArgs>
    _count?: boolean | InternshipCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internship"]>

  export type InternshipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    companyName?: boolean
    location?: boolean
    type?: boolean
    duration?: boolean
    stipend?: boolean
    requiredSkills?: boolean
    startDate?: boolean
    endDate?: boolean
    applicationDeadline?: boolean
    isActive?: boolean
    postedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["internship"]>

  export type InternshipSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    companyName?: boolean
    location?: boolean
    type?: boolean
    duration?: boolean
    stipend?: boolean
    requiredSkills?: boolean
    startDate?: boolean
    endDate?: boolean
    applicationDeadline?: boolean
    isActive?: boolean
    postedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InternshipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applications?: boolean | Internship$applicationsArgs<ExtArgs>
    evaluations?: boolean | Internship$evaluationsArgs<ExtArgs>
    _count?: boolean | InternshipCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InternshipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InternshipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Internship"
    objects: {
      applications: Prisma.$InternshipApplicationPayload<ExtArgs>[]
      evaluations: Prisma.$InternshipEvaluationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      companyName: string
      location: string
      type: string
      duration: number
      stipend: number | null
      requiredSkills: string
      startDate: Date | null
      endDate: Date | null
      applicationDeadline: Date | null
      isActive: boolean
      postedBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["internship"]>
    composites: {}
  }

  type InternshipGetPayload<S extends boolean | null | undefined | InternshipDefaultArgs> = $Result.GetResult<Prisma.$InternshipPayload, S>

  type InternshipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternshipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternshipCountAggregateInputType | true
    }

  export interface InternshipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Internship'], meta: { name: 'Internship' } }
    /**
     * Find zero or one Internship that matches the filter.
     * @param {InternshipFindUniqueArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternshipFindUniqueArgs>(args: SelectSubset<T, InternshipFindUniqueArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Internship that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternshipFindUniqueOrThrowArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternshipFindUniqueOrThrowArgs>(args: SelectSubset<T, InternshipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Internship that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindFirstArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternshipFindFirstArgs>(args?: SelectSubset<T, InternshipFindFirstArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Internship that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindFirstOrThrowArgs} args - Arguments to find a Internship
     * @example
     * // Get one Internship
     * const internship = await prisma.internship.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternshipFindFirstOrThrowArgs>(args?: SelectSubset<T, InternshipFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Internships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Internships
     * const internships = await prisma.internship.findMany()
     * 
     * // Get first 10 Internships
     * const internships = await prisma.internship.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internshipWithIdOnly = await prisma.internship.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternshipFindManyArgs>(args?: SelectSubset<T, InternshipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Internship.
     * @param {InternshipCreateArgs} args - Arguments to create a Internship.
     * @example
     * // Create one Internship
     * const Internship = await prisma.internship.create({
     *   data: {
     *     // ... data to create a Internship
     *   }
     * })
     * 
     */
    create<T extends InternshipCreateArgs>(args: SelectSubset<T, InternshipCreateArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Internships.
     * @param {InternshipCreateManyArgs} args - Arguments to create many Internships.
     * @example
     * // Create many Internships
     * const internship = await prisma.internship.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternshipCreateManyArgs>(args?: SelectSubset<T, InternshipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Internships and returns the data saved in the database.
     * @param {InternshipCreateManyAndReturnArgs} args - Arguments to create many Internships.
     * @example
     * // Create many Internships
     * const internship = await prisma.internship.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Internships and only return the `id`
     * const internshipWithIdOnly = await prisma.internship.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternshipCreateManyAndReturnArgs>(args?: SelectSubset<T, InternshipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Internship.
     * @param {InternshipDeleteArgs} args - Arguments to delete one Internship.
     * @example
     * // Delete one Internship
     * const Internship = await prisma.internship.delete({
     *   where: {
     *     // ... filter to delete one Internship
     *   }
     * })
     * 
     */
    delete<T extends InternshipDeleteArgs>(args: SelectSubset<T, InternshipDeleteArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Internship.
     * @param {InternshipUpdateArgs} args - Arguments to update one Internship.
     * @example
     * // Update one Internship
     * const internship = await prisma.internship.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternshipUpdateArgs>(args: SelectSubset<T, InternshipUpdateArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Internships.
     * @param {InternshipDeleteManyArgs} args - Arguments to filter Internships to delete.
     * @example
     * // Delete a few Internships
     * const { count } = await prisma.internship.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternshipDeleteManyArgs>(args?: SelectSubset<T, InternshipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Internships
     * const internship = await prisma.internship.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternshipUpdateManyArgs>(args: SelectSubset<T, InternshipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Internship.
     * @param {InternshipUpsertArgs} args - Arguments to update or create a Internship.
     * @example
     * // Update or create a Internship
     * const internship = await prisma.internship.upsert({
     *   create: {
     *     // ... data to create a Internship
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Internship we want to update
     *   }
     * })
     */
    upsert<T extends InternshipUpsertArgs>(args: SelectSubset<T, InternshipUpsertArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Internships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipCountArgs} args - Arguments to filter Internships to count.
     * @example
     * // Count the number of Internships
     * const count = await prisma.internship.count({
     *   where: {
     *     // ... the filter for the Internships we want to count
     *   }
     * })
    **/
    count<T extends InternshipCountArgs>(
      args?: Subset<T, InternshipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternshipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Internship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternshipAggregateArgs>(args: Subset<T, InternshipAggregateArgs>): Prisma.PrismaPromise<GetInternshipAggregateType<T>>

    /**
     * Group by Internship.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternshipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternshipGroupByArgs['orderBy'] }
        : { orderBy?: InternshipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternshipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternshipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Internship model
   */
  readonly fields: InternshipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Internship.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternshipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applications<T extends Internship$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Internship$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findMany"> | Null>
    evaluations<T extends Internship$evaluationsArgs<ExtArgs> = {}>(args?: Subset<T, Internship$evaluationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Internship model
   */ 
  interface InternshipFieldRefs {
    readonly id: FieldRef<"Internship", 'String'>
    readonly title: FieldRef<"Internship", 'String'>
    readonly description: FieldRef<"Internship", 'String'>
    readonly companyName: FieldRef<"Internship", 'String'>
    readonly location: FieldRef<"Internship", 'String'>
    readonly type: FieldRef<"Internship", 'String'>
    readonly duration: FieldRef<"Internship", 'Int'>
    readonly stipend: FieldRef<"Internship", 'Int'>
    readonly requiredSkills: FieldRef<"Internship", 'String'>
    readonly startDate: FieldRef<"Internship", 'DateTime'>
    readonly endDate: FieldRef<"Internship", 'DateTime'>
    readonly applicationDeadline: FieldRef<"Internship", 'DateTime'>
    readonly isActive: FieldRef<"Internship", 'Boolean'>
    readonly postedBy: FieldRef<"Internship", 'String'>
    readonly createdAt: FieldRef<"Internship", 'DateTime'>
    readonly updatedAt: FieldRef<"Internship", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Internship findUnique
   */
  export type InternshipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where: InternshipWhereUniqueInput
  }

  /**
   * Internship findUniqueOrThrow
   */
  export type InternshipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where: InternshipWhereUniqueInput
  }

  /**
   * Internship findFirst
   */
  export type InternshipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Internships.
     */
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }

  /**
   * Internship findFirstOrThrow
   */
  export type InternshipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internship to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Internships.
     */
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }

  /**
   * Internship findMany
   */
  export type InternshipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter, which Internships to fetch.
     */
    where?: InternshipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Internships to fetch.
     */
    orderBy?: InternshipOrderByWithRelationInput | InternshipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Internships.
     */
    cursor?: InternshipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Internships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Internships.
     */
    skip?: number
    distinct?: InternshipScalarFieldEnum | InternshipScalarFieldEnum[]
  }

  /**
   * Internship create
   */
  export type InternshipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The data needed to create a Internship.
     */
    data: XOR<InternshipCreateInput, InternshipUncheckedCreateInput>
  }

  /**
   * Internship createMany
   */
  export type InternshipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Internships.
     */
    data: InternshipCreateManyInput | InternshipCreateManyInput[]
  }

  /**
   * Internship createManyAndReturn
   */
  export type InternshipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Internships.
     */
    data: InternshipCreateManyInput | InternshipCreateManyInput[]
  }

  /**
   * Internship update
   */
  export type InternshipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The data needed to update a Internship.
     */
    data: XOR<InternshipUpdateInput, InternshipUncheckedUpdateInput>
    /**
     * Choose, which Internship to update.
     */
    where: InternshipWhereUniqueInput
  }

  /**
   * Internship updateMany
   */
  export type InternshipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Internships.
     */
    data: XOR<InternshipUpdateManyMutationInput, InternshipUncheckedUpdateManyInput>
    /**
     * Filter which Internships to update
     */
    where?: InternshipWhereInput
  }

  /**
   * Internship upsert
   */
  export type InternshipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * The filter to search for the Internship to update in case it exists.
     */
    where: InternshipWhereUniqueInput
    /**
     * In case the Internship found by the `where` argument doesn't exist, create a new Internship with this data.
     */
    create: XOR<InternshipCreateInput, InternshipUncheckedCreateInput>
    /**
     * In case the Internship was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternshipUpdateInput, InternshipUncheckedUpdateInput>
  }

  /**
   * Internship delete
   */
  export type InternshipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
    /**
     * Filter which Internship to delete.
     */
    where: InternshipWhereUniqueInput
  }

  /**
   * Internship deleteMany
   */
  export type InternshipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Internships to delete
     */
    where?: InternshipWhereInput
  }

  /**
   * Internship.applications
   */
  export type Internship$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    where?: InternshipApplicationWhereInput
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    cursor?: InternshipApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipApplicationScalarFieldEnum | InternshipApplicationScalarFieldEnum[]
  }

  /**
   * Internship.evaluations
   */
  export type Internship$evaluationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    where?: InternshipEvaluationWhereInput
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    cursor?: InternshipEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternshipEvaluationScalarFieldEnum | InternshipEvaluationScalarFieldEnum[]
  }

  /**
   * Internship without action
   */
  export type InternshipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Internship
     */
    select?: InternshipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipInclude<ExtArgs> | null
  }


  /**
   * Model InternshipApplication
   */

  export type AggregateInternshipApplication = {
    _count: InternshipApplicationCountAggregateOutputType | null
    _min: InternshipApplicationMinAggregateOutputType | null
    _max: InternshipApplicationMaxAggregateOutputType | null
  }

  export type InternshipApplicationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    internshipId: string | null
    status: string | null
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date | null
    reviewedAt: Date | null
    rejectionReason: string | null
  }

  export type InternshipApplicationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    internshipId: string | null
    status: string | null
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date | null
    reviewedAt: Date | null
    rejectionReason: string | null
  }

  export type InternshipApplicationCountAggregateOutputType = {
    id: number
    studentId: number
    internshipId: number
    status: number
    coverLetter: number
    resumeUrl: number
    appliedAt: number
    reviewedAt: number
    rejectionReason: number
    _all: number
  }


  export type InternshipApplicationMinAggregateInputType = {
    id?: true
    studentId?: true
    internshipId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    reviewedAt?: true
    rejectionReason?: true
  }

  export type InternshipApplicationMaxAggregateInputType = {
    id?: true
    studentId?: true
    internshipId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    reviewedAt?: true
    rejectionReason?: true
  }

  export type InternshipApplicationCountAggregateInputType = {
    id?: true
    studentId?: true
    internshipId?: true
    status?: true
    coverLetter?: true
    resumeUrl?: true
    appliedAt?: true
    reviewedAt?: true
    rejectionReason?: true
    _all?: true
  }

  export type InternshipApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternshipApplication to aggregate.
     */
    where?: InternshipApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipApplications to fetch.
     */
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternshipApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternshipApplications
    **/
    _count?: true | InternshipApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternshipApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternshipApplicationMaxAggregateInputType
  }

  export type GetInternshipApplicationAggregateType<T extends InternshipApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateInternshipApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternshipApplication[P]>
      : GetScalarType<T[P], AggregateInternshipApplication[P]>
  }




  export type InternshipApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipApplicationWhereInput
    orderBy?: InternshipApplicationOrderByWithAggregationInput | InternshipApplicationOrderByWithAggregationInput[]
    by: InternshipApplicationScalarFieldEnum[] | InternshipApplicationScalarFieldEnum
    having?: InternshipApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternshipApplicationCountAggregateInputType | true
    _min?: InternshipApplicationMinAggregateInputType
    _max?: InternshipApplicationMaxAggregateInputType
  }

  export type InternshipApplicationGroupByOutputType = {
    id: string
    studentId: string
    internshipId: string
    status: string
    coverLetter: string | null
    resumeUrl: string | null
    appliedAt: Date
    reviewedAt: Date | null
    rejectionReason: string | null
    _count: InternshipApplicationCountAggregateOutputType | null
    _min: InternshipApplicationMinAggregateOutputType | null
    _max: InternshipApplicationMaxAggregateOutputType | null
  }

  type GetInternshipApplicationGroupByPayload<T extends InternshipApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternshipApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternshipApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternshipApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], InternshipApplicationGroupByOutputType[P]>
        }
      >
    >


  export type InternshipApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    internshipId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internshipApplication"]>

  export type InternshipApplicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    internshipId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internshipApplication"]>

  export type InternshipApplicationSelectScalar = {
    id?: boolean
    studentId?: boolean
    internshipId?: boolean
    status?: boolean
    coverLetter?: boolean
    resumeUrl?: boolean
    appliedAt?: boolean
    reviewedAt?: boolean
    rejectionReason?: boolean
  }

  export type InternshipApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
  }
  export type InternshipApplicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
  }

  export type $InternshipApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternshipApplication"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      internship: Prisma.$InternshipPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      internshipId: string
      status: string
      coverLetter: string | null
      resumeUrl: string | null
      appliedAt: Date
      reviewedAt: Date | null
      rejectionReason: string | null
    }, ExtArgs["result"]["internshipApplication"]>
    composites: {}
  }

  type InternshipApplicationGetPayload<S extends boolean | null | undefined | InternshipApplicationDefaultArgs> = $Result.GetResult<Prisma.$InternshipApplicationPayload, S>

  type InternshipApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternshipApplicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternshipApplicationCountAggregateInputType | true
    }

  export interface InternshipApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternshipApplication'], meta: { name: 'InternshipApplication' } }
    /**
     * Find zero or one InternshipApplication that matches the filter.
     * @param {InternshipApplicationFindUniqueArgs} args - Arguments to find a InternshipApplication
     * @example
     * // Get one InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternshipApplicationFindUniqueArgs>(args: SelectSubset<T, InternshipApplicationFindUniqueArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InternshipApplication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternshipApplicationFindUniqueOrThrowArgs} args - Arguments to find a InternshipApplication
     * @example
     * // Get one InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternshipApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, InternshipApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InternshipApplication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationFindFirstArgs} args - Arguments to find a InternshipApplication
     * @example
     * // Get one InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternshipApplicationFindFirstArgs>(args?: SelectSubset<T, InternshipApplicationFindFirstArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InternshipApplication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationFindFirstOrThrowArgs} args - Arguments to find a InternshipApplication
     * @example
     * // Get one InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternshipApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, InternshipApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InternshipApplications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternshipApplications
     * const internshipApplications = await prisma.internshipApplication.findMany()
     * 
     * // Get first 10 InternshipApplications
     * const internshipApplications = await prisma.internshipApplication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internshipApplicationWithIdOnly = await prisma.internshipApplication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternshipApplicationFindManyArgs>(args?: SelectSubset<T, InternshipApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InternshipApplication.
     * @param {InternshipApplicationCreateArgs} args - Arguments to create a InternshipApplication.
     * @example
     * // Create one InternshipApplication
     * const InternshipApplication = await prisma.internshipApplication.create({
     *   data: {
     *     // ... data to create a InternshipApplication
     *   }
     * })
     * 
     */
    create<T extends InternshipApplicationCreateArgs>(args: SelectSubset<T, InternshipApplicationCreateArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InternshipApplications.
     * @param {InternshipApplicationCreateManyArgs} args - Arguments to create many InternshipApplications.
     * @example
     * // Create many InternshipApplications
     * const internshipApplication = await prisma.internshipApplication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternshipApplicationCreateManyArgs>(args?: SelectSubset<T, InternshipApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InternshipApplications and returns the data saved in the database.
     * @param {InternshipApplicationCreateManyAndReturnArgs} args - Arguments to create many InternshipApplications.
     * @example
     * // Create many InternshipApplications
     * const internshipApplication = await prisma.internshipApplication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InternshipApplications and only return the `id`
     * const internshipApplicationWithIdOnly = await prisma.internshipApplication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternshipApplicationCreateManyAndReturnArgs>(args?: SelectSubset<T, InternshipApplicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InternshipApplication.
     * @param {InternshipApplicationDeleteArgs} args - Arguments to delete one InternshipApplication.
     * @example
     * // Delete one InternshipApplication
     * const InternshipApplication = await prisma.internshipApplication.delete({
     *   where: {
     *     // ... filter to delete one InternshipApplication
     *   }
     * })
     * 
     */
    delete<T extends InternshipApplicationDeleteArgs>(args: SelectSubset<T, InternshipApplicationDeleteArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InternshipApplication.
     * @param {InternshipApplicationUpdateArgs} args - Arguments to update one InternshipApplication.
     * @example
     * // Update one InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternshipApplicationUpdateArgs>(args: SelectSubset<T, InternshipApplicationUpdateArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InternshipApplications.
     * @param {InternshipApplicationDeleteManyArgs} args - Arguments to filter InternshipApplications to delete.
     * @example
     * // Delete a few InternshipApplications
     * const { count } = await prisma.internshipApplication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternshipApplicationDeleteManyArgs>(args?: SelectSubset<T, InternshipApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternshipApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternshipApplications
     * const internshipApplication = await prisma.internshipApplication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternshipApplicationUpdateManyArgs>(args: SelectSubset<T, InternshipApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternshipApplication.
     * @param {InternshipApplicationUpsertArgs} args - Arguments to update or create a InternshipApplication.
     * @example
     * // Update or create a InternshipApplication
     * const internshipApplication = await prisma.internshipApplication.upsert({
     *   create: {
     *     // ... data to create a InternshipApplication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternshipApplication we want to update
     *   }
     * })
     */
    upsert<T extends InternshipApplicationUpsertArgs>(args: SelectSubset<T, InternshipApplicationUpsertArgs<ExtArgs>>): Prisma__InternshipApplicationClient<$Result.GetResult<Prisma.$InternshipApplicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InternshipApplications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationCountArgs} args - Arguments to filter InternshipApplications to count.
     * @example
     * // Count the number of InternshipApplications
     * const count = await prisma.internshipApplication.count({
     *   where: {
     *     // ... the filter for the InternshipApplications we want to count
     *   }
     * })
    **/
    count<T extends InternshipApplicationCountArgs>(
      args?: Subset<T, InternshipApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternshipApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternshipApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternshipApplicationAggregateArgs>(args: Subset<T, InternshipApplicationAggregateArgs>): Prisma.PrismaPromise<GetInternshipApplicationAggregateType<T>>

    /**
     * Group by InternshipApplication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternshipApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternshipApplicationGroupByArgs['orderBy'] }
        : { orderBy?: InternshipApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternshipApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternshipApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternshipApplication model
   */
  readonly fields: InternshipApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternshipApplication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternshipApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    internship<T extends InternshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InternshipDefaultArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternshipApplication model
   */ 
  interface InternshipApplicationFieldRefs {
    readonly id: FieldRef<"InternshipApplication", 'String'>
    readonly studentId: FieldRef<"InternshipApplication", 'String'>
    readonly internshipId: FieldRef<"InternshipApplication", 'String'>
    readonly status: FieldRef<"InternshipApplication", 'String'>
    readonly coverLetter: FieldRef<"InternshipApplication", 'String'>
    readonly resumeUrl: FieldRef<"InternshipApplication", 'String'>
    readonly appliedAt: FieldRef<"InternshipApplication", 'DateTime'>
    readonly reviewedAt: FieldRef<"InternshipApplication", 'DateTime'>
    readonly rejectionReason: FieldRef<"InternshipApplication", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InternshipApplication findUnique
   */
  export type InternshipApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipApplication to fetch.
     */
    where: InternshipApplicationWhereUniqueInput
  }

  /**
   * InternshipApplication findUniqueOrThrow
   */
  export type InternshipApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipApplication to fetch.
     */
    where: InternshipApplicationWhereUniqueInput
  }

  /**
   * InternshipApplication findFirst
   */
  export type InternshipApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipApplication to fetch.
     */
    where?: InternshipApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipApplications to fetch.
     */
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternshipApplications.
     */
    cursor?: InternshipApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternshipApplications.
     */
    distinct?: InternshipApplicationScalarFieldEnum | InternshipApplicationScalarFieldEnum[]
  }

  /**
   * InternshipApplication findFirstOrThrow
   */
  export type InternshipApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipApplication to fetch.
     */
    where?: InternshipApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipApplications to fetch.
     */
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternshipApplications.
     */
    cursor?: InternshipApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipApplications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternshipApplications.
     */
    distinct?: InternshipApplicationScalarFieldEnum | InternshipApplicationScalarFieldEnum[]
  }

  /**
   * InternshipApplication findMany
   */
  export type InternshipApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipApplications to fetch.
     */
    where?: InternshipApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipApplications to fetch.
     */
    orderBy?: InternshipApplicationOrderByWithRelationInput | InternshipApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternshipApplications.
     */
    cursor?: InternshipApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipApplications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipApplications.
     */
    skip?: number
    distinct?: InternshipApplicationScalarFieldEnum | InternshipApplicationScalarFieldEnum[]
  }

  /**
   * InternshipApplication create
   */
  export type InternshipApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a InternshipApplication.
     */
    data: XOR<InternshipApplicationCreateInput, InternshipApplicationUncheckedCreateInput>
  }

  /**
   * InternshipApplication createMany
   */
  export type InternshipApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternshipApplications.
     */
    data: InternshipApplicationCreateManyInput | InternshipApplicationCreateManyInput[]
  }

  /**
   * InternshipApplication createManyAndReturn
   */
  export type InternshipApplicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InternshipApplications.
     */
    data: InternshipApplicationCreateManyInput | InternshipApplicationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InternshipApplication update
   */
  export type InternshipApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a InternshipApplication.
     */
    data: XOR<InternshipApplicationUpdateInput, InternshipApplicationUncheckedUpdateInput>
    /**
     * Choose, which InternshipApplication to update.
     */
    where: InternshipApplicationWhereUniqueInput
  }

  /**
   * InternshipApplication updateMany
   */
  export type InternshipApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternshipApplications.
     */
    data: XOR<InternshipApplicationUpdateManyMutationInput, InternshipApplicationUncheckedUpdateManyInput>
    /**
     * Filter which InternshipApplications to update
     */
    where?: InternshipApplicationWhereInput
  }

  /**
   * InternshipApplication upsert
   */
  export type InternshipApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the InternshipApplication to update in case it exists.
     */
    where: InternshipApplicationWhereUniqueInput
    /**
     * In case the InternshipApplication found by the `where` argument doesn't exist, create a new InternshipApplication with this data.
     */
    create: XOR<InternshipApplicationCreateInput, InternshipApplicationUncheckedCreateInput>
    /**
     * In case the InternshipApplication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternshipApplicationUpdateInput, InternshipApplicationUncheckedUpdateInput>
  }

  /**
   * InternshipApplication delete
   */
  export type InternshipApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
    /**
     * Filter which InternshipApplication to delete.
     */
    where: InternshipApplicationWhereUniqueInput
  }

  /**
   * InternshipApplication deleteMany
   */
  export type InternshipApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternshipApplications to delete
     */
    where?: InternshipApplicationWhereInput
  }

  /**
   * InternshipApplication without action
   */
  export type InternshipApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipApplication
     */
    select?: InternshipApplicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipApplicationInclude<ExtArgs> | null
  }


  /**
   * Model InternshipEvaluation
   */

  export type AggregateInternshipEvaluation = {
    _count: InternshipEvaluationCountAggregateOutputType | null
    _avg: InternshipEvaluationAvgAggregateOutputType | null
    _sum: InternshipEvaluationSumAggregateOutputType | null
    _min: InternshipEvaluationMinAggregateOutputType | null
    _max: InternshipEvaluationMaxAggregateOutputType | null
  }

  export type InternshipEvaluationAvgAggregateOutputType = {
    finalScore: number | null
  }

  export type InternshipEvaluationSumAggregateOutputType = {
    finalScore: number | null
  }

  export type InternshipEvaluationMinAggregateOutputType = {
    id: string | null
    internshipId: string | null
    evaluatorId: string | null
    facultyId: string | null
    rubricJson: string | null
    comments: string | null
    finalScore: number | null
    createdAt: Date | null
  }

  export type InternshipEvaluationMaxAggregateOutputType = {
    id: string | null
    internshipId: string | null
    evaluatorId: string | null
    facultyId: string | null
    rubricJson: string | null
    comments: string | null
    finalScore: number | null
    createdAt: Date | null
  }

  export type InternshipEvaluationCountAggregateOutputType = {
    id: number
    internshipId: number
    evaluatorId: number
    facultyId: number
    rubricJson: number
    comments: number
    finalScore: number
    createdAt: number
    _all: number
  }


  export type InternshipEvaluationAvgAggregateInputType = {
    finalScore?: true
  }

  export type InternshipEvaluationSumAggregateInputType = {
    finalScore?: true
  }

  export type InternshipEvaluationMinAggregateInputType = {
    id?: true
    internshipId?: true
    evaluatorId?: true
    facultyId?: true
    rubricJson?: true
    comments?: true
    finalScore?: true
    createdAt?: true
  }

  export type InternshipEvaluationMaxAggregateInputType = {
    id?: true
    internshipId?: true
    evaluatorId?: true
    facultyId?: true
    rubricJson?: true
    comments?: true
    finalScore?: true
    createdAt?: true
  }

  export type InternshipEvaluationCountAggregateInputType = {
    id?: true
    internshipId?: true
    evaluatorId?: true
    facultyId?: true
    rubricJson?: true
    comments?: true
    finalScore?: true
    createdAt?: true
    _all?: true
  }

  export type InternshipEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternshipEvaluation to aggregate.
     */
    where?: InternshipEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipEvaluations to fetch.
     */
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternshipEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternshipEvaluations
    **/
    _count?: true | InternshipEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternshipEvaluationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternshipEvaluationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternshipEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternshipEvaluationMaxAggregateInputType
  }

  export type GetInternshipEvaluationAggregateType<T extends InternshipEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateInternshipEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternshipEvaluation[P]>
      : GetScalarType<T[P], AggregateInternshipEvaluation[P]>
  }




  export type InternshipEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternshipEvaluationWhereInput
    orderBy?: InternshipEvaluationOrderByWithAggregationInput | InternshipEvaluationOrderByWithAggregationInput[]
    by: InternshipEvaluationScalarFieldEnum[] | InternshipEvaluationScalarFieldEnum
    having?: InternshipEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternshipEvaluationCountAggregateInputType | true
    _avg?: InternshipEvaluationAvgAggregateInputType
    _sum?: InternshipEvaluationSumAggregateInputType
    _min?: InternshipEvaluationMinAggregateInputType
    _max?: InternshipEvaluationMaxAggregateInputType
  }

  export type InternshipEvaluationGroupByOutputType = {
    id: string
    internshipId: string
    evaluatorId: string
    facultyId: string
    rubricJson: string
    comments: string | null
    finalScore: number
    createdAt: Date
    _count: InternshipEvaluationCountAggregateOutputType | null
    _avg: InternshipEvaluationAvgAggregateOutputType | null
    _sum: InternshipEvaluationSumAggregateOutputType | null
    _min: InternshipEvaluationMinAggregateOutputType | null
    _max: InternshipEvaluationMaxAggregateOutputType | null
  }

  type GetInternshipEvaluationGroupByPayload<T extends InternshipEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternshipEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternshipEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternshipEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], InternshipEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type InternshipEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internshipId?: boolean
    evaluatorId?: boolean
    facultyId?: boolean
    rubricJson?: boolean
    comments?: boolean
    finalScore?: boolean
    createdAt?: boolean
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internshipEvaluation"]>

  export type InternshipEvaluationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    internshipId?: boolean
    evaluatorId?: boolean
    facultyId?: boolean
    rubricJson?: boolean
    comments?: boolean
    finalScore?: boolean
    createdAt?: boolean
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internshipEvaluation"]>

  export type InternshipEvaluationSelectScalar = {
    id?: boolean
    internshipId?: boolean
    evaluatorId?: boolean
    facultyId?: boolean
    rubricJson?: boolean
    comments?: boolean
    finalScore?: boolean
    createdAt?: boolean
  }

  export type InternshipEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InternshipEvaluationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    internship?: boolean | InternshipDefaultArgs<ExtArgs>
    evaluator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InternshipEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternshipEvaluation"
    objects: {
      internship: Prisma.$InternshipPayload<ExtArgs>
      evaluator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      internshipId: string
      evaluatorId: string
      facultyId: string
      rubricJson: string
      comments: string | null
      finalScore: number
      createdAt: Date
    }, ExtArgs["result"]["internshipEvaluation"]>
    composites: {}
  }

  type InternshipEvaluationGetPayload<S extends boolean | null | undefined | InternshipEvaluationDefaultArgs> = $Result.GetResult<Prisma.$InternshipEvaluationPayload, S>

  type InternshipEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternshipEvaluationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternshipEvaluationCountAggregateInputType | true
    }

  export interface InternshipEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternshipEvaluation'], meta: { name: 'InternshipEvaluation' } }
    /**
     * Find zero or one InternshipEvaluation that matches the filter.
     * @param {InternshipEvaluationFindUniqueArgs} args - Arguments to find a InternshipEvaluation
     * @example
     * // Get one InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternshipEvaluationFindUniqueArgs>(args: SelectSubset<T, InternshipEvaluationFindUniqueArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InternshipEvaluation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternshipEvaluationFindUniqueOrThrowArgs} args - Arguments to find a InternshipEvaluation
     * @example
     * // Get one InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternshipEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, InternshipEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InternshipEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationFindFirstArgs} args - Arguments to find a InternshipEvaluation
     * @example
     * // Get one InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternshipEvaluationFindFirstArgs>(args?: SelectSubset<T, InternshipEvaluationFindFirstArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InternshipEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationFindFirstOrThrowArgs} args - Arguments to find a InternshipEvaluation
     * @example
     * // Get one InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternshipEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, InternshipEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InternshipEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternshipEvaluations
     * const internshipEvaluations = await prisma.internshipEvaluation.findMany()
     * 
     * // Get first 10 InternshipEvaluations
     * const internshipEvaluations = await prisma.internshipEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const internshipEvaluationWithIdOnly = await prisma.internshipEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InternshipEvaluationFindManyArgs>(args?: SelectSubset<T, InternshipEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InternshipEvaluation.
     * @param {InternshipEvaluationCreateArgs} args - Arguments to create a InternshipEvaluation.
     * @example
     * // Create one InternshipEvaluation
     * const InternshipEvaluation = await prisma.internshipEvaluation.create({
     *   data: {
     *     // ... data to create a InternshipEvaluation
     *   }
     * })
     * 
     */
    create<T extends InternshipEvaluationCreateArgs>(args: SelectSubset<T, InternshipEvaluationCreateArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InternshipEvaluations.
     * @param {InternshipEvaluationCreateManyArgs} args - Arguments to create many InternshipEvaluations.
     * @example
     * // Create many InternshipEvaluations
     * const internshipEvaluation = await prisma.internshipEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternshipEvaluationCreateManyArgs>(args?: SelectSubset<T, InternshipEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InternshipEvaluations and returns the data saved in the database.
     * @param {InternshipEvaluationCreateManyAndReturnArgs} args - Arguments to create many InternshipEvaluations.
     * @example
     * // Create many InternshipEvaluations
     * const internshipEvaluation = await prisma.internshipEvaluation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InternshipEvaluations and only return the `id`
     * const internshipEvaluationWithIdOnly = await prisma.internshipEvaluation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InternshipEvaluationCreateManyAndReturnArgs>(args?: SelectSubset<T, InternshipEvaluationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InternshipEvaluation.
     * @param {InternshipEvaluationDeleteArgs} args - Arguments to delete one InternshipEvaluation.
     * @example
     * // Delete one InternshipEvaluation
     * const InternshipEvaluation = await prisma.internshipEvaluation.delete({
     *   where: {
     *     // ... filter to delete one InternshipEvaluation
     *   }
     * })
     * 
     */
    delete<T extends InternshipEvaluationDeleteArgs>(args: SelectSubset<T, InternshipEvaluationDeleteArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InternshipEvaluation.
     * @param {InternshipEvaluationUpdateArgs} args - Arguments to update one InternshipEvaluation.
     * @example
     * // Update one InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternshipEvaluationUpdateArgs>(args: SelectSubset<T, InternshipEvaluationUpdateArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InternshipEvaluations.
     * @param {InternshipEvaluationDeleteManyArgs} args - Arguments to filter InternshipEvaluations to delete.
     * @example
     * // Delete a few InternshipEvaluations
     * const { count } = await prisma.internshipEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternshipEvaluationDeleteManyArgs>(args?: SelectSubset<T, InternshipEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternshipEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternshipEvaluations
     * const internshipEvaluation = await prisma.internshipEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternshipEvaluationUpdateManyArgs>(args: SelectSubset<T, InternshipEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternshipEvaluation.
     * @param {InternshipEvaluationUpsertArgs} args - Arguments to update or create a InternshipEvaluation.
     * @example
     * // Update or create a InternshipEvaluation
     * const internshipEvaluation = await prisma.internshipEvaluation.upsert({
     *   create: {
     *     // ... data to create a InternshipEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternshipEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends InternshipEvaluationUpsertArgs>(args: SelectSubset<T, InternshipEvaluationUpsertArgs<ExtArgs>>): Prisma__InternshipEvaluationClient<$Result.GetResult<Prisma.$InternshipEvaluationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InternshipEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationCountArgs} args - Arguments to filter InternshipEvaluations to count.
     * @example
     * // Count the number of InternshipEvaluations
     * const count = await prisma.internshipEvaluation.count({
     *   where: {
     *     // ... the filter for the InternshipEvaluations we want to count
     *   }
     * })
    **/
    count<T extends InternshipEvaluationCountArgs>(
      args?: Subset<T, InternshipEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternshipEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternshipEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternshipEvaluationAggregateArgs>(args: Subset<T, InternshipEvaluationAggregateArgs>): Prisma.PrismaPromise<GetInternshipEvaluationAggregateType<T>>

    /**
     * Group by InternshipEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternshipEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternshipEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternshipEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: InternshipEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternshipEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternshipEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternshipEvaluation model
   */
  readonly fields: InternshipEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternshipEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternshipEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    internship<T extends InternshipDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InternshipDefaultArgs<ExtArgs>>): Prisma__InternshipClient<$Result.GetResult<Prisma.$InternshipPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evaluator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternshipEvaluation model
   */ 
  interface InternshipEvaluationFieldRefs {
    readonly id: FieldRef<"InternshipEvaluation", 'String'>
    readonly internshipId: FieldRef<"InternshipEvaluation", 'String'>
    readonly evaluatorId: FieldRef<"InternshipEvaluation", 'String'>
    readonly facultyId: FieldRef<"InternshipEvaluation", 'String'>
    readonly rubricJson: FieldRef<"InternshipEvaluation", 'String'>
    readonly comments: FieldRef<"InternshipEvaluation", 'String'>
    readonly finalScore: FieldRef<"InternshipEvaluation", 'Float'>
    readonly createdAt: FieldRef<"InternshipEvaluation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InternshipEvaluation findUnique
   */
  export type InternshipEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipEvaluation to fetch.
     */
    where: InternshipEvaluationWhereUniqueInput
  }

  /**
   * InternshipEvaluation findUniqueOrThrow
   */
  export type InternshipEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipEvaluation to fetch.
     */
    where: InternshipEvaluationWhereUniqueInput
  }

  /**
   * InternshipEvaluation findFirst
   */
  export type InternshipEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipEvaluation to fetch.
     */
    where?: InternshipEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipEvaluations to fetch.
     */
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternshipEvaluations.
     */
    cursor?: InternshipEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternshipEvaluations.
     */
    distinct?: InternshipEvaluationScalarFieldEnum | InternshipEvaluationScalarFieldEnum[]
  }

  /**
   * InternshipEvaluation findFirstOrThrow
   */
  export type InternshipEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipEvaluation to fetch.
     */
    where?: InternshipEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipEvaluations to fetch.
     */
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternshipEvaluations.
     */
    cursor?: InternshipEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternshipEvaluations.
     */
    distinct?: InternshipEvaluationScalarFieldEnum | InternshipEvaluationScalarFieldEnum[]
  }

  /**
   * InternshipEvaluation findMany
   */
  export type InternshipEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which InternshipEvaluations to fetch.
     */
    where?: InternshipEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternshipEvaluations to fetch.
     */
    orderBy?: InternshipEvaluationOrderByWithRelationInput | InternshipEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternshipEvaluations.
     */
    cursor?: InternshipEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternshipEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternshipEvaluations.
     */
    skip?: number
    distinct?: InternshipEvaluationScalarFieldEnum | InternshipEvaluationScalarFieldEnum[]
  }

  /**
   * InternshipEvaluation create
   */
  export type InternshipEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a InternshipEvaluation.
     */
    data: XOR<InternshipEvaluationCreateInput, InternshipEvaluationUncheckedCreateInput>
  }

  /**
   * InternshipEvaluation createMany
   */
  export type InternshipEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternshipEvaluations.
     */
    data: InternshipEvaluationCreateManyInput | InternshipEvaluationCreateManyInput[]
  }

  /**
   * InternshipEvaluation createManyAndReturn
   */
  export type InternshipEvaluationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InternshipEvaluations.
     */
    data: InternshipEvaluationCreateManyInput | InternshipEvaluationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InternshipEvaluation update
   */
  export type InternshipEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a InternshipEvaluation.
     */
    data: XOR<InternshipEvaluationUpdateInput, InternshipEvaluationUncheckedUpdateInput>
    /**
     * Choose, which InternshipEvaluation to update.
     */
    where: InternshipEvaluationWhereUniqueInput
  }

  /**
   * InternshipEvaluation updateMany
   */
  export type InternshipEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternshipEvaluations.
     */
    data: XOR<InternshipEvaluationUpdateManyMutationInput, InternshipEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which InternshipEvaluations to update
     */
    where?: InternshipEvaluationWhereInput
  }

  /**
   * InternshipEvaluation upsert
   */
  export type InternshipEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the InternshipEvaluation to update in case it exists.
     */
    where: InternshipEvaluationWhereUniqueInput
    /**
     * In case the InternshipEvaluation found by the `where` argument doesn't exist, create a new InternshipEvaluation with this data.
     */
    create: XOR<InternshipEvaluationCreateInput, InternshipEvaluationUncheckedCreateInput>
    /**
     * In case the InternshipEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternshipEvaluationUpdateInput, InternshipEvaluationUncheckedUpdateInput>
  }

  /**
   * InternshipEvaluation delete
   */
  export type InternshipEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
    /**
     * Filter which InternshipEvaluation to delete.
     */
    where: InternshipEvaluationWhereUniqueInput
  }

  /**
   * InternshipEvaluation deleteMany
   */
  export type InternshipEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternshipEvaluations to delete
     */
    where?: InternshipEvaluationWhereInput
  }

  /**
   * InternshipEvaluation without action
   */
  export type InternshipEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternshipEvaluation
     */
    select?: InternshipEvaluationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternshipEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model Course
   */

  export type AggregateCourse = {
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  export type CourseAvgAggregateOutputType = {
    price: number | null
  }

  export type CourseSumAggregateOutputType = {
    price: number | null
  }

  export type CourseMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    price: number | null
    thumbnail: string | null
    instructorId: string | null
    thumbnailUrl: string | null
    createdAt: Date | null
  }

  export type CourseMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    type: string | null
    price: number | null
    thumbnail: string | null
    instructorId: string | null
    thumbnailUrl: string | null
    createdAt: Date | null
  }

  export type CourseCountAggregateOutputType = {
    id: number
    title: number
    description: number
    type: number
    price: number
    thumbnail: number
    instructorId: number
    thumbnailUrl: number
    createdAt: number
    _all: number
  }


  export type CourseAvgAggregateInputType = {
    price?: true
  }

  export type CourseSumAggregateInputType = {
    price?: true
  }

  export type CourseMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    thumbnail?: true
    instructorId?: true
    thumbnailUrl?: true
    createdAt?: true
  }

  export type CourseMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    thumbnail?: true
    instructorId?: true
    thumbnailUrl?: true
    createdAt?: true
  }

  export type CourseCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    type?: true
    price?: true
    thumbnail?: true
    instructorId?: true
    thumbnailUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CourseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Course to aggregate.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Courses
    **/
    _count?: true | CourseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseMaxAggregateInputType
  }

  export type GetCourseAggregateType<T extends CourseAggregateArgs> = {
        [P in keyof T & keyof AggregateCourse]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourse[P]>
      : GetScalarType<T[P], AggregateCourse[P]>
  }




  export type CourseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseWhereInput
    orderBy?: CourseOrderByWithAggregationInput | CourseOrderByWithAggregationInput[]
    by: CourseScalarFieldEnum[] | CourseScalarFieldEnum
    having?: CourseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseCountAggregateInputType | true
    _avg?: CourseAvgAggregateInputType
    _sum?: CourseSumAggregateInputType
    _min?: CourseMinAggregateInputType
    _max?: CourseMaxAggregateInputType
  }

  export type CourseGroupByOutputType = {
    id: string
    title: string
    description: string
    type: string
    price: number | null
    thumbnail: string | null
    instructorId: string
    thumbnailUrl: string | null
    createdAt: Date
    _count: CourseCountAggregateOutputType | null
    _avg: CourseAvgAggregateOutputType | null
    _sum: CourseSumAggregateOutputType | null
    _min: CourseMinAggregateOutputType | null
    _max: CourseMaxAggregateOutputType | null
  }

  type GetCourseGroupByPayload<T extends CourseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseGroupByOutputType[P]>
            : GetScalarType<T[P], CourseGroupByOutputType[P]>
        }
      >
    >


  export type CourseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    thumbnail?: boolean
    instructorId?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    checkpoints?: boolean | Course$checkpointsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["course"]>

  export type CourseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    thumbnail?: boolean
    instructorId?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["course"]>

  export type CourseSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    type?: boolean
    price?: boolean
    thumbnail?: boolean
    instructorId?: boolean
    thumbnailUrl?: boolean
    createdAt?: boolean
  }

  export type CourseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    enrollments?: boolean | Course$enrollmentsArgs<ExtArgs>
    checkpoints?: boolean | Course$checkpointsArgs<ExtArgs>
    _count?: boolean | CourseCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CourseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CoursePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Course"
    objects: {
      enrollments: Prisma.$CourseEnrollmentPayload<ExtArgs>[]
      checkpoints: Prisma.$CheckpointPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      type: string
      price: number | null
      thumbnail: string | null
      instructorId: string
      thumbnailUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["course"]>
    composites: {}
  }

  type CourseGetPayload<S extends boolean | null | undefined | CourseDefaultArgs> = $Result.GetResult<Prisma.$CoursePayload, S>

  type CourseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseCountAggregateInputType | true
    }

  export interface CourseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Course'], meta: { name: 'Course' } }
    /**
     * Find zero or one Course that matches the filter.
     * @param {CourseFindUniqueArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseFindUniqueArgs>(args: SelectSubset<T, CourseFindUniqueArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Course that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseFindUniqueOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Course that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseFindFirstArgs>(args?: SelectSubset<T, CourseFindFirstArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Course that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindFirstOrThrowArgs} args - Arguments to find a Course
     * @example
     * // Get one Course
     * const course = await prisma.course.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Courses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Courses
     * const courses = await prisma.course.findMany()
     * 
     * // Get first 10 Courses
     * const courses = await prisma.course.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseWithIdOnly = await prisma.course.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseFindManyArgs>(args?: SelectSubset<T, CourseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Course.
     * @param {CourseCreateArgs} args - Arguments to create a Course.
     * @example
     * // Create one Course
     * const Course = await prisma.course.create({
     *   data: {
     *     // ... data to create a Course
     *   }
     * })
     * 
     */
    create<T extends CourseCreateArgs>(args: SelectSubset<T, CourseCreateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Courses.
     * @param {CourseCreateManyArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseCreateManyArgs>(args?: SelectSubset<T, CourseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Courses and returns the data saved in the database.
     * @param {CourseCreateManyAndReturnArgs} args - Arguments to create many Courses.
     * @example
     * // Create many Courses
     * const course = await prisma.course.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Courses and only return the `id`
     * const courseWithIdOnly = await prisma.course.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Course.
     * @param {CourseDeleteArgs} args - Arguments to delete one Course.
     * @example
     * // Delete one Course
     * const Course = await prisma.course.delete({
     *   where: {
     *     // ... filter to delete one Course
     *   }
     * })
     * 
     */
    delete<T extends CourseDeleteArgs>(args: SelectSubset<T, CourseDeleteArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Course.
     * @param {CourseUpdateArgs} args - Arguments to update one Course.
     * @example
     * // Update one Course
     * const course = await prisma.course.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseUpdateArgs>(args: SelectSubset<T, CourseUpdateArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Courses.
     * @param {CourseDeleteManyArgs} args - Arguments to filter Courses to delete.
     * @example
     * // Delete a few Courses
     * const { count } = await prisma.course.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseDeleteManyArgs>(args?: SelectSubset<T, CourseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Courses
     * const course = await prisma.course.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseUpdateManyArgs>(args: SelectSubset<T, CourseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Course.
     * @param {CourseUpsertArgs} args - Arguments to update or create a Course.
     * @example
     * // Update or create a Course
     * const course = await prisma.course.upsert({
     *   create: {
     *     // ... data to create a Course
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Course we want to update
     *   }
     * })
     */
    upsert<T extends CourseUpsertArgs>(args: SelectSubset<T, CourseUpsertArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Courses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseCountArgs} args - Arguments to filter Courses to count.
     * @example
     * // Count the number of Courses
     * const count = await prisma.course.count({
     *   where: {
     *     // ... the filter for the Courses we want to count
     *   }
     * })
    **/
    count<T extends CourseCountArgs>(
      args?: Subset<T, CourseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseAggregateArgs>(args: Subset<T, CourseAggregateArgs>): Prisma.PrismaPromise<GetCourseAggregateType<T>>

    /**
     * Group by Course.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseGroupByArgs['orderBy'] }
        : { orderBy?: CourseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Course model
   */
  readonly fields: CourseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Course.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    enrollments<T extends Course$enrollmentsArgs<ExtArgs> = {}>(args?: Subset<T, Course$enrollmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany"> | Null>
    checkpoints<T extends Course$checkpointsArgs<ExtArgs> = {}>(args?: Subset<T, Course$checkpointsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Course model
   */ 
  interface CourseFieldRefs {
    readonly id: FieldRef<"Course", 'String'>
    readonly title: FieldRef<"Course", 'String'>
    readonly description: FieldRef<"Course", 'String'>
    readonly type: FieldRef<"Course", 'String'>
    readonly price: FieldRef<"Course", 'Float'>
    readonly thumbnail: FieldRef<"Course", 'String'>
    readonly instructorId: FieldRef<"Course", 'String'>
    readonly thumbnailUrl: FieldRef<"Course", 'String'>
    readonly createdAt: FieldRef<"Course", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Course findUnique
   */
  export type CourseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findUniqueOrThrow
   */
  export type CourseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course findFirst
   */
  export type CourseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findFirstOrThrow
   */
  export type CourseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Course to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Courses.
     */
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course findMany
   */
  export type CourseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter, which Courses to fetch.
     */
    where?: CourseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Courses to fetch.
     */
    orderBy?: CourseOrderByWithRelationInput | CourseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Courses.
     */
    cursor?: CourseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Courses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Courses.
     */
    skip?: number
    distinct?: CourseScalarFieldEnum | CourseScalarFieldEnum[]
  }

  /**
   * Course create
   */
  export type CourseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to create a Course.
     */
    data: XOR<CourseCreateInput, CourseUncheckedCreateInput>
  }

  /**
   * Course createMany
   */
  export type CourseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
  }

  /**
   * Course createManyAndReturn
   */
  export type CourseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Courses.
     */
    data: CourseCreateManyInput | CourseCreateManyInput[]
  }

  /**
   * Course update
   */
  export type CourseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The data needed to update a Course.
     */
    data: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
    /**
     * Choose, which Course to update.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course updateMany
   */
  export type CourseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Courses.
     */
    data: XOR<CourseUpdateManyMutationInput, CourseUncheckedUpdateManyInput>
    /**
     * Filter which Courses to update
     */
    where?: CourseWhereInput
  }

  /**
   * Course upsert
   */
  export type CourseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * The filter to search for the Course to update in case it exists.
     */
    where: CourseWhereUniqueInput
    /**
     * In case the Course found by the `where` argument doesn't exist, create a new Course with this data.
     */
    create: XOR<CourseCreateInput, CourseUncheckedCreateInput>
    /**
     * In case the Course was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseUpdateInput, CourseUncheckedUpdateInput>
  }

  /**
   * Course delete
   */
  export type CourseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
    /**
     * Filter which Course to delete.
     */
    where: CourseWhereUniqueInput
  }

  /**
   * Course deleteMany
   */
  export type CourseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Courses to delete
     */
    where?: CourseWhereInput
  }

  /**
   * Course.enrollments
   */
  export type Course$enrollmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    cursor?: CourseEnrollmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * Course.checkpoints
   */
  export type Course$checkpointsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    where?: CheckpointWhereInput
    orderBy?: CheckpointOrderByWithRelationInput | CheckpointOrderByWithRelationInput[]
    cursor?: CheckpointWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * Course without action
   */
  export type CourseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Course
     */
    select?: CourseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseInclude<ExtArgs> | null
  }


  /**
   * Model CourseEnrollment
   */

  export type AggregateCourseEnrollment = {
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  export type CourseEnrollmentAvgAggregateOutputType = {
    progressPercent: number | null
  }

  export type CourseEnrollmentSumAggregateOutputType = {
    progressPercent: number | null
  }

  export type CourseEnrollmentMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    enrolledAt: Date | null
    progressPercent: number | null
    completedAt: Date | null
  }

  export type CourseEnrollmentMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    courseId: string | null
    enrolledAt: Date | null
    progressPercent: number | null
    completedAt: Date | null
  }

  export type CourseEnrollmentCountAggregateOutputType = {
    id: number
    studentId: number
    courseId: number
    enrolledAt: number
    progressPercent: number
    completedAt: number
    _all: number
  }


  export type CourseEnrollmentAvgAggregateInputType = {
    progressPercent?: true
  }

  export type CourseEnrollmentSumAggregateInputType = {
    progressPercent?: true
  }

  export type CourseEnrollmentMinAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    enrolledAt?: true
    progressPercent?: true
    completedAt?: true
  }

  export type CourseEnrollmentMaxAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    enrolledAt?: true
    progressPercent?: true
    completedAt?: true
  }

  export type CourseEnrollmentCountAggregateInputType = {
    id?: true
    studentId?: true
    courseId?: true
    enrolledAt?: true
    progressPercent?: true
    completedAt?: true
    _all?: true
  }

  export type CourseEnrollmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollment to aggregate.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CourseEnrollments
    **/
    _count?: true | CourseEnrollmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CourseEnrollmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CourseEnrollmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CourseEnrollmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type GetCourseEnrollmentAggregateType<T extends CourseEnrollmentAggregateArgs> = {
        [P in keyof T & keyof AggregateCourseEnrollment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCourseEnrollment[P]>
      : GetScalarType<T[P], AggregateCourseEnrollment[P]>
  }




  export type CourseEnrollmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CourseEnrollmentWhereInput
    orderBy?: CourseEnrollmentOrderByWithAggregationInput | CourseEnrollmentOrderByWithAggregationInput[]
    by: CourseEnrollmentScalarFieldEnum[] | CourseEnrollmentScalarFieldEnum
    having?: CourseEnrollmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CourseEnrollmentCountAggregateInputType | true
    _avg?: CourseEnrollmentAvgAggregateInputType
    _sum?: CourseEnrollmentSumAggregateInputType
    _min?: CourseEnrollmentMinAggregateInputType
    _max?: CourseEnrollmentMaxAggregateInputType
  }

  export type CourseEnrollmentGroupByOutputType = {
    id: string
    studentId: string
    courseId: string
    enrolledAt: Date
    progressPercent: number
    completedAt: Date | null
    _count: CourseEnrollmentCountAggregateOutputType | null
    _avg: CourseEnrollmentAvgAggregateOutputType | null
    _sum: CourseEnrollmentSumAggregateOutputType | null
    _min: CourseEnrollmentMinAggregateOutputType | null
    _max: CourseEnrollmentMaxAggregateOutputType | null
  }

  type GetCourseEnrollmentGroupByPayload<T extends CourseEnrollmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CourseEnrollmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CourseEnrollmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
            : GetScalarType<T[P], CourseEnrollmentGroupByOutputType[P]>
        }
      >
    >


  export type CourseEnrollmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    progressPercent?: boolean
    completedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    progressPercent?: boolean
    completedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["courseEnrollment"]>

  export type CourseEnrollmentSelectScalar = {
    id?: boolean
    studentId?: boolean
    courseId?: boolean
    enrolledAt?: boolean
    progressPercent?: boolean
    completedAt?: boolean
  }

  export type CourseEnrollmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CourseEnrollmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CourseEnrollment"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      courseId: string
      enrolledAt: Date
      progressPercent: number
      completedAt: Date | null
    }, ExtArgs["result"]["courseEnrollment"]>
    composites: {}
  }

  type CourseEnrollmentGetPayload<S extends boolean | null | undefined | CourseEnrollmentDefaultArgs> = $Result.GetResult<Prisma.$CourseEnrollmentPayload, S>

  type CourseEnrollmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CourseEnrollmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CourseEnrollmentCountAggregateInputType | true
    }

  export interface CourseEnrollmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CourseEnrollment'], meta: { name: 'CourseEnrollment' } }
    /**
     * Find zero or one CourseEnrollment that matches the filter.
     * @param {CourseEnrollmentFindUniqueArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CourseEnrollmentFindUniqueArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CourseEnrollment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CourseEnrollmentFindUniqueOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CourseEnrollmentFindUniqueOrThrowArgs>(args: SelectSubset<T, CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CourseEnrollment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CourseEnrollmentFindFirstArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CourseEnrollment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindFirstOrThrowArgs} args - Arguments to find a CourseEnrollment
     * @example
     * // Get one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CourseEnrollmentFindFirstOrThrowArgs>(args?: SelectSubset<T, CourseEnrollmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CourseEnrollments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany()
     * 
     * // Get first 10 CourseEnrollments
     * const courseEnrollments = await prisma.courseEnrollment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CourseEnrollmentFindManyArgs>(args?: SelectSubset<T, CourseEnrollmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CourseEnrollment.
     * @param {CourseEnrollmentCreateArgs} args - Arguments to create a CourseEnrollment.
     * @example
     * // Create one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.create({
     *   data: {
     *     // ... data to create a CourseEnrollment
     *   }
     * })
     * 
     */
    create<T extends CourseEnrollmentCreateArgs>(args: SelectSubset<T, CourseEnrollmentCreateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CourseEnrollments.
     * @param {CourseEnrollmentCreateManyArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CourseEnrollmentCreateManyArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CourseEnrollments and returns the data saved in the database.
     * @param {CourseEnrollmentCreateManyAndReturnArgs} args - Arguments to create many CourseEnrollments.
     * @example
     * // Create many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CourseEnrollments and only return the `id`
     * const courseEnrollmentWithIdOnly = await prisma.courseEnrollment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CourseEnrollmentCreateManyAndReturnArgs>(args?: SelectSubset<T, CourseEnrollmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CourseEnrollment.
     * @param {CourseEnrollmentDeleteArgs} args - Arguments to delete one CourseEnrollment.
     * @example
     * // Delete one CourseEnrollment
     * const CourseEnrollment = await prisma.courseEnrollment.delete({
     *   where: {
     *     // ... filter to delete one CourseEnrollment
     *   }
     * })
     * 
     */
    delete<T extends CourseEnrollmentDeleteArgs>(args: SelectSubset<T, CourseEnrollmentDeleteArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CourseEnrollment.
     * @param {CourseEnrollmentUpdateArgs} args - Arguments to update one CourseEnrollment.
     * @example
     * // Update one CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CourseEnrollmentUpdateArgs>(args: SelectSubset<T, CourseEnrollmentUpdateArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CourseEnrollments.
     * @param {CourseEnrollmentDeleteManyArgs} args - Arguments to filter CourseEnrollments to delete.
     * @example
     * // Delete a few CourseEnrollments
     * const { count } = await prisma.courseEnrollment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CourseEnrollmentDeleteManyArgs>(args?: SelectSubset<T, CourseEnrollmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CourseEnrollments
     * const courseEnrollment = await prisma.courseEnrollment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CourseEnrollmentUpdateManyArgs>(args: SelectSubset<T, CourseEnrollmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CourseEnrollment.
     * @param {CourseEnrollmentUpsertArgs} args - Arguments to update or create a CourseEnrollment.
     * @example
     * // Update or create a CourseEnrollment
     * const courseEnrollment = await prisma.courseEnrollment.upsert({
     *   create: {
     *     // ... data to create a CourseEnrollment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CourseEnrollment we want to update
     *   }
     * })
     */
    upsert<T extends CourseEnrollmentUpsertArgs>(args: SelectSubset<T, CourseEnrollmentUpsertArgs<ExtArgs>>): Prisma__CourseEnrollmentClient<$Result.GetResult<Prisma.$CourseEnrollmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CourseEnrollments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentCountArgs} args - Arguments to filter CourseEnrollments to count.
     * @example
     * // Count the number of CourseEnrollments
     * const count = await prisma.courseEnrollment.count({
     *   where: {
     *     // ... the filter for the CourseEnrollments we want to count
     *   }
     * })
    **/
    count<T extends CourseEnrollmentCountArgs>(
      args?: Subset<T, CourseEnrollmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CourseEnrollmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CourseEnrollmentAggregateArgs>(args: Subset<T, CourseEnrollmentAggregateArgs>): Prisma.PrismaPromise<GetCourseEnrollmentAggregateType<T>>

    /**
     * Group by CourseEnrollment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CourseEnrollmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CourseEnrollmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CourseEnrollmentGroupByArgs['orderBy'] }
        : { orderBy?: CourseEnrollmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CourseEnrollmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCourseEnrollmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CourseEnrollment model
   */
  readonly fields: CourseEnrollmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CourseEnrollment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CourseEnrollmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CourseEnrollment model
   */ 
  interface CourseEnrollmentFieldRefs {
    readonly id: FieldRef<"CourseEnrollment", 'String'>
    readonly studentId: FieldRef<"CourseEnrollment", 'String'>
    readonly courseId: FieldRef<"CourseEnrollment", 'String'>
    readonly enrolledAt: FieldRef<"CourseEnrollment", 'DateTime'>
    readonly progressPercent: FieldRef<"CourseEnrollment", 'Int'>
    readonly completedAt: FieldRef<"CourseEnrollment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CourseEnrollment findUnique
   */
  export type CourseEnrollmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findUniqueOrThrow
   */
  export type CourseEnrollmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment findFirst
   */
  export type CourseEnrollmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findFirstOrThrow
   */
  export type CourseEnrollmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollment to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CourseEnrollments.
     */
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment findMany
   */
  export type CourseEnrollmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter, which CourseEnrollments to fetch.
     */
    where?: CourseEnrollmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CourseEnrollments to fetch.
     */
    orderBy?: CourseEnrollmentOrderByWithRelationInput | CourseEnrollmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CourseEnrollments.
     */
    cursor?: CourseEnrollmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CourseEnrollments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CourseEnrollments.
     */
    skip?: number
    distinct?: CourseEnrollmentScalarFieldEnum | CourseEnrollmentScalarFieldEnum[]
  }

  /**
   * CourseEnrollment create
   */
  export type CourseEnrollmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to create a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
  }

  /**
   * CourseEnrollment createMany
   */
  export type CourseEnrollmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
  }

  /**
   * CourseEnrollment createManyAndReturn
   */
  export type CourseEnrollmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CourseEnrollments.
     */
    data: CourseEnrollmentCreateManyInput | CourseEnrollmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CourseEnrollment update
   */
  export type CourseEnrollmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The data needed to update a CourseEnrollment.
     */
    data: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
    /**
     * Choose, which CourseEnrollment to update.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment updateMany
   */
  export type CourseEnrollmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CourseEnrollments.
     */
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyInput>
    /**
     * Filter which CourseEnrollments to update
     */
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseEnrollment upsert
   */
  export type CourseEnrollmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * The filter to search for the CourseEnrollment to update in case it exists.
     */
    where: CourseEnrollmentWhereUniqueInput
    /**
     * In case the CourseEnrollment found by the `where` argument doesn't exist, create a new CourseEnrollment with this data.
     */
    create: XOR<CourseEnrollmentCreateInput, CourseEnrollmentUncheckedCreateInput>
    /**
     * In case the CourseEnrollment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CourseEnrollmentUpdateInput, CourseEnrollmentUncheckedUpdateInput>
  }

  /**
   * CourseEnrollment delete
   */
  export type CourseEnrollmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
    /**
     * Filter which CourseEnrollment to delete.
     */
    where: CourseEnrollmentWhereUniqueInput
  }

  /**
   * CourseEnrollment deleteMany
   */
  export type CourseEnrollmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CourseEnrollments to delete
     */
    where?: CourseEnrollmentWhereInput
  }

  /**
   * CourseEnrollment without action
   */
  export type CourseEnrollmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CourseEnrollment
     */
    select?: CourseEnrollmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CourseEnrollmentInclude<ExtArgs> | null
  }


  /**
   * Model Checkpoint
   */

  export type AggregateCheckpoint = {
    _count: CheckpointCountAggregateOutputType | null
    _min: CheckpointMinAggregateOutputType | null
    _max: CheckpointMaxAggregateOutputType | null
  }

  export type CheckpointMinAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    resourceUrl: string | null
  }

  export type CheckpointMaxAggregateOutputType = {
    id: string | null
    courseId: string | null
    title: string | null
    description: string | null
    resourceUrl: string | null
  }

  export type CheckpointCountAggregateOutputType = {
    id: number
    courseId: number
    title: number
    description: number
    resourceUrl: number
    _all: number
  }


  export type CheckpointMinAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    resourceUrl?: true
  }

  export type CheckpointMaxAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    resourceUrl?: true
  }

  export type CheckpointCountAggregateInputType = {
    id?: true
    courseId?: true
    title?: true
    description?: true
    resourceUrl?: true
    _all?: true
  }

  export type CheckpointAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkpoint to aggregate.
     */
    where?: CheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkpoints to fetch.
     */
    orderBy?: CheckpointOrderByWithRelationInput | CheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Checkpoints
    **/
    _count?: true | CheckpointCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CheckpointMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CheckpointMaxAggregateInputType
  }

  export type GetCheckpointAggregateType<T extends CheckpointAggregateArgs> = {
        [P in keyof T & keyof AggregateCheckpoint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCheckpoint[P]>
      : GetScalarType<T[P], AggregateCheckpoint[P]>
  }




  export type CheckpointGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CheckpointWhereInput
    orderBy?: CheckpointOrderByWithAggregationInput | CheckpointOrderByWithAggregationInput[]
    by: CheckpointScalarFieldEnum[] | CheckpointScalarFieldEnum
    having?: CheckpointScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CheckpointCountAggregateInputType | true
    _min?: CheckpointMinAggregateInputType
    _max?: CheckpointMaxAggregateInputType
  }

  export type CheckpointGroupByOutputType = {
    id: string
    courseId: string
    title: string
    description: string | null
    resourceUrl: string | null
    _count: CheckpointCountAggregateOutputType | null
    _min: CheckpointMinAggregateOutputType | null
    _max: CheckpointMaxAggregateOutputType | null
  }

  type GetCheckpointGroupByPayload<T extends CheckpointGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CheckpointGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CheckpointGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CheckpointGroupByOutputType[P]>
            : GetScalarType<T[P], CheckpointGroupByOutputType[P]>
        }
      >
    >


  export type CheckpointSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    resourceUrl?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoint"]>

  export type CheckpointSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    resourceUrl?: boolean
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checkpoint"]>

  export type CheckpointSelectScalar = {
    id?: boolean
    courseId?: boolean
    title?: boolean
    description?: boolean
    resourceUrl?: boolean
  }

  export type CheckpointInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }
  export type CheckpointIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    course?: boolean | CourseDefaultArgs<ExtArgs>
  }

  export type $CheckpointPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Checkpoint"
    objects: {
      course: Prisma.$CoursePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      courseId: string
      title: string
      description: string | null
      resourceUrl: string | null
    }, ExtArgs["result"]["checkpoint"]>
    composites: {}
  }

  type CheckpointGetPayload<S extends boolean | null | undefined | CheckpointDefaultArgs> = $Result.GetResult<Prisma.$CheckpointPayload, S>

  type CheckpointCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CheckpointFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CheckpointCountAggregateInputType | true
    }

  export interface CheckpointDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Checkpoint'], meta: { name: 'Checkpoint' } }
    /**
     * Find zero or one Checkpoint that matches the filter.
     * @param {CheckpointFindUniqueArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CheckpointFindUniqueArgs>(args: SelectSubset<T, CheckpointFindUniqueArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Checkpoint that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CheckpointFindUniqueOrThrowArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CheckpointFindUniqueOrThrowArgs>(args: SelectSubset<T, CheckpointFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Checkpoint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointFindFirstArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CheckpointFindFirstArgs>(args?: SelectSubset<T, CheckpointFindFirstArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Checkpoint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointFindFirstOrThrowArgs} args - Arguments to find a Checkpoint
     * @example
     * // Get one Checkpoint
     * const checkpoint = await prisma.checkpoint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CheckpointFindFirstOrThrowArgs>(args?: SelectSubset<T, CheckpointFindFirstOrThrowArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Checkpoints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checkpoints
     * const checkpoints = await prisma.checkpoint.findMany()
     * 
     * // Get first 10 Checkpoints
     * const checkpoints = await prisma.checkpoint.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checkpointWithIdOnly = await prisma.checkpoint.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CheckpointFindManyArgs>(args?: SelectSubset<T, CheckpointFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Checkpoint.
     * @param {CheckpointCreateArgs} args - Arguments to create a Checkpoint.
     * @example
     * // Create one Checkpoint
     * const Checkpoint = await prisma.checkpoint.create({
     *   data: {
     *     // ... data to create a Checkpoint
     *   }
     * })
     * 
     */
    create<T extends CheckpointCreateArgs>(args: SelectSubset<T, CheckpointCreateArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Checkpoints.
     * @param {CheckpointCreateManyArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoint = await prisma.checkpoint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CheckpointCreateManyArgs>(args?: SelectSubset<T, CheckpointCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Checkpoints and returns the data saved in the database.
     * @param {CheckpointCreateManyAndReturnArgs} args - Arguments to create many Checkpoints.
     * @example
     * // Create many Checkpoints
     * const checkpoint = await prisma.checkpoint.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Checkpoints and only return the `id`
     * const checkpointWithIdOnly = await prisma.checkpoint.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CheckpointCreateManyAndReturnArgs>(args?: SelectSubset<T, CheckpointCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Checkpoint.
     * @param {CheckpointDeleteArgs} args - Arguments to delete one Checkpoint.
     * @example
     * // Delete one Checkpoint
     * const Checkpoint = await prisma.checkpoint.delete({
     *   where: {
     *     // ... filter to delete one Checkpoint
     *   }
     * })
     * 
     */
    delete<T extends CheckpointDeleteArgs>(args: SelectSubset<T, CheckpointDeleteArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Checkpoint.
     * @param {CheckpointUpdateArgs} args - Arguments to update one Checkpoint.
     * @example
     * // Update one Checkpoint
     * const checkpoint = await prisma.checkpoint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CheckpointUpdateArgs>(args: SelectSubset<T, CheckpointUpdateArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Checkpoints.
     * @param {CheckpointDeleteManyArgs} args - Arguments to filter Checkpoints to delete.
     * @example
     * // Delete a few Checkpoints
     * const { count } = await prisma.checkpoint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CheckpointDeleteManyArgs>(args?: SelectSubset<T, CheckpointDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checkpoints
     * const checkpoint = await prisma.checkpoint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CheckpointUpdateManyArgs>(args: SelectSubset<T, CheckpointUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checkpoint.
     * @param {CheckpointUpsertArgs} args - Arguments to update or create a Checkpoint.
     * @example
     * // Update or create a Checkpoint
     * const checkpoint = await prisma.checkpoint.upsert({
     *   create: {
     *     // ... data to create a Checkpoint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checkpoint we want to update
     *   }
     * })
     */
    upsert<T extends CheckpointUpsertArgs>(args: SelectSubset<T, CheckpointUpsertArgs<ExtArgs>>): Prisma__CheckpointClient<$Result.GetResult<Prisma.$CheckpointPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Checkpoints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointCountArgs} args - Arguments to filter Checkpoints to count.
     * @example
     * // Count the number of Checkpoints
     * const count = await prisma.checkpoint.count({
     *   where: {
     *     // ... the filter for the Checkpoints we want to count
     *   }
     * })
    **/
    count<T extends CheckpointCountArgs>(
      args?: Subset<T, CheckpointCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CheckpointCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checkpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CheckpointAggregateArgs>(args: Subset<T, CheckpointAggregateArgs>): Prisma.PrismaPromise<GetCheckpointAggregateType<T>>

    /**
     * Group by Checkpoint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CheckpointGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CheckpointGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CheckpointGroupByArgs['orderBy'] }
        : { orderBy?: CheckpointGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CheckpointGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCheckpointGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Checkpoint model
   */
  readonly fields: CheckpointFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Checkpoint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CheckpointClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    course<T extends CourseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CourseDefaultArgs<ExtArgs>>): Prisma__CourseClient<$Result.GetResult<Prisma.$CoursePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Checkpoint model
   */ 
  interface CheckpointFieldRefs {
    readonly id: FieldRef<"Checkpoint", 'String'>
    readonly courseId: FieldRef<"Checkpoint", 'String'>
    readonly title: FieldRef<"Checkpoint", 'String'>
    readonly description: FieldRef<"Checkpoint", 'String'>
    readonly resourceUrl: FieldRef<"Checkpoint", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Checkpoint findUnique
   */
  export type CheckpointFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter, which Checkpoint to fetch.
     */
    where: CheckpointWhereUniqueInput
  }

  /**
   * Checkpoint findUniqueOrThrow
   */
  export type CheckpointFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter, which Checkpoint to fetch.
     */
    where: CheckpointWhereUniqueInput
  }

  /**
   * Checkpoint findFirst
   */
  export type CheckpointFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter, which Checkpoint to fetch.
     */
    where?: CheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkpoints to fetch.
     */
    orderBy?: CheckpointOrderByWithRelationInput | CheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkpoints.
     */
    cursor?: CheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkpoints.
     */
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * Checkpoint findFirstOrThrow
   */
  export type CheckpointFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter, which Checkpoint to fetch.
     */
    where?: CheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkpoints to fetch.
     */
    orderBy?: CheckpointOrderByWithRelationInput | CheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Checkpoints.
     */
    cursor?: CheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkpoints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Checkpoints.
     */
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * Checkpoint findMany
   */
  export type CheckpointFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter, which Checkpoints to fetch.
     */
    where?: CheckpointWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Checkpoints to fetch.
     */
    orderBy?: CheckpointOrderByWithRelationInput | CheckpointOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Checkpoints.
     */
    cursor?: CheckpointWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Checkpoints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Checkpoints.
     */
    skip?: number
    distinct?: CheckpointScalarFieldEnum | CheckpointScalarFieldEnum[]
  }

  /**
   * Checkpoint create
   */
  export type CheckpointCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * The data needed to create a Checkpoint.
     */
    data: XOR<CheckpointCreateInput, CheckpointUncheckedCreateInput>
  }

  /**
   * Checkpoint createMany
   */
  export type CheckpointCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Checkpoints.
     */
    data: CheckpointCreateManyInput | CheckpointCreateManyInput[]
  }

  /**
   * Checkpoint createManyAndReturn
   */
  export type CheckpointCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Checkpoints.
     */
    data: CheckpointCreateManyInput | CheckpointCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Checkpoint update
   */
  export type CheckpointUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * The data needed to update a Checkpoint.
     */
    data: XOR<CheckpointUpdateInput, CheckpointUncheckedUpdateInput>
    /**
     * Choose, which Checkpoint to update.
     */
    where: CheckpointWhereUniqueInput
  }

  /**
   * Checkpoint updateMany
   */
  export type CheckpointUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Checkpoints.
     */
    data: XOR<CheckpointUpdateManyMutationInput, CheckpointUncheckedUpdateManyInput>
    /**
     * Filter which Checkpoints to update
     */
    where?: CheckpointWhereInput
  }

  /**
   * Checkpoint upsert
   */
  export type CheckpointUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * The filter to search for the Checkpoint to update in case it exists.
     */
    where: CheckpointWhereUniqueInput
    /**
     * In case the Checkpoint found by the `where` argument doesn't exist, create a new Checkpoint with this data.
     */
    create: XOR<CheckpointCreateInput, CheckpointUncheckedCreateInput>
    /**
     * In case the Checkpoint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CheckpointUpdateInput, CheckpointUncheckedUpdateInput>
  }

  /**
   * Checkpoint delete
   */
  export type CheckpointDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
    /**
     * Filter which Checkpoint to delete.
     */
    where: CheckpointWhereUniqueInput
  }

  /**
   * Checkpoint deleteMany
   */
  export type CheckpointDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Checkpoints to delete
     */
    where?: CheckpointWhereInput
  }

  /**
   * Checkpoint without action
   */
  export type CheckpointDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checkpoint
     */
    select?: CheckpointSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CheckpointInclude<ExtArgs> | null
  }


  /**
   * Model PortfolioProject
   */

  export type AggregatePortfolioProject = {
    _count: PortfolioProjectCountAggregateOutputType | null
    _avg: PortfolioProjectAvgAggregateOutputType | null
    _sum: PortfolioProjectSumAggregateOutputType | null
    _min: PortfolioProjectMinAggregateOutputType | null
    _max: PortfolioProjectMaxAggregateOutputType | null
  }

  export type PortfolioProjectAvgAggregateOutputType = {
    stars: number | null
    forks: number | null
  }

  export type PortfolioProjectSumAggregateOutputType = {
    stars: number | null
    forks: number | null
  }

  export type PortfolioProjectMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    description: string | null
    githubUrl: string | null
    liveUrl: string | null
    tags: string | null
    createdAt: Date | null
    source: string | null
    githubRepoId: string | null
    lastSyncedAt: Date | null
    stars: number | null
    forks: number | null
    language: string | null
  }

  export type PortfolioProjectMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    description: string | null
    githubUrl: string | null
    liveUrl: string | null
    tags: string | null
    createdAt: Date | null
    source: string | null
    githubRepoId: string | null
    lastSyncedAt: Date | null
    stars: number | null
    forks: number | null
    language: string | null
  }

  export type PortfolioProjectCountAggregateOutputType = {
    id: number
    studentId: number
    title: number
    description: number
    githubUrl: number
    liveUrl: number
    tags: number
    createdAt: number
    source: number
    githubRepoId: number
    lastSyncedAt: number
    stars: number
    forks: number
    language: number
    _all: number
  }


  export type PortfolioProjectAvgAggregateInputType = {
    stars?: true
    forks?: true
  }

  export type PortfolioProjectSumAggregateInputType = {
    stars?: true
    forks?: true
  }

  export type PortfolioProjectMinAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    githubUrl?: true
    liveUrl?: true
    tags?: true
    createdAt?: true
    source?: true
    githubRepoId?: true
    lastSyncedAt?: true
    stars?: true
    forks?: true
    language?: true
  }

  export type PortfolioProjectMaxAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    githubUrl?: true
    liveUrl?: true
    tags?: true
    createdAt?: true
    source?: true
    githubRepoId?: true
    lastSyncedAt?: true
    stars?: true
    forks?: true
    language?: true
  }

  export type PortfolioProjectCountAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    description?: true
    githubUrl?: true
    liveUrl?: true
    tags?: true
    createdAt?: true
    source?: true
    githubRepoId?: true
    lastSyncedAt?: true
    stars?: true
    forks?: true
    language?: true
    _all?: true
  }

  export type PortfolioProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioProject to aggregate.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortfolioProjects
    **/
    _count?: true | PortfolioProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PortfolioProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PortfolioProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortfolioProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortfolioProjectMaxAggregateInputType
  }

  export type GetPortfolioProjectAggregateType<T extends PortfolioProjectAggregateArgs> = {
        [P in keyof T & keyof AggregatePortfolioProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortfolioProject[P]>
      : GetScalarType<T[P], AggregatePortfolioProject[P]>
  }




  export type PortfolioProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortfolioProjectWhereInput
    orderBy?: PortfolioProjectOrderByWithAggregationInput | PortfolioProjectOrderByWithAggregationInput[]
    by: PortfolioProjectScalarFieldEnum[] | PortfolioProjectScalarFieldEnum
    having?: PortfolioProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortfolioProjectCountAggregateInputType | true
    _avg?: PortfolioProjectAvgAggregateInputType
    _sum?: PortfolioProjectSumAggregateInputType
    _min?: PortfolioProjectMinAggregateInputType
    _max?: PortfolioProjectMaxAggregateInputType
  }

  export type PortfolioProjectGroupByOutputType = {
    id: string
    studentId: string
    title: string
    description: string
    githubUrl: string | null
    liveUrl: string | null
    tags: string | null
    createdAt: Date
    source: string
    githubRepoId: string | null
    lastSyncedAt: Date | null
    stars: number
    forks: number
    language: string | null
    _count: PortfolioProjectCountAggregateOutputType | null
    _avg: PortfolioProjectAvgAggregateOutputType | null
    _sum: PortfolioProjectSumAggregateOutputType | null
    _min: PortfolioProjectMinAggregateOutputType | null
    _max: PortfolioProjectMaxAggregateOutputType | null
  }

  type GetPortfolioProjectGroupByPayload<T extends PortfolioProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortfolioProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortfolioProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortfolioProjectGroupByOutputType[P]>
            : GetScalarType<T[P], PortfolioProjectGroupByOutputType[P]>
        }
      >
    >


  export type PortfolioProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    source?: boolean
    githubRepoId?: boolean
    lastSyncedAt?: boolean
    stars?: boolean
    forks?: boolean
    language?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioProject"]>

  export type PortfolioProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    source?: boolean
    githubRepoId?: boolean
    lastSyncedAt?: boolean
    stars?: boolean
    forks?: boolean
    language?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portfolioProject"]>

  export type PortfolioProjectSelectScalar = {
    id?: boolean
    studentId?: boolean
    title?: boolean
    description?: boolean
    githubUrl?: boolean
    liveUrl?: boolean
    tags?: boolean
    createdAt?: boolean
    source?: boolean
    githubRepoId?: boolean
    lastSyncedAt?: boolean
    stars?: boolean
    forks?: boolean
    language?: boolean
  }

  export type PortfolioProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type PortfolioProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $PortfolioProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortfolioProject"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      title: string
      description: string
      githubUrl: string | null
      liveUrl: string | null
      tags: string | null
      createdAt: Date
      source: string
      githubRepoId: string | null
      lastSyncedAt: Date | null
      stars: number
      forks: number
      language: string | null
    }, ExtArgs["result"]["portfolioProject"]>
    composites: {}
  }

  type PortfolioProjectGetPayload<S extends boolean | null | undefined | PortfolioProjectDefaultArgs> = $Result.GetResult<Prisma.$PortfolioProjectPayload, S>

  type PortfolioProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PortfolioProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PortfolioProjectCountAggregateInputType | true
    }

  export interface PortfolioProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortfolioProject'], meta: { name: 'PortfolioProject' } }
    /**
     * Find zero or one PortfolioProject that matches the filter.
     * @param {PortfolioProjectFindUniqueArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortfolioProjectFindUniqueArgs>(args: SelectSubset<T, PortfolioProjectFindUniqueArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PortfolioProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PortfolioProjectFindUniqueOrThrowArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortfolioProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, PortfolioProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PortfolioProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindFirstArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortfolioProjectFindFirstArgs>(args?: SelectSubset<T, PortfolioProjectFindFirstArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PortfolioProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindFirstOrThrowArgs} args - Arguments to find a PortfolioProject
     * @example
     * // Get one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortfolioProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, PortfolioProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PortfolioProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProject.findMany()
     * 
     * // Get first 10 PortfolioProjects
     * const portfolioProjects = await prisma.portfolioProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portfolioProjectWithIdOnly = await prisma.portfolioProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortfolioProjectFindManyArgs>(args?: SelectSubset<T, PortfolioProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PortfolioProject.
     * @param {PortfolioProjectCreateArgs} args - Arguments to create a PortfolioProject.
     * @example
     * // Create one PortfolioProject
     * const PortfolioProject = await prisma.portfolioProject.create({
     *   data: {
     *     // ... data to create a PortfolioProject
     *   }
     * })
     * 
     */
    create<T extends PortfolioProjectCreateArgs>(args: SelectSubset<T, PortfolioProjectCreateArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PortfolioProjects.
     * @param {PortfolioProjectCreateManyArgs} args - Arguments to create many PortfolioProjects.
     * @example
     * // Create many PortfolioProjects
     * const portfolioProject = await prisma.portfolioProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortfolioProjectCreateManyArgs>(args?: SelectSubset<T, PortfolioProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortfolioProjects and returns the data saved in the database.
     * @param {PortfolioProjectCreateManyAndReturnArgs} args - Arguments to create many PortfolioProjects.
     * @example
     * // Create many PortfolioProjects
     * const portfolioProject = await prisma.portfolioProject.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortfolioProjects and only return the `id`
     * const portfolioProjectWithIdOnly = await prisma.portfolioProject.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortfolioProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, PortfolioProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PortfolioProject.
     * @param {PortfolioProjectDeleteArgs} args - Arguments to delete one PortfolioProject.
     * @example
     * // Delete one PortfolioProject
     * const PortfolioProject = await prisma.portfolioProject.delete({
     *   where: {
     *     // ... filter to delete one PortfolioProject
     *   }
     * })
     * 
     */
    delete<T extends PortfolioProjectDeleteArgs>(args: SelectSubset<T, PortfolioProjectDeleteArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PortfolioProject.
     * @param {PortfolioProjectUpdateArgs} args - Arguments to update one PortfolioProject.
     * @example
     * // Update one PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortfolioProjectUpdateArgs>(args: SelectSubset<T, PortfolioProjectUpdateArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PortfolioProjects.
     * @param {PortfolioProjectDeleteManyArgs} args - Arguments to filter PortfolioProjects to delete.
     * @example
     * // Delete a few PortfolioProjects
     * const { count } = await prisma.portfolioProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortfolioProjectDeleteManyArgs>(args?: SelectSubset<T, PortfolioProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortfolioProjects
     * const portfolioProject = await prisma.portfolioProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortfolioProjectUpdateManyArgs>(args: SelectSubset<T, PortfolioProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PortfolioProject.
     * @param {PortfolioProjectUpsertArgs} args - Arguments to update or create a PortfolioProject.
     * @example
     * // Update or create a PortfolioProject
     * const portfolioProject = await prisma.portfolioProject.upsert({
     *   create: {
     *     // ... data to create a PortfolioProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortfolioProject we want to update
     *   }
     * })
     */
    upsert<T extends PortfolioProjectUpsertArgs>(args: SelectSubset<T, PortfolioProjectUpsertArgs<ExtArgs>>): Prisma__PortfolioProjectClient<$Result.GetResult<Prisma.$PortfolioProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PortfolioProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectCountArgs} args - Arguments to filter PortfolioProjects to count.
     * @example
     * // Count the number of PortfolioProjects
     * const count = await prisma.portfolioProject.count({
     *   where: {
     *     // ... the filter for the PortfolioProjects we want to count
     *   }
     * })
    **/
    count<T extends PortfolioProjectCountArgs>(
      args?: Subset<T, PortfolioProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortfolioProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortfolioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortfolioProjectAggregateArgs>(args: Subset<T, PortfolioProjectAggregateArgs>): Prisma.PrismaPromise<GetPortfolioProjectAggregateType<T>>

    /**
     * Group by PortfolioProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortfolioProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortfolioProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortfolioProjectGroupByArgs['orderBy'] }
        : { orderBy?: PortfolioProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortfolioProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortfolioProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortfolioProject model
   */
  readonly fields: PortfolioProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortfolioProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortfolioProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortfolioProject model
   */ 
  interface PortfolioProjectFieldRefs {
    readonly id: FieldRef<"PortfolioProject", 'String'>
    readonly studentId: FieldRef<"PortfolioProject", 'String'>
    readonly title: FieldRef<"PortfolioProject", 'String'>
    readonly description: FieldRef<"PortfolioProject", 'String'>
    readonly githubUrl: FieldRef<"PortfolioProject", 'String'>
    readonly liveUrl: FieldRef<"PortfolioProject", 'String'>
    readonly tags: FieldRef<"PortfolioProject", 'String'>
    readonly createdAt: FieldRef<"PortfolioProject", 'DateTime'>
    readonly source: FieldRef<"PortfolioProject", 'String'>
    readonly githubRepoId: FieldRef<"PortfolioProject", 'String'>
    readonly lastSyncedAt: FieldRef<"PortfolioProject", 'DateTime'>
    readonly stars: FieldRef<"PortfolioProject", 'Int'>
    readonly forks: FieldRef<"PortfolioProject", 'Int'>
    readonly language: FieldRef<"PortfolioProject", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PortfolioProject findUnique
   */
  export type PortfolioProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject findUniqueOrThrow
   */
  export type PortfolioProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject findFirst
   */
  export type PortfolioProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioProjects.
     */
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject findFirstOrThrow
   */
  export type PortfolioProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioProject to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortfolioProjects.
     */
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject findMany
   */
  export type PortfolioProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter, which PortfolioProjects to fetch.
     */
    where?: PortfolioProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortfolioProjects to fetch.
     */
    orderBy?: PortfolioProjectOrderByWithRelationInput | PortfolioProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortfolioProjects.
     */
    cursor?: PortfolioProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortfolioProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortfolioProjects.
     */
    skip?: number
    distinct?: PortfolioProjectScalarFieldEnum | PortfolioProjectScalarFieldEnum[]
  }

  /**
   * PortfolioProject create
   */
  export type PortfolioProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a PortfolioProject.
     */
    data: XOR<PortfolioProjectCreateInput, PortfolioProjectUncheckedCreateInput>
  }

  /**
   * PortfolioProject createMany
   */
  export type PortfolioProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortfolioProjects.
     */
    data: PortfolioProjectCreateManyInput | PortfolioProjectCreateManyInput[]
  }

  /**
   * PortfolioProject createManyAndReturn
   */
  export type PortfolioProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PortfolioProjects.
     */
    data: PortfolioProjectCreateManyInput | PortfolioProjectCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortfolioProject update
   */
  export type PortfolioProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a PortfolioProject.
     */
    data: XOR<PortfolioProjectUpdateInput, PortfolioProjectUncheckedUpdateInput>
    /**
     * Choose, which PortfolioProject to update.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject updateMany
   */
  export type PortfolioProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortfolioProjects.
     */
    data: XOR<PortfolioProjectUpdateManyMutationInput, PortfolioProjectUncheckedUpdateManyInput>
    /**
     * Filter which PortfolioProjects to update
     */
    where?: PortfolioProjectWhereInput
  }

  /**
   * PortfolioProject upsert
   */
  export type PortfolioProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the PortfolioProject to update in case it exists.
     */
    where: PortfolioProjectWhereUniqueInput
    /**
     * In case the PortfolioProject found by the `where` argument doesn't exist, create a new PortfolioProject with this data.
     */
    create: XOR<PortfolioProjectCreateInput, PortfolioProjectUncheckedCreateInput>
    /**
     * In case the PortfolioProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortfolioProjectUpdateInput, PortfolioProjectUncheckedUpdateInput>
  }

  /**
   * PortfolioProject delete
   */
  export type PortfolioProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
    /**
     * Filter which PortfolioProject to delete.
     */
    where: PortfolioProjectWhereUniqueInput
  }

  /**
   * PortfolioProject deleteMany
   */
  export type PortfolioProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortfolioProjects to delete
     */
    where?: PortfolioProjectWhereInput
  }

  /**
   * PortfolioProject without action
   */
  export type PortfolioProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortfolioProject
     */
    select?: PortfolioProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortfolioProjectInclude<ExtArgs> | null
  }


  /**
   * Model MentorSession
   */

  export type AggregateMentorSession = {
    _count: MentorSessionCountAggregateOutputType | null
    _min: MentorSessionMinAggregateOutputType | null
    _max: MentorSessionMaxAggregateOutputType | null
  }

  export type MentorSessionMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    mentorId: string | null
    scheduledAt: Date | null
    status: string | null
    meetingLink: string | null
    createdAt: Date | null
  }

  export type MentorSessionMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    mentorId: string | null
    scheduledAt: Date | null
    status: string | null
    meetingLink: string | null
    createdAt: Date | null
  }

  export type MentorSessionCountAggregateOutputType = {
    id: number
    studentId: number
    mentorId: number
    scheduledAt: number
    status: number
    meetingLink: number
    createdAt: number
    _all: number
  }


  export type MentorSessionMinAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduledAt?: true
    status?: true
    meetingLink?: true
    createdAt?: true
  }

  export type MentorSessionMaxAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduledAt?: true
    status?: true
    meetingLink?: true
    createdAt?: true
  }

  export type MentorSessionCountAggregateInputType = {
    id?: true
    studentId?: true
    mentorId?: true
    scheduledAt?: true
    status?: true
    meetingLink?: true
    createdAt?: true
    _all?: true
  }

  export type MentorSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorSession to aggregate.
     */
    where?: MentorSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorSessions
    **/
    _count?: true | MentorSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorSessionMaxAggregateInputType
  }

  export type GetMentorSessionAggregateType<T extends MentorSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorSession[P]>
      : GetScalarType<T[P], AggregateMentorSession[P]>
  }




  export type MentorSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorSessionWhereInput
    orderBy?: MentorSessionOrderByWithAggregationInput | MentorSessionOrderByWithAggregationInput[]
    by: MentorSessionScalarFieldEnum[] | MentorSessionScalarFieldEnum
    having?: MentorSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorSessionCountAggregateInputType | true
    _min?: MentorSessionMinAggregateInputType
    _max?: MentorSessionMaxAggregateInputType
  }

  export type MentorSessionGroupByOutputType = {
    id: string
    studentId: string
    mentorId: string
    scheduledAt: Date
    status: string
    meetingLink: string | null
    createdAt: Date
    _count: MentorSessionCountAggregateOutputType | null
    _min: MentorSessionMinAggregateOutputType | null
    _max: MentorSessionMaxAggregateOutputType | null
  }

  type GetMentorSessionGroupByPayload<T extends MentorSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorSessionGroupByOutputType[P]>
            : GetScalarType<T[P], MentorSessionGroupByOutputType[P]>
        }
      >
    >


  export type MentorSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduledAt?: boolean
    status?: boolean
    meetingLink?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | MentorSession$reviewsArgs<ExtArgs>
    _count?: boolean | MentorSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSession"]>

  export type MentorSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduledAt?: boolean
    status?: boolean
    meetingLink?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorSession"]>

  export type MentorSessionSelectScalar = {
    id?: boolean
    studentId?: boolean
    mentorId?: boolean
    scheduledAt?: boolean
    status?: boolean
    meetingLink?: boolean
    createdAt?: boolean
  }

  export type MentorSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
    reviews?: boolean | MentorSession$reviewsArgs<ExtArgs>
    _count?: boolean | MentorSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MentorSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    mentor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MentorSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorSession"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      mentor: Prisma.$UserPayload<ExtArgs>
      reviews: Prisma.$MentorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      mentorId: string
      scheduledAt: Date
      status: string
      meetingLink: string | null
      createdAt: Date
    }, ExtArgs["result"]["mentorSession"]>
    composites: {}
  }

  type MentorSessionGetPayload<S extends boolean | null | undefined | MentorSessionDefaultArgs> = $Result.GetResult<Prisma.$MentorSessionPayload, S>

  type MentorSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentorSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorSessionCountAggregateInputType | true
    }

  export interface MentorSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorSession'], meta: { name: 'MentorSession' } }
    /**
     * Find zero or one MentorSession that matches the filter.
     * @param {MentorSessionFindUniqueArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorSessionFindUniqueArgs>(args: SelectSubset<T, MentorSessionFindUniqueArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentorSessionFindUniqueOrThrowArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindFirstArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorSessionFindFirstArgs>(args?: SelectSubset<T, MentorSessionFindFirstArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindFirstOrThrowArgs} args - Arguments to find a MentorSession
     * @example
     * // Get one MentorSession
     * const mentorSession = await prisma.mentorSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorSessions
     * const mentorSessions = await prisma.mentorSession.findMany()
     * 
     * // Get first 10 MentorSessions
     * const mentorSessions = await prisma.mentorSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorSessionWithIdOnly = await prisma.mentorSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorSessionFindManyArgs>(args?: SelectSubset<T, MentorSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorSession.
     * @param {MentorSessionCreateArgs} args - Arguments to create a MentorSession.
     * @example
     * // Create one MentorSession
     * const MentorSession = await prisma.mentorSession.create({
     *   data: {
     *     // ... data to create a MentorSession
     *   }
     * })
     * 
     */
    create<T extends MentorSessionCreateArgs>(args: SelectSubset<T, MentorSessionCreateArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorSessions.
     * @param {MentorSessionCreateManyArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSession = await prisma.mentorSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorSessionCreateManyArgs>(args?: SelectSubset<T, MentorSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorSessions and returns the data saved in the database.
     * @param {MentorSessionCreateManyAndReturnArgs} args - Arguments to create many MentorSessions.
     * @example
     * // Create many MentorSessions
     * const mentorSession = await prisma.mentorSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorSessions and only return the `id`
     * const mentorSessionWithIdOnly = await prisma.mentorSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorSession.
     * @param {MentorSessionDeleteArgs} args - Arguments to delete one MentorSession.
     * @example
     * // Delete one MentorSession
     * const MentorSession = await prisma.mentorSession.delete({
     *   where: {
     *     // ... filter to delete one MentorSession
     *   }
     * })
     * 
     */
    delete<T extends MentorSessionDeleteArgs>(args: SelectSubset<T, MentorSessionDeleteArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorSession.
     * @param {MentorSessionUpdateArgs} args - Arguments to update one MentorSession.
     * @example
     * // Update one MentorSession
     * const mentorSession = await prisma.mentorSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorSessionUpdateArgs>(args: SelectSubset<T, MentorSessionUpdateArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorSessions.
     * @param {MentorSessionDeleteManyArgs} args - Arguments to filter MentorSessions to delete.
     * @example
     * // Delete a few MentorSessions
     * const { count } = await prisma.mentorSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorSessionDeleteManyArgs>(args?: SelectSubset<T, MentorSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorSessions
     * const mentorSession = await prisma.mentorSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorSessionUpdateManyArgs>(args: SelectSubset<T, MentorSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorSession.
     * @param {MentorSessionUpsertArgs} args - Arguments to update or create a MentorSession.
     * @example
     * // Update or create a MentorSession
     * const mentorSession = await prisma.mentorSession.upsert({
     *   create: {
     *     // ... data to create a MentorSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorSession we want to update
     *   }
     * })
     */
    upsert<T extends MentorSessionUpsertArgs>(args: SelectSubset<T, MentorSessionUpsertArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionCountArgs} args - Arguments to filter MentorSessions to count.
     * @example
     * // Count the number of MentorSessions
     * const count = await prisma.mentorSession.count({
     *   where: {
     *     // ... the filter for the MentorSessions we want to count
     *   }
     * })
    **/
    count<T extends MentorSessionCountArgs>(
      args?: Subset<T, MentorSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorSessionAggregateArgs>(args: Subset<T, MentorSessionAggregateArgs>): Prisma.PrismaPromise<GetMentorSessionAggregateType<T>>

    /**
     * Group by MentorSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorSessionGroupByArgs['orderBy'] }
        : { orderBy?: MentorSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorSession model
   */
  readonly fields: MentorSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    mentor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reviews<T extends MentorSession$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, MentorSession$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorSession model
   */ 
  interface MentorSessionFieldRefs {
    readonly id: FieldRef<"MentorSession", 'String'>
    readonly studentId: FieldRef<"MentorSession", 'String'>
    readonly mentorId: FieldRef<"MentorSession", 'String'>
    readonly scheduledAt: FieldRef<"MentorSession", 'DateTime'>
    readonly status: FieldRef<"MentorSession", 'String'>
    readonly meetingLink: FieldRef<"MentorSession", 'String'>
    readonly createdAt: FieldRef<"MentorSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MentorSession findUnique
   */
  export type MentorSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorSession to fetch.
     */
    where: MentorSessionWhereUniqueInput
  }

  /**
   * MentorSession findUniqueOrThrow
   */
  export type MentorSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorSession to fetch.
     */
    where: MentorSessionWhereUniqueInput
  }

  /**
   * MentorSession findFirst
   */
  export type MentorSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorSession to fetch.
     */
    where?: MentorSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorSessions.
     */
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[]
  }

  /**
   * MentorSession findFirstOrThrow
   */
  export type MentorSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorSession to fetch.
     */
    where?: MentorSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorSessions.
     */
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[]
  }

  /**
   * MentorSession findMany
   */
  export type MentorSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter, which MentorSessions to fetch.
     */
    where?: MentorSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorSessions to fetch.
     */
    orderBy?: MentorSessionOrderByWithRelationInput | MentorSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorSessions.
     */
    cursor?: MentorSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorSessions.
     */
    skip?: number
    distinct?: MentorSessionScalarFieldEnum | MentorSessionScalarFieldEnum[]
  }

  /**
   * MentorSession create
   */
  export type MentorSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorSession.
     */
    data: XOR<MentorSessionCreateInput, MentorSessionUncheckedCreateInput>
  }

  /**
   * MentorSession createMany
   */
  export type MentorSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorSessions.
     */
    data: MentorSessionCreateManyInput | MentorSessionCreateManyInput[]
  }

  /**
   * MentorSession createManyAndReturn
   */
  export type MentorSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MentorSessions.
     */
    data: MentorSessionCreateManyInput | MentorSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorSession update
   */
  export type MentorSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorSession.
     */
    data: XOR<MentorSessionUpdateInput, MentorSessionUncheckedUpdateInput>
    /**
     * Choose, which MentorSession to update.
     */
    where: MentorSessionWhereUniqueInput
  }

  /**
   * MentorSession updateMany
   */
  export type MentorSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorSessions.
     */
    data: XOR<MentorSessionUpdateManyMutationInput, MentorSessionUncheckedUpdateManyInput>
    /**
     * Filter which MentorSessions to update
     */
    where?: MentorSessionWhereInput
  }

  /**
   * MentorSession upsert
   */
  export type MentorSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorSession to update in case it exists.
     */
    where: MentorSessionWhereUniqueInput
    /**
     * In case the MentorSession found by the `where` argument doesn't exist, create a new MentorSession with this data.
     */
    create: XOR<MentorSessionCreateInput, MentorSessionUncheckedCreateInput>
    /**
     * In case the MentorSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorSessionUpdateInput, MentorSessionUncheckedUpdateInput>
  }

  /**
   * MentorSession delete
   */
  export type MentorSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
    /**
     * Filter which MentorSession to delete.
     */
    where: MentorSessionWhereUniqueInput
  }

  /**
   * MentorSession deleteMany
   */
  export type MentorSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorSessions to delete
     */
    where?: MentorSessionWhereInput
  }

  /**
   * MentorSession.reviews
   */
  export type MentorSession$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    where?: MentorReviewWhereInput
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    cursor?: MentorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MentorReviewScalarFieldEnum | MentorReviewScalarFieldEnum[]
  }

  /**
   * MentorSession without action
   */
  export type MentorSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorSession
     */
    select?: MentorSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorSessionInclude<ExtArgs> | null
  }


  /**
   * Model MentorReview
   */

  export type AggregateMentorReview = {
    _count: MentorReviewCountAggregateOutputType | null
    _avg: MentorReviewAvgAggregateOutputType | null
    _sum: MentorReviewSumAggregateOutputType | null
    _min: MentorReviewMinAggregateOutputType | null
    _max: MentorReviewMaxAggregateOutputType | null
  }

  export type MentorReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type MentorReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type MentorReviewMinAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    rating: number | null
    review: string | null
  }

  export type MentorReviewMaxAggregateOutputType = {
    id: string | null
    sessionId: string | null
    studentId: string | null
    rating: number | null
    review: string | null
  }

  export type MentorReviewCountAggregateOutputType = {
    id: number
    sessionId: number
    studentId: number
    rating: number
    review: number
    _all: number
  }


  export type MentorReviewAvgAggregateInputType = {
    rating?: true
  }

  export type MentorReviewSumAggregateInputType = {
    rating?: true
  }

  export type MentorReviewMinAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    review?: true
  }

  export type MentorReviewMaxAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    review?: true
  }

  export type MentorReviewCountAggregateInputType = {
    id?: true
    sessionId?: true
    studentId?: true
    rating?: true
    review?: true
    _all?: true
  }

  export type MentorReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorReview to aggregate.
     */
    where?: MentorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorReviews to fetch.
     */
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MentorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MentorReviews
    **/
    _count?: true | MentorReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MentorReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MentorReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MentorReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MentorReviewMaxAggregateInputType
  }

  export type GetMentorReviewAggregateType<T extends MentorReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateMentorReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMentorReview[P]>
      : GetScalarType<T[P], AggregateMentorReview[P]>
  }




  export type MentorReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MentorReviewWhereInput
    orderBy?: MentorReviewOrderByWithAggregationInput | MentorReviewOrderByWithAggregationInput[]
    by: MentorReviewScalarFieldEnum[] | MentorReviewScalarFieldEnum
    having?: MentorReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MentorReviewCountAggregateInputType | true
    _avg?: MentorReviewAvgAggregateInputType
    _sum?: MentorReviewSumAggregateInputType
    _min?: MentorReviewMinAggregateInputType
    _max?: MentorReviewMaxAggregateInputType
  }

  export type MentorReviewGroupByOutputType = {
    id: string
    sessionId: string
    studentId: string
    rating: number
    review: string | null
    _count: MentorReviewCountAggregateOutputType | null
    _avg: MentorReviewAvgAggregateOutputType | null
    _sum: MentorReviewSumAggregateOutputType | null
    _min: MentorReviewMinAggregateOutputType | null
    _max: MentorReviewMaxAggregateOutputType | null
  }

  type GetMentorReviewGroupByPayload<T extends MentorReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MentorReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MentorReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MentorReviewGroupByOutputType[P]>
            : GetScalarType<T[P], MentorReviewGroupByOutputType[P]>
        }
      >
    >


  export type MentorReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    review?: boolean
    session?: boolean | MentorSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorReview"]>

  export type MentorReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    review?: boolean
    session?: boolean | MentorSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mentorReview"]>

  export type MentorReviewSelectScalar = {
    id?: boolean
    sessionId?: boolean
    studentId?: boolean
    rating?: boolean
    review?: boolean
  }

  export type MentorReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | MentorSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type MentorReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    session?: boolean | MentorSessionDefaultArgs<ExtArgs>
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $MentorReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MentorReview"
    objects: {
      session: Prisma.$MentorSessionPayload<ExtArgs>
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionId: string
      studentId: string
      rating: number
      review: string | null
    }, ExtArgs["result"]["mentorReview"]>
    composites: {}
  }

  type MentorReviewGetPayload<S extends boolean | null | undefined | MentorReviewDefaultArgs> = $Result.GetResult<Prisma.$MentorReviewPayload, S>

  type MentorReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MentorReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MentorReviewCountAggregateInputType | true
    }

  export interface MentorReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MentorReview'], meta: { name: 'MentorReview' } }
    /**
     * Find zero or one MentorReview that matches the filter.
     * @param {MentorReviewFindUniqueArgs} args - Arguments to find a MentorReview
     * @example
     * // Get one MentorReview
     * const mentorReview = await prisma.mentorReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MentorReviewFindUniqueArgs>(args: SelectSubset<T, MentorReviewFindUniqueArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MentorReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MentorReviewFindUniqueOrThrowArgs} args - Arguments to find a MentorReview
     * @example
     * // Get one MentorReview
     * const mentorReview = await prisma.mentorReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MentorReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, MentorReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MentorReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewFindFirstArgs} args - Arguments to find a MentorReview
     * @example
     * // Get one MentorReview
     * const mentorReview = await prisma.mentorReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MentorReviewFindFirstArgs>(args?: SelectSubset<T, MentorReviewFindFirstArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MentorReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewFindFirstOrThrowArgs} args - Arguments to find a MentorReview
     * @example
     * // Get one MentorReview
     * const mentorReview = await prisma.mentorReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MentorReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, MentorReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MentorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MentorReviews
     * const mentorReviews = await prisma.mentorReview.findMany()
     * 
     * // Get first 10 MentorReviews
     * const mentorReviews = await prisma.mentorReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mentorReviewWithIdOnly = await prisma.mentorReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MentorReviewFindManyArgs>(args?: SelectSubset<T, MentorReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MentorReview.
     * @param {MentorReviewCreateArgs} args - Arguments to create a MentorReview.
     * @example
     * // Create one MentorReview
     * const MentorReview = await prisma.mentorReview.create({
     *   data: {
     *     // ... data to create a MentorReview
     *   }
     * })
     * 
     */
    create<T extends MentorReviewCreateArgs>(args: SelectSubset<T, MentorReviewCreateArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MentorReviews.
     * @param {MentorReviewCreateManyArgs} args - Arguments to create many MentorReviews.
     * @example
     * // Create many MentorReviews
     * const mentorReview = await prisma.mentorReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MentorReviewCreateManyArgs>(args?: SelectSubset<T, MentorReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MentorReviews and returns the data saved in the database.
     * @param {MentorReviewCreateManyAndReturnArgs} args - Arguments to create many MentorReviews.
     * @example
     * // Create many MentorReviews
     * const mentorReview = await prisma.mentorReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MentorReviews and only return the `id`
     * const mentorReviewWithIdOnly = await prisma.mentorReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MentorReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, MentorReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MentorReview.
     * @param {MentorReviewDeleteArgs} args - Arguments to delete one MentorReview.
     * @example
     * // Delete one MentorReview
     * const MentorReview = await prisma.mentorReview.delete({
     *   where: {
     *     // ... filter to delete one MentorReview
     *   }
     * })
     * 
     */
    delete<T extends MentorReviewDeleteArgs>(args: SelectSubset<T, MentorReviewDeleteArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MentorReview.
     * @param {MentorReviewUpdateArgs} args - Arguments to update one MentorReview.
     * @example
     * // Update one MentorReview
     * const mentorReview = await prisma.mentorReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MentorReviewUpdateArgs>(args: SelectSubset<T, MentorReviewUpdateArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MentorReviews.
     * @param {MentorReviewDeleteManyArgs} args - Arguments to filter MentorReviews to delete.
     * @example
     * // Delete a few MentorReviews
     * const { count } = await prisma.mentorReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MentorReviewDeleteManyArgs>(args?: SelectSubset<T, MentorReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MentorReviews
     * const mentorReview = await prisma.mentorReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MentorReviewUpdateManyArgs>(args: SelectSubset<T, MentorReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MentorReview.
     * @param {MentorReviewUpsertArgs} args - Arguments to update or create a MentorReview.
     * @example
     * // Update or create a MentorReview
     * const mentorReview = await prisma.mentorReview.upsert({
     *   create: {
     *     // ... data to create a MentorReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MentorReview we want to update
     *   }
     * })
     */
    upsert<T extends MentorReviewUpsertArgs>(args: SelectSubset<T, MentorReviewUpsertArgs<ExtArgs>>): Prisma__MentorReviewClient<$Result.GetResult<Prisma.$MentorReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MentorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewCountArgs} args - Arguments to filter MentorReviews to count.
     * @example
     * // Count the number of MentorReviews
     * const count = await prisma.mentorReview.count({
     *   where: {
     *     // ... the filter for the MentorReviews we want to count
     *   }
     * })
    **/
    count<T extends MentorReviewCountArgs>(
      args?: Subset<T, MentorReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MentorReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MentorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MentorReviewAggregateArgs>(args: Subset<T, MentorReviewAggregateArgs>): Prisma.PrismaPromise<GetMentorReviewAggregateType<T>>

    /**
     * Group by MentorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MentorReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MentorReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MentorReviewGroupByArgs['orderBy'] }
        : { orderBy?: MentorReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MentorReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMentorReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MentorReview model
   */
  readonly fields: MentorReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MentorReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MentorReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    session<T extends MentorSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MentorSessionDefaultArgs<ExtArgs>>): Prisma__MentorSessionClient<$Result.GetResult<Prisma.$MentorSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MentorReview model
   */ 
  interface MentorReviewFieldRefs {
    readonly id: FieldRef<"MentorReview", 'String'>
    readonly sessionId: FieldRef<"MentorReview", 'String'>
    readonly studentId: FieldRef<"MentorReview", 'String'>
    readonly rating: FieldRef<"MentorReview", 'Float'>
    readonly review: FieldRef<"MentorReview", 'String'>
  }
    

  // Custom InputTypes
  /**
   * MentorReview findUnique
   */
  export type MentorReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter, which MentorReview to fetch.
     */
    where: MentorReviewWhereUniqueInput
  }

  /**
   * MentorReview findUniqueOrThrow
   */
  export type MentorReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter, which MentorReview to fetch.
     */
    where: MentorReviewWhereUniqueInput
  }

  /**
   * MentorReview findFirst
   */
  export type MentorReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter, which MentorReview to fetch.
     */
    where?: MentorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorReviews to fetch.
     */
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorReviews.
     */
    cursor?: MentorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorReviews.
     */
    distinct?: MentorReviewScalarFieldEnum | MentorReviewScalarFieldEnum[]
  }

  /**
   * MentorReview findFirstOrThrow
   */
  export type MentorReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter, which MentorReview to fetch.
     */
    where?: MentorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorReviews to fetch.
     */
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MentorReviews.
     */
    cursor?: MentorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MentorReviews.
     */
    distinct?: MentorReviewScalarFieldEnum | MentorReviewScalarFieldEnum[]
  }

  /**
   * MentorReview findMany
   */
  export type MentorReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter, which MentorReviews to fetch.
     */
    where?: MentorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MentorReviews to fetch.
     */
    orderBy?: MentorReviewOrderByWithRelationInput | MentorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MentorReviews.
     */
    cursor?: MentorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MentorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MentorReviews.
     */
    skip?: number
    distinct?: MentorReviewScalarFieldEnum | MentorReviewScalarFieldEnum[]
  }

  /**
   * MentorReview create
   */
  export type MentorReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a MentorReview.
     */
    data: XOR<MentorReviewCreateInput, MentorReviewUncheckedCreateInput>
  }

  /**
   * MentorReview createMany
   */
  export type MentorReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MentorReviews.
     */
    data: MentorReviewCreateManyInput | MentorReviewCreateManyInput[]
  }

  /**
   * MentorReview createManyAndReturn
   */
  export type MentorReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MentorReviews.
     */
    data: MentorReviewCreateManyInput | MentorReviewCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MentorReview update
   */
  export type MentorReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a MentorReview.
     */
    data: XOR<MentorReviewUpdateInput, MentorReviewUncheckedUpdateInput>
    /**
     * Choose, which MentorReview to update.
     */
    where: MentorReviewWhereUniqueInput
  }

  /**
   * MentorReview updateMany
   */
  export type MentorReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MentorReviews.
     */
    data: XOR<MentorReviewUpdateManyMutationInput, MentorReviewUncheckedUpdateManyInput>
    /**
     * Filter which MentorReviews to update
     */
    where?: MentorReviewWhereInput
  }

  /**
   * MentorReview upsert
   */
  export type MentorReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the MentorReview to update in case it exists.
     */
    where: MentorReviewWhereUniqueInput
    /**
     * In case the MentorReview found by the `where` argument doesn't exist, create a new MentorReview with this data.
     */
    create: XOR<MentorReviewCreateInput, MentorReviewUncheckedCreateInput>
    /**
     * In case the MentorReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MentorReviewUpdateInput, MentorReviewUncheckedUpdateInput>
  }

  /**
   * MentorReview delete
   */
  export type MentorReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
    /**
     * Filter which MentorReview to delete.
     */
    where: MentorReviewWhereUniqueInput
  }

  /**
   * MentorReview deleteMany
   */
  export type MentorReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MentorReviews to delete
     */
    where?: MentorReviewWhereInput
  }

  /**
   * MentorReview without action
   */
  export type MentorReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MentorReview
     */
    select?: MentorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MentorReviewInclude<ExtArgs> | null
  }


  /**
   * Model LogbookEntry
   */

  export type AggregateLogbookEntry = {
    _count: LogbookEntryCountAggregateOutputType | null
    _avg: LogbookEntryAvgAggregateOutputType | null
    _sum: LogbookEntrySumAggregateOutputType | null
    _min: LogbookEntryMinAggregateOutputType | null
    _max: LogbookEntryMaxAggregateOutputType | null
  }

  export type LogbookEntryAvgAggregateOutputType = {
    hours: number | null
  }

  export type LogbookEntrySumAggregateOutputType = {
    hours: number | null
  }

  export type LogbookEntryMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    task: string | null
    hours: number | null
    description: string | null
    proofUrl: string | null
    createdAt: Date | null
  }

  export type LogbookEntryMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    date: Date | null
    task: string | null
    hours: number | null
    description: string | null
    proofUrl: string | null
    createdAt: Date | null
  }

  export type LogbookEntryCountAggregateOutputType = {
    id: number
    studentId: number
    date: number
    task: number
    hours: number
    description: number
    proofUrl: number
    createdAt: number
    _all: number
  }


  export type LogbookEntryAvgAggregateInputType = {
    hours?: true
  }

  export type LogbookEntrySumAggregateInputType = {
    hours?: true
  }

  export type LogbookEntryMinAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    task?: true
    hours?: true
    description?: true
    proofUrl?: true
    createdAt?: true
  }

  export type LogbookEntryMaxAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    task?: true
    hours?: true
    description?: true
    proofUrl?: true
    createdAt?: true
  }

  export type LogbookEntryCountAggregateInputType = {
    id?: true
    studentId?: true
    date?: true
    task?: true
    hours?: true
    description?: true
    proofUrl?: true
    createdAt?: true
    _all?: true
  }

  export type LogbookEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogbookEntry to aggregate.
     */
    where?: LogbookEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogbookEntries to fetch.
     */
    orderBy?: LogbookEntryOrderByWithRelationInput | LogbookEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogbookEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogbookEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogbookEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LogbookEntries
    **/
    _count?: true | LogbookEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogbookEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogbookEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogbookEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogbookEntryMaxAggregateInputType
  }

  export type GetLogbookEntryAggregateType<T extends LogbookEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateLogbookEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogbookEntry[P]>
      : GetScalarType<T[P], AggregateLogbookEntry[P]>
  }




  export type LogbookEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogbookEntryWhereInput
    orderBy?: LogbookEntryOrderByWithAggregationInput | LogbookEntryOrderByWithAggregationInput[]
    by: LogbookEntryScalarFieldEnum[] | LogbookEntryScalarFieldEnum
    having?: LogbookEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogbookEntryCountAggregateInputType | true
    _avg?: LogbookEntryAvgAggregateInputType
    _sum?: LogbookEntrySumAggregateInputType
    _min?: LogbookEntryMinAggregateInputType
    _max?: LogbookEntryMaxAggregateInputType
  }

  export type LogbookEntryGroupByOutputType = {
    id: string
    studentId: string
    date: Date
    task: string
    hours: number
    description: string
    proofUrl: string | null
    createdAt: Date
    _count: LogbookEntryCountAggregateOutputType | null
    _avg: LogbookEntryAvgAggregateOutputType | null
    _sum: LogbookEntrySumAggregateOutputType | null
    _min: LogbookEntryMinAggregateOutputType | null
    _max: LogbookEntryMaxAggregateOutputType | null
  }

  type GetLogbookEntryGroupByPayload<T extends LogbookEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogbookEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogbookEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogbookEntryGroupByOutputType[P]>
            : GetScalarType<T[P], LogbookEntryGroupByOutputType[P]>
        }
      >
    >


  export type LogbookEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    task?: boolean
    hours?: boolean
    description?: boolean
    proofUrl?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logbookEntry"]>

  export type LogbookEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    date?: boolean
    task?: boolean
    hours?: boolean
    description?: boolean
    proofUrl?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["logbookEntry"]>

  export type LogbookEntrySelectScalar = {
    id?: boolean
    studentId?: boolean
    date?: boolean
    task?: boolean
    hours?: boolean
    description?: boolean
    proofUrl?: boolean
    createdAt?: boolean
  }

  export type LogbookEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type LogbookEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $LogbookEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LogbookEntry"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      date: Date
      task: string
      hours: number
      description: string
      proofUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["logbookEntry"]>
    composites: {}
  }

  type LogbookEntryGetPayload<S extends boolean | null | undefined | LogbookEntryDefaultArgs> = $Result.GetResult<Prisma.$LogbookEntryPayload, S>

  type LogbookEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LogbookEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LogbookEntryCountAggregateInputType | true
    }

  export interface LogbookEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LogbookEntry'], meta: { name: 'LogbookEntry' } }
    /**
     * Find zero or one LogbookEntry that matches the filter.
     * @param {LogbookEntryFindUniqueArgs} args - Arguments to find a LogbookEntry
     * @example
     * // Get one LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogbookEntryFindUniqueArgs>(args: SelectSubset<T, LogbookEntryFindUniqueArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LogbookEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LogbookEntryFindUniqueOrThrowArgs} args - Arguments to find a LogbookEntry
     * @example
     * // Get one LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogbookEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, LogbookEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LogbookEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryFindFirstArgs} args - Arguments to find a LogbookEntry
     * @example
     * // Get one LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogbookEntryFindFirstArgs>(args?: SelectSubset<T, LogbookEntryFindFirstArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LogbookEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryFindFirstOrThrowArgs} args - Arguments to find a LogbookEntry
     * @example
     * // Get one LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogbookEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, LogbookEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LogbookEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LogbookEntries
     * const logbookEntries = await prisma.logbookEntry.findMany()
     * 
     * // Get first 10 LogbookEntries
     * const logbookEntries = await prisma.logbookEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logbookEntryWithIdOnly = await prisma.logbookEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogbookEntryFindManyArgs>(args?: SelectSubset<T, LogbookEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LogbookEntry.
     * @param {LogbookEntryCreateArgs} args - Arguments to create a LogbookEntry.
     * @example
     * // Create one LogbookEntry
     * const LogbookEntry = await prisma.logbookEntry.create({
     *   data: {
     *     // ... data to create a LogbookEntry
     *   }
     * })
     * 
     */
    create<T extends LogbookEntryCreateArgs>(args: SelectSubset<T, LogbookEntryCreateArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LogbookEntries.
     * @param {LogbookEntryCreateManyArgs} args - Arguments to create many LogbookEntries.
     * @example
     * // Create many LogbookEntries
     * const logbookEntry = await prisma.logbookEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogbookEntryCreateManyArgs>(args?: SelectSubset<T, LogbookEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LogbookEntries and returns the data saved in the database.
     * @param {LogbookEntryCreateManyAndReturnArgs} args - Arguments to create many LogbookEntries.
     * @example
     * // Create many LogbookEntries
     * const logbookEntry = await prisma.logbookEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LogbookEntries and only return the `id`
     * const logbookEntryWithIdOnly = await prisma.logbookEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogbookEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, LogbookEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LogbookEntry.
     * @param {LogbookEntryDeleteArgs} args - Arguments to delete one LogbookEntry.
     * @example
     * // Delete one LogbookEntry
     * const LogbookEntry = await prisma.logbookEntry.delete({
     *   where: {
     *     // ... filter to delete one LogbookEntry
     *   }
     * })
     * 
     */
    delete<T extends LogbookEntryDeleteArgs>(args: SelectSubset<T, LogbookEntryDeleteArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LogbookEntry.
     * @param {LogbookEntryUpdateArgs} args - Arguments to update one LogbookEntry.
     * @example
     * // Update one LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogbookEntryUpdateArgs>(args: SelectSubset<T, LogbookEntryUpdateArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LogbookEntries.
     * @param {LogbookEntryDeleteManyArgs} args - Arguments to filter LogbookEntries to delete.
     * @example
     * // Delete a few LogbookEntries
     * const { count } = await prisma.logbookEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogbookEntryDeleteManyArgs>(args?: SelectSubset<T, LogbookEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LogbookEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LogbookEntries
     * const logbookEntry = await prisma.logbookEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogbookEntryUpdateManyArgs>(args: SelectSubset<T, LogbookEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LogbookEntry.
     * @param {LogbookEntryUpsertArgs} args - Arguments to update or create a LogbookEntry.
     * @example
     * // Update or create a LogbookEntry
     * const logbookEntry = await prisma.logbookEntry.upsert({
     *   create: {
     *     // ... data to create a LogbookEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LogbookEntry we want to update
     *   }
     * })
     */
    upsert<T extends LogbookEntryUpsertArgs>(args: SelectSubset<T, LogbookEntryUpsertArgs<ExtArgs>>): Prisma__LogbookEntryClient<$Result.GetResult<Prisma.$LogbookEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LogbookEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryCountArgs} args - Arguments to filter LogbookEntries to count.
     * @example
     * // Count the number of LogbookEntries
     * const count = await prisma.logbookEntry.count({
     *   where: {
     *     // ... the filter for the LogbookEntries we want to count
     *   }
     * })
    **/
    count<T extends LogbookEntryCountArgs>(
      args?: Subset<T, LogbookEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogbookEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LogbookEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogbookEntryAggregateArgs>(args: Subset<T, LogbookEntryAggregateArgs>): Prisma.PrismaPromise<GetLogbookEntryAggregateType<T>>

    /**
     * Group by LogbookEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogbookEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogbookEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogbookEntryGroupByArgs['orderBy'] }
        : { orderBy?: LogbookEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogbookEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogbookEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LogbookEntry model
   */
  readonly fields: LogbookEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LogbookEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogbookEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LogbookEntry model
   */ 
  interface LogbookEntryFieldRefs {
    readonly id: FieldRef<"LogbookEntry", 'String'>
    readonly studentId: FieldRef<"LogbookEntry", 'String'>
    readonly date: FieldRef<"LogbookEntry", 'DateTime'>
    readonly task: FieldRef<"LogbookEntry", 'String'>
    readonly hours: FieldRef<"LogbookEntry", 'Int'>
    readonly description: FieldRef<"LogbookEntry", 'String'>
    readonly proofUrl: FieldRef<"LogbookEntry", 'String'>
    readonly createdAt: FieldRef<"LogbookEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LogbookEntry findUnique
   */
  export type LogbookEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogbookEntry to fetch.
     */
    where: LogbookEntryWhereUniqueInput
  }

  /**
   * LogbookEntry findUniqueOrThrow
   */
  export type LogbookEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogbookEntry to fetch.
     */
    where: LogbookEntryWhereUniqueInput
  }

  /**
   * LogbookEntry findFirst
   */
  export type LogbookEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogbookEntry to fetch.
     */
    where?: LogbookEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogbookEntries to fetch.
     */
    orderBy?: LogbookEntryOrderByWithRelationInput | LogbookEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogbookEntries.
     */
    cursor?: LogbookEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogbookEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogbookEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogbookEntries.
     */
    distinct?: LogbookEntryScalarFieldEnum | LogbookEntryScalarFieldEnum[]
  }

  /**
   * LogbookEntry findFirstOrThrow
   */
  export type LogbookEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogbookEntry to fetch.
     */
    where?: LogbookEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogbookEntries to fetch.
     */
    orderBy?: LogbookEntryOrderByWithRelationInput | LogbookEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LogbookEntries.
     */
    cursor?: LogbookEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogbookEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogbookEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LogbookEntries.
     */
    distinct?: LogbookEntryScalarFieldEnum | LogbookEntryScalarFieldEnum[]
  }

  /**
   * LogbookEntry findMany
   */
  export type LogbookEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter, which LogbookEntries to fetch.
     */
    where?: LogbookEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LogbookEntries to fetch.
     */
    orderBy?: LogbookEntryOrderByWithRelationInput | LogbookEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LogbookEntries.
     */
    cursor?: LogbookEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LogbookEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LogbookEntries.
     */
    skip?: number
    distinct?: LogbookEntryScalarFieldEnum | LogbookEntryScalarFieldEnum[]
  }

  /**
   * LogbookEntry create
   */
  export type LogbookEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a LogbookEntry.
     */
    data: XOR<LogbookEntryCreateInput, LogbookEntryUncheckedCreateInput>
  }

  /**
   * LogbookEntry createMany
   */
  export type LogbookEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LogbookEntries.
     */
    data: LogbookEntryCreateManyInput | LogbookEntryCreateManyInput[]
  }

  /**
   * LogbookEntry createManyAndReturn
   */
  export type LogbookEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LogbookEntries.
     */
    data: LogbookEntryCreateManyInput | LogbookEntryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LogbookEntry update
   */
  export type LogbookEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a LogbookEntry.
     */
    data: XOR<LogbookEntryUpdateInput, LogbookEntryUncheckedUpdateInput>
    /**
     * Choose, which LogbookEntry to update.
     */
    where: LogbookEntryWhereUniqueInput
  }

  /**
   * LogbookEntry updateMany
   */
  export type LogbookEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LogbookEntries.
     */
    data: XOR<LogbookEntryUpdateManyMutationInput, LogbookEntryUncheckedUpdateManyInput>
    /**
     * Filter which LogbookEntries to update
     */
    where?: LogbookEntryWhereInput
  }

  /**
   * LogbookEntry upsert
   */
  export type LogbookEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the LogbookEntry to update in case it exists.
     */
    where: LogbookEntryWhereUniqueInput
    /**
     * In case the LogbookEntry found by the `where` argument doesn't exist, create a new LogbookEntry with this data.
     */
    create: XOR<LogbookEntryCreateInput, LogbookEntryUncheckedCreateInput>
    /**
     * In case the LogbookEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogbookEntryUpdateInput, LogbookEntryUncheckedUpdateInput>
  }

  /**
   * LogbookEntry delete
   */
  export type LogbookEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
    /**
     * Filter which LogbookEntry to delete.
     */
    where: LogbookEntryWhereUniqueInput
  }

  /**
   * LogbookEntry deleteMany
   */
  export type LogbookEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LogbookEntries to delete
     */
    where?: LogbookEntryWhereInput
  }

  /**
   * LogbookEntry without action
   */
  export type LogbookEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LogbookEntry
     */
    select?: LogbookEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogbookEntryInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    issuedAt: Date | null
    certificateUrl: string | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    issuedAt: Date | null
    certificateUrl: string | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    studentId: number
    title: number
    issuedAt: number
    certificateUrl: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuedAt?: true
    certificateUrl?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuedAt?: true
    certificateUrl?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuedAt?: true
    certificateUrl?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    studentId: string
    title: string
    issuedAt: Date
    certificateUrl: string
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuedAt?: boolean
    certificateUrl?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuedAt?: boolean
    certificateUrl?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>

  export type CertificateSelectScalar = {
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuedAt?: boolean
    certificateUrl?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type CertificateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      title: string
      issuedAt: Date
      certificateUrl: string
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {CertificateCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificateWithIdOnly = await prisma.certificate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificateCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly studentId: FieldRef<"Certificate", 'String'>
    readonly title: FieldRef<"Certificate", 'String'>
    readonly issuedAt: FieldRef<"Certificate", 'DateTime'>
    readonly certificateUrl: FieldRef<"Certificate", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
  }

  /**
   * Certificate createManyAndReturn
   */
  export type CertificateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model StudentLearningProgress
   */

  export type AggregateStudentLearningProgress = {
    _count: StudentLearningProgressCountAggregateOutputType | null
    _min: StudentLearningProgressMinAggregateOutputType | null
    _max: StudentLearningProgressMaxAggregateOutputType | null
  }

  export type StudentLearningProgressMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    profileId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    checkpointId: string | null
  }

  export type StudentLearningProgressMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    profileId: string | null
    isCompleted: boolean | null
    completedAt: Date | null
    checkpointId: string | null
  }

  export type StudentLearningProgressCountAggregateOutputType = {
    id: number
    studentId: number
    profileId: number
    isCompleted: number
    completedAt: number
    checkpointId: number
    _all: number
  }


  export type StudentLearningProgressMinAggregateInputType = {
    id?: true
    studentId?: true
    profileId?: true
    isCompleted?: true
    completedAt?: true
    checkpointId?: true
  }

  export type StudentLearningProgressMaxAggregateInputType = {
    id?: true
    studentId?: true
    profileId?: true
    isCompleted?: true
    completedAt?: true
    checkpointId?: true
  }

  export type StudentLearningProgressCountAggregateInputType = {
    id?: true
    studentId?: true
    profileId?: true
    isCompleted?: true
    completedAt?: true
    checkpointId?: true
    _all?: true
  }

  export type StudentLearningProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentLearningProgress to aggregate.
     */
    where?: StudentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLearningProgresses to fetch.
     */
    orderBy?: StudentLearningProgressOrderByWithRelationInput | StudentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentLearningProgresses
    **/
    _count?: true | StudentLearningProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentLearningProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentLearningProgressMaxAggregateInputType
  }

  export type GetStudentLearningProgressAggregateType<T extends StudentLearningProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentLearningProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentLearningProgress[P]>
      : GetScalarType<T[P], AggregateStudentLearningProgress[P]>
  }




  export type StudentLearningProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentLearningProgressWhereInput
    orderBy?: StudentLearningProgressOrderByWithAggregationInput | StudentLearningProgressOrderByWithAggregationInput[]
    by: StudentLearningProgressScalarFieldEnum[] | StudentLearningProgressScalarFieldEnum
    having?: StudentLearningProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentLearningProgressCountAggregateInputType | true
    _min?: StudentLearningProgressMinAggregateInputType
    _max?: StudentLearningProgressMaxAggregateInputType
  }

  export type StudentLearningProgressGroupByOutputType = {
    id: string
    studentId: string
    profileId: string
    isCompleted: boolean
    completedAt: Date | null
    checkpointId: string
    _count: StudentLearningProgressCountAggregateOutputType | null
    _min: StudentLearningProgressMinAggregateOutputType | null
    _max: StudentLearningProgressMaxAggregateOutputType | null
  }

  type GetStudentLearningProgressGroupByPayload<T extends StudentLearningProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentLearningProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentLearningProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentLearningProgressGroupByOutputType[P]>
            : GetScalarType<T[P], StudentLearningProgressGroupByOutputType[P]>
        }
      >
    >


  export type StudentLearningProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    profileId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    checkpointId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentLearningProgress"]>

  export type StudentLearningProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    profileId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    checkpointId?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentLearningProgress"]>

  export type StudentLearningProgressSelectScalar = {
    id?: boolean
    studentId?: boolean
    profileId?: boolean
    isCompleted?: boolean
    completedAt?: boolean
    checkpointId?: boolean
  }

  export type StudentLearningProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type StudentLearningProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $StudentLearningProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentLearningProgress"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      profileId: string
      isCompleted: boolean
      completedAt: Date | null
      checkpointId: string
    }, ExtArgs["result"]["studentLearningProgress"]>
    composites: {}
  }

  type StudentLearningProgressGetPayload<S extends boolean | null | undefined | StudentLearningProgressDefaultArgs> = $Result.GetResult<Prisma.$StudentLearningProgressPayload, S>

  type StudentLearningProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentLearningProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentLearningProgressCountAggregateInputType | true
    }

  export interface StudentLearningProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentLearningProgress'], meta: { name: 'StudentLearningProgress' } }
    /**
     * Find zero or one StudentLearningProgress that matches the filter.
     * @param {StudentLearningProgressFindUniqueArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentLearningProgressFindUniqueArgs>(args: SelectSubset<T, StudentLearningProgressFindUniqueArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentLearningProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentLearningProgressFindUniqueOrThrowArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentLearningProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentLearningProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentLearningProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressFindFirstArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentLearningProgressFindFirstArgs>(args?: SelectSubset<T, StudentLearningProgressFindFirstArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentLearningProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressFindFirstOrThrowArgs} args - Arguments to find a StudentLearningProgress
     * @example
     * // Get one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentLearningProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentLearningProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentLearningProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentLearningProgresses
     * const studentLearningProgresses = await prisma.studentLearningProgress.findMany()
     * 
     * // Get first 10 StudentLearningProgresses
     * const studentLearningProgresses = await prisma.studentLearningProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentLearningProgressWithIdOnly = await prisma.studentLearningProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentLearningProgressFindManyArgs>(args?: SelectSubset<T, StudentLearningProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentLearningProgress.
     * @param {StudentLearningProgressCreateArgs} args - Arguments to create a StudentLearningProgress.
     * @example
     * // Create one StudentLearningProgress
     * const StudentLearningProgress = await prisma.studentLearningProgress.create({
     *   data: {
     *     // ... data to create a StudentLearningProgress
     *   }
     * })
     * 
     */
    create<T extends StudentLearningProgressCreateArgs>(args: SelectSubset<T, StudentLearningProgressCreateArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentLearningProgresses.
     * @param {StudentLearningProgressCreateManyArgs} args - Arguments to create many StudentLearningProgresses.
     * @example
     * // Create many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentLearningProgressCreateManyArgs>(args?: SelectSubset<T, StudentLearningProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentLearningProgresses and returns the data saved in the database.
     * @param {StudentLearningProgressCreateManyAndReturnArgs} args - Arguments to create many StudentLearningProgresses.
     * @example
     * // Create many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentLearningProgresses and only return the `id`
     * const studentLearningProgressWithIdOnly = await prisma.studentLearningProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentLearningProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentLearningProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentLearningProgress.
     * @param {StudentLearningProgressDeleteArgs} args - Arguments to delete one StudentLearningProgress.
     * @example
     * // Delete one StudentLearningProgress
     * const StudentLearningProgress = await prisma.studentLearningProgress.delete({
     *   where: {
     *     // ... filter to delete one StudentLearningProgress
     *   }
     * })
     * 
     */
    delete<T extends StudentLearningProgressDeleteArgs>(args: SelectSubset<T, StudentLearningProgressDeleteArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentLearningProgress.
     * @param {StudentLearningProgressUpdateArgs} args - Arguments to update one StudentLearningProgress.
     * @example
     * // Update one StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentLearningProgressUpdateArgs>(args: SelectSubset<T, StudentLearningProgressUpdateArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentLearningProgresses.
     * @param {StudentLearningProgressDeleteManyArgs} args - Arguments to filter StudentLearningProgresses to delete.
     * @example
     * // Delete a few StudentLearningProgresses
     * const { count } = await prisma.studentLearningProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentLearningProgressDeleteManyArgs>(args?: SelectSubset<T, StudentLearningProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentLearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentLearningProgresses
     * const studentLearningProgress = await prisma.studentLearningProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentLearningProgressUpdateManyArgs>(args: SelectSubset<T, StudentLearningProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentLearningProgress.
     * @param {StudentLearningProgressUpsertArgs} args - Arguments to update or create a StudentLearningProgress.
     * @example
     * // Update or create a StudentLearningProgress
     * const studentLearningProgress = await prisma.studentLearningProgress.upsert({
     *   create: {
     *     // ... data to create a StudentLearningProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentLearningProgress we want to update
     *   }
     * })
     */
    upsert<T extends StudentLearningProgressUpsertArgs>(args: SelectSubset<T, StudentLearningProgressUpsertArgs<ExtArgs>>): Prisma__StudentLearningProgressClient<$Result.GetResult<Prisma.$StudentLearningProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentLearningProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressCountArgs} args - Arguments to filter StudentLearningProgresses to count.
     * @example
     * // Count the number of StudentLearningProgresses
     * const count = await prisma.studentLearningProgress.count({
     *   where: {
     *     // ... the filter for the StudentLearningProgresses we want to count
     *   }
     * })
    **/
    count<T extends StudentLearningProgressCountArgs>(
      args?: Subset<T, StudentLearningProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentLearningProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentLearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentLearningProgressAggregateArgs>(args: Subset<T, StudentLearningProgressAggregateArgs>): Prisma.PrismaPromise<GetStudentLearningProgressAggregateType<T>>

    /**
     * Group by StudentLearningProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentLearningProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentLearningProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentLearningProgressGroupByArgs['orderBy'] }
        : { orderBy?: StudentLearningProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentLearningProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentLearningProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentLearningProgress model
   */
  readonly fields: StudentLearningProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentLearningProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentLearningProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentLearningProgress model
   */ 
  interface StudentLearningProgressFieldRefs {
    readonly id: FieldRef<"StudentLearningProgress", 'String'>
    readonly studentId: FieldRef<"StudentLearningProgress", 'String'>
    readonly profileId: FieldRef<"StudentLearningProgress", 'String'>
    readonly isCompleted: FieldRef<"StudentLearningProgress", 'Boolean'>
    readonly completedAt: FieldRef<"StudentLearningProgress", 'DateTime'>
    readonly checkpointId: FieldRef<"StudentLearningProgress", 'String'>
  }
    

  // Custom InputTypes
  /**
   * StudentLearningProgress findUnique
   */
  export type StudentLearningProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentLearningProgress to fetch.
     */
    where: StudentLearningProgressWhereUniqueInput
  }

  /**
   * StudentLearningProgress findUniqueOrThrow
   */
  export type StudentLearningProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentLearningProgress to fetch.
     */
    where: StudentLearningProgressWhereUniqueInput
  }

  /**
   * StudentLearningProgress findFirst
   */
  export type StudentLearningProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentLearningProgress to fetch.
     */
    where?: StudentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLearningProgresses to fetch.
     */
    orderBy?: StudentLearningProgressOrderByWithRelationInput | StudentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentLearningProgresses.
     */
    cursor?: StudentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentLearningProgresses.
     */
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * StudentLearningProgress findFirstOrThrow
   */
  export type StudentLearningProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentLearningProgress to fetch.
     */
    where?: StudentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLearningProgresses to fetch.
     */
    orderBy?: StudentLearningProgressOrderByWithRelationInput | StudentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentLearningProgresses.
     */
    cursor?: StudentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLearningProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentLearningProgresses.
     */
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * StudentLearningProgress findMany
   */
  export type StudentLearningProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter, which StudentLearningProgresses to fetch.
     */
    where?: StudentLearningProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentLearningProgresses to fetch.
     */
    orderBy?: StudentLearningProgressOrderByWithRelationInput | StudentLearningProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentLearningProgresses.
     */
    cursor?: StudentLearningProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentLearningProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentLearningProgresses.
     */
    skip?: number
    distinct?: StudentLearningProgressScalarFieldEnum | StudentLearningProgressScalarFieldEnum[]
  }

  /**
   * StudentLearningProgress create
   */
  export type StudentLearningProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentLearningProgress.
     */
    data: XOR<StudentLearningProgressCreateInput, StudentLearningProgressUncheckedCreateInput>
  }

  /**
   * StudentLearningProgress createMany
   */
  export type StudentLearningProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentLearningProgresses.
     */
    data: StudentLearningProgressCreateManyInput | StudentLearningProgressCreateManyInput[]
  }

  /**
   * StudentLearningProgress createManyAndReturn
   */
  export type StudentLearningProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentLearningProgresses.
     */
    data: StudentLearningProgressCreateManyInput | StudentLearningProgressCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentLearningProgress update
   */
  export type StudentLearningProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentLearningProgress.
     */
    data: XOR<StudentLearningProgressUpdateInput, StudentLearningProgressUncheckedUpdateInput>
    /**
     * Choose, which StudentLearningProgress to update.
     */
    where: StudentLearningProgressWhereUniqueInput
  }

  /**
   * StudentLearningProgress updateMany
   */
  export type StudentLearningProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentLearningProgresses.
     */
    data: XOR<StudentLearningProgressUpdateManyMutationInput, StudentLearningProgressUncheckedUpdateManyInput>
    /**
     * Filter which StudentLearningProgresses to update
     */
    where?: StudentLearningProgressWhereInput
  }

  /**
   * StudentLearningProgress upsert
   */
  export type StudentLearningProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentLearningProgress to update in case it exists.
     */
    where: StudentLearningProgressWhereUniqueInput
    /**
     * In case the StudentLearningProgress found by the `where` argument doesn't exist, create a new StudentLearningProgress with this data.
     */
    create: XOR<StudentLearningProgressCreateInput, StudentLearningProgressUncheckedCreateInput>
    /**
     * In case the StudentLearningProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentLearningProgressUpdateInput, StudentLearningProgressUncheckedUpdateInput>
  }

  /**
   * StudentLearningProgress delete
   */
  export type StudentLearningProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
    /**
     * Filter which StudentLearningProgress to delete.
     */
    where: StudentLearningProgressWhereUniqueInput
  }

  /**
   * StudentLearningProgress deleteMany
   */
  export type StudentLearningProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentLearningProgresses to delete
     */
    where?: StudentLearningProgressWhereInput
  }

  /**
   * StudentLearningProgress without action
   */
  export type StudentLearningProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentLearningProgress
     */
    select?: StudentLearningProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentLearningProgressInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    domain: string | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    domain: string | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    title: number
    description: number
    domain: number
    _all: number
  }


  export type RoadmapMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    domain?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    title: string
    description: string | null
    domain: string
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
  }, ExtArgs["result"]["roadmap"]>

  export type RoadmapSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    domain?: boolean
  }


  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      domain: string
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roadmaps and returns the data saved in the database.
     * @param {RoadmapCreateManyAndReturnArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roadmaps and only return the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoadmapCreateManyAndReturnArgs>(args?: SelectSubset<T, RoadmapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */ 
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly title: FieldRef<"Roadmap", 'String'>
    readonly description: FieldRef<"Roadmap", 'String'>
    readonly domain: FieldRef<"Roadmap", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
  }

  /**
   * Roadmap createManyAndReturn
   */
  export type RoadmapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
  }


  /**
   * Model Certification
   */

  export type AggregateCertification = {
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  export type CertificationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    issuer: string | null
    issueDate: Date | null
    expiryDate: Date | null
    credentialId: string | null
    credentialUrl: string | null
    source: string | null
    documentUrl: string | null
    verified: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    title: string | null
    issuer: string | null
    issueDate: Date | null
    expiryDate: Date | null
    credentialId: string | null
    credentialUrl: string | null
    source: string | null
    documentUrl: string | null
    verified: boolean | null
    metadata: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CertificationCountAggregateOutputType = {
    id: number
    studentId: number
    title: number
    issuer: number
    issueDate: number
    expiryDate: number
    credentialId: number
    credentialUrl: number
    source: number
    documentUrl: number
    verified: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CertificationMinAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuer?: true
    issueDate?: true
    expiryDate?: true
    credentialId?: true
    credentialUrl?: true
    source?: true
    documentUrl?: true
    verified?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationMaxAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuer?: true
    issueDate?: true
    expiryDate?: true
    credentialId?: true
    credentialUrl?: true
    source?: true
    documentUrl?: true
    verified?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CertificationCountAggregateInputType = {
    id?: true
    studentId?: true
    title?: true
    issuer?: true
    issueDate?: true
    expiryDate?: true
    credentialId?: true
    credentialUrl?: true
    source?: true
    documentUrl?: true
    verified?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CertificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certification to aggregate.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certifications
    **/
    _count?: true | CertificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificationMaxAggregateInputType
  }

  export type GetCertificationAggregateType<T extends CertificationAggregateArgs> = {
        [P in keyof T & keyof AggregateCertification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertification[P]>
      : GetScalarType<T[P], AggregateCertification[P]>
  }




  export type CertificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificationWhereInput
    orderBy?: CertificationOrderByWithAggregationInput | CertificationOrderByWithAggregationInput[]
    by: CertificationScalarFieldEnum[] | CertificationScalarFieldEnum
    having?: CertificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificationCountAggregateInputType | true
    _min?: CertificationMinAggregateInputType
    _max?: CertificationMaxAggregateInputType
  }

  export type CertificationGroupByOutputType = {
    id: string
    studentId: string
    title: string
    issuer: string | null
    issueDate: Date | null
    expiryDate: Date | null
    credentialId: string | null
    credentialUrl: string | null
    source: string
    documentUrl: string | null
    verified: boolean
    metadata: string | null
    createdAt: Date
    updatedAt: Date
    _count: CertificationCountAggregateOutputType | null
    _min: CertificationMinAggregateOutputType | null
    _max: CertificationMaxAggregateOutputType | null
  }

  type GetCertificationGroupByPayload<T extends CertificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificationGroupByOutputType[P]>
            : GetScalarType<T[P], CertificationGroupByOutputType[P]>
        }
      >
    >


  export type CertificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuer?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    credentialId?: boolean
    credentialUrl?: boolean
    source?: boolean
    documentUrl?: boolean
    verified?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuer?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    credentialId?: boolean
    credentialUrl?: boolean
    source?: boolean
    documentUrl?: boolean
    verified?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certification"]>

  export type CertificationSelectScalar = {
    id?: boolean
    studentId?: boolean
    title?: boolean
    issuer?: boolean
    issueDate?: boolean
    expiryDate?: boolean
    credentialId?: boolean
    credentialUrl?: boolean
    source?: boolean
    documentUrl?: boolean
    verified?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CertificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type CertificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $CertificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certification"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      title: string
      issuer: string | null
      issueDate: Date | null
      expiryDate: Date | null
      credentialId: string | null
      credentialUrl: string | null
      source: string
      documentUrl: string | null
      verified: boolean
      metadata: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["certification"]>
    composites: {}
  }

  type CertificationGetPayload<S extends boolean | null | undefined | CertificationDefaultArgs> = $Result.GetResult<Prisma.$CertificationPayload, S>

  type CertificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificationCountAggregateInputType | true
    }

  export interface CertificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certification'], meta: { name: 'Certification' } }
    /**
     * Find zero or one Certification that matches the filter.
     * @param {CertificationFindUniqueArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificationFindUniqueArgs>(args: SelectSubset<T, CertificationFindUniqueArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificationFindUniqueOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificationFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificationFindFirstArgs>(args?: SelectSubset<T, CertificationFindFirstArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindFirstOrThrowArgs} args - Arguments to find a Certification
     * @example
     * // Get one Certification
     * const certification = await prisma.certification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificationFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certifications
     * const certifications = await prisma.certification.findMany()
     * 
     * // Get first 10 Certifications
     * const certifications = await prisma.certification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificationWithIdOnly = await prisma.certification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificationFindManyArgs>(args?: SelectSubset<T, CertificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certification.
     * @param {CertificationCreateArgs} args - Arguments to create a Certification.
     * @example
     * // Create one Certification
     * const Certification = await prisma.certification.create({
     *   data: {
     *     // ... data to create a Certification
     *   }
     * })
     * 
     */
    create<T extends CertificationCreateArgs>(args: SelectSubset<T, CertificationCreateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certifications.
     * @param {CertificationCreateManyArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificationCreateManyArgs>(args?: SelectSubset<T, CertificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certifications and returns the data saved in the database.
     * @param {CertificationCreateManyAndReturnArgs} args - Arguments to create many Certifications.
     * @example
     * // Create many Certifications
     * const certification = await prisma.certification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certifications and only return the `id`
     * const certificationWithIdOnly = await prisma.certification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CertificationCreateManyAndReturnArgs>(args?: SelectSubset<T, CertificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Certification.
     * @param {CertificationDeleteArgs} args - Arguments to delete one Certification.
     * @example
     * // Delete one Certification
     * const Certification = await prisma.certification.delete({
     *   where: {
     *     // ... filter to delete one Certification
     *   }
     * })
     * 
     */
    delete<T extends CertificationDeleteArgs>(args: SelectSubset<T, CertificationDeleteArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certification.
     * @param {CertificationUpdateArgs} args - Arguments to update one Certification.
     * @example
     * // Update one Certification
     * const certification = await prisma.certification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificationUpdateArgs>(args: SelectSubset<T, CertificationUpdateArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certifications.
     * @param {CertificationDeleteManyArgs} args - Arguments to filter Certifications to delete.
     * @example
     * // Delete a few Certifications
     * const { count } = await prisma.certification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificationDeleteManyArgs>(args?: SelectSubset<T, CertificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certifications
     * const certification = await prisma.certification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificationUpdateManyArgs>(args: SelectSubset<T, CertificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certification.
     * @param {CertificationUpsertArgs} args - Arguments to update or create a Certification.
     * @example
     * // Update or create a Certification
     * const certification = await prisma.certification.upsert({
     *   create: {
     *     // ... data to create a Certification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certification we want to update
     *   }
     * })
     */
    upsert<T extends CertificationUpsertArgs>(args: SelectSubset<T, CertificationUpsertArgs<ExtArgs>>): Prisma__CertificationClient<$Result.GetResult<Prisma.$CertificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationCountArgs} args - Arguments to filter Certifications to count.
     * @example
     * // Count the number of Certifications
     * const count = await prisma.certification.count({
     *   where: {
     *     // ... the filter for the Certifications we want to count
     *   }
     * })
    **/
    count<T extends CertificationCountArgs>(
      args?: Subset<T, CertificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificationAggregateArgs>(args: Subset<T, CertificationAggregateArgs>): Prisma.PrismaPromise<GetCertificationAggregateType<T>>

    /**
     * Group by Certification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificationGroupByArgs['orderBy'] }
        : { orderBy?: CertificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certification model
   */
  readonly fields: CertificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certification model
   */ 
  interface CertificationFieldRefs {
    readonly id: FieldRef<"Certification", 'String'>
    readonly studentId: FieldRef<"Certification", 'String'>
    readonly title: FieldRef<"Certification", 'String'>
    readonly issuer: FieldRef<"Certification", 'String'>
    readonly issueDate: FieldRef<"Certification", 'DateTime'>
    readonly expiryDate: FieldRef<"Certification", 'DateTime'>
    readonly credentialId: FieldRef<"Certification", 'String'>
    readonly credentialUrl: FieldRef<"Certification", 'String'>
    readonly source: FieldRef<"Certification", 'String'>
    readonly documentUrl: FieldRef<"Certification", 'String'>
    readonly verified: FieldRef<"Certification", 'Boolean'>
    readonly metadata: FieldRef<"Certification", 'String'>
    readonly createdAt: FieldRef<"Certification", 'DateTime'>
    readonly updatedAt: FieldRef<"Certification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certification findUnique
   */
  export type CertificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findUniqueOrThrow
   */
  export type CertificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification findFirst
   */
  export type CertificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findFirstOrThrow
   */
  export type CertificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certification to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certifications.
     */
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification findMany
   */
  export type CertificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter, which Certifications to fetch.
     */
    where?: CertificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certifications to fetch.
     */
    orderBy?: CertificationOrderByWithRelationInput | CertificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certifications.
     */
    cursor?: CertificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certifications.
     */
    skip?: number
    distinct?: CertificationScalarFieldEnum | CertificationScalarFieldEnum[]
  }

  /**
   * Certification create
   */
  export type CertificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Certification.
     */
    data: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
  }

  /**
   * Certification createMany
   */
  export type CertificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
  }

  /**
   * Certification createManyAndReturn
   */
  export type CertificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Certifications.
     */
    data: CertificationCreateManyInput | CertificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Certification update
   */
  export type CertificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Certification.
     */
    data: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
    /**
     * Choose, which Certification to update.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification updateMany
   */
  export type CertificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certifications.
     */
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyInput>
    /**
     * Filter which Certifications to update
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification upsert
   */
  export type CertificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Certification to update in case it exists.
     */
    where: CertificationWhereUniqueInput
    /**
     * In case the Certification found by the `where` argument doesn't exist, create a new Certification with this data.
     */
    create: XOR<CertificationCreateInput, CertificationUncheckedCreateInput>
    /**
     * In case the Certification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificationUpdateInput, CertificationUncheckedUpdateInput>
  }

  /**
   * Certification delete
   */
  export type CertificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
    /**
     * Filter which Certification to delete.
     */
    where: CertificationWhereUniqueInput
  }

  /**
   * Certification deleteMany
   */
  export type CertificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certifications to delete
     */
    where?: CertificationWhereInput
  }

  /**
   * Certification without action
   */
  export type CertificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certification
     */
    select?: CertificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificationInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    createdAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category: string | null
    createdAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    category: number
    createdAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    category: string | null
    createdAt: Date
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
    studentSkills?: boolean | Skill$studentSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentSkills?: boolean | Skill$studentSkillsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      studentSkills: Prisma.$StudentSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category: string | null
      createdAt: Date
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    studentSkills<T extends Skill$studentSkillsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$studentSkillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */ 
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly category: FieldRef<"Skill", 'String'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
  }

  /**
   * Skill.studentSkills
   */
  export type Skill$studentSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    where?: StudentSkillWhereInput
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    cursor?: StudentSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model StudentSkill
   */

  export type AggregateStudentSkill = {
    _count: StudentSkillCountAggregateOutputType | null
    _avg: StudentSkillAvgAggregateOutputType | null
    _sum: StudentSkillSumAggregateOutputType | null
    _min: StudentSkillMinAggregateOutputType | null
    _max: StudentSkillMaxAggregateOutputType | null
  }

  export type StudentSkillAvgAggregateOutputType = {
    proficiencyLevel: number | null
    yearsExperience: number | null
  }

  export type StudentSkillSumAggregateOutputType = {
    proficiencyLevel: number | null
    yearsExperience: number | null
  }

  export type StudentSkillMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    skillId: string | null
    proficiencyLevel: number | null
    yearsExperience: number | null
    source: string | null
    createdAt: Date | null
  }

  export type StudentSkillMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    skillId: string | null
    proficiencyLevel: number | null
    yearsExperience: number | null
    source: string | null
    createdAt: Date | null
  }

  export type StudentSkillCountAggregateOutputType = {
    id: number
    studentId: number
    skillId: number
    proficiencyLevel: number
    yearsExperience: number
    source: number
    createdAt: number
    _all: number
  }


  export type StudentSkillAvgAggregateInputType = {
    proficiencyLevel?: true
    yearsExperience?: true
  }

  export type StudentSkillSumAggregateInputType = {
    proficiencyLevel?: true
    yearsExperience?: true
  }

  export type StudentSkillMinAggregateInputType = {
    id?: true
    studentId?: true
    skillId?: true
    proficiencyLevel?: true
    yearsExperience?: true
    source?: true
    createdAt?: true
  }

  export type StudentSkillMaxAggregateInputType = {
    id?: true
    studentId?: true
    skillId?: true
    proficiencyLevel?: true
    yearsExperience?: true
    source?: true
    createdAt?: true
  }

  export type StudentSkillCountAggregateInputType = {
    id?: true
    studentId?: true
    skillId?: true
    proficiencyLevel?: true
    yearsExperience?: true
    source?: true
    createdAt?: true
    _all?: true
  }

  export type StudentSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSkill to aggregate.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentSkills
    **/
    _count?: true | StudentSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StudentSkillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StudentSkillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentSkillMaxAggregateInputType
  }

  export type GetStudentSkillAggregateType<T extends StudentSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentSkill[P]>
      : GetScalarType<T[P], AggregateStudentSkill[P]>
  }




  export type StudentSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentSkillWhereInput
    orderBy?: StudentSkillOrderByWithAggregationInput | StudentSkillOrderByWithAggregationInput[]
    by: StudentSkillScalarFieldEnum[] | StudentSkillScalarFieldEnum
    having?: StudentSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentSkillCountAggregateInputType | true
    _avg?: StudentSkillAvgAggregateInputType
    _sum?: StudentSkillSumAggregateInputType
    _min?: StudentSkillMinAggregateInputType
    _max?: StudentSkillMaxAggregateInputType
  }

  export type StudentSkillGroupByOutputType = {
    id: string
    studentId: string
    skillId: string
    proficiencyLevel: number
    yearsExperience: number | null
    source: string
    createdAt: Date
    _count: StudentSkillCountAggregateOutputType | null
    _avg: StudentSkillAvgAggregateOutputType | null
    _sum: StudentSkillSumAggregateOutputType | null
    _min: StudentSkillMinAggregateOutputType | null
    _max: StudentSkillMaxAggregateOutputType | null
  }

  type GetStudentSkillGroupByPayload<T extends StudentSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentSkillGroupByOutputType[P]>
            : GetScalarType<T[P], StudentSkillGroupByOutputType[P]>
        }
      >
    >


  export type StudentSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    yearsExperience?: boolean
    source?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSkill"]>

  export type StudentSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    yearsExperience?: boolean
    source?: boolean
    createdAt?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentSkill"]>

  export type StudentSkillSelectScalar = {
    id?: boolean
    studentId?: boolean
    skillId?: boolean
    proficiencyLevel?: boolean
    yearsExperience?: boolean
    source?: boolean
    createdAt?: boolean
  }

  export type StudentSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type StudentSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $StudentSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentSkill"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      skillId: string
      proficiencyLevel: number
      yearsExperience: number | null
      source: string
      createdAt: Date
    }, ExtArgs["result"]["studentSkill"]>
    composites: {}
  }

  type StudentSkillGetPayload<S extends boolean | null | undefined | StudentSkillDefaultArgs> = $Result.GetResult<Prisma.$StudentSkillPayload, S>

  type StudentSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StudentSkillFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StudentSkillCountAggregateInputType | true
    }

  export interface StudentSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentSkill'], meta: { name: 'StudentSkill' } }
    /**
     * Find zero or one StudentSkill that matches the filter.
     * @param {StudentSkillFindUniqueArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentSkillFindUniqueArgs>(args: SelectSubset<T, StudentSkillFindUniqueArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StudentSkill that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StudentSkillFindUniqueOrThrowArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StudentSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindFirstArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentSkillFindFirstArgs>(args?: SelectSubset<T, StudentSkillFindFirstArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StudentSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindFirstOrThrowArgs} args - Arguments to find a StudentSkill
     * @example
     * // Get one StudentSkill
     * const studentSkill = await prisma.studentSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StudentSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentSkills
     * const studentSkills = await prisma.studentSkill.findMany()
     * 
     * // Get first 10 StudentSkills
     * const studentSkills = await prisma.studentSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentSkillWithIdOnly = await prisma.studentSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentSkillFindManyArgs>(args?: SelectSubset<T, StudentSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StudentSkill.
     * @param {StudentSkillCreateArgs} args - Arguments to create a StudentSkill.
     * @example
     * // Create one StudentSkill
     * const StudentSkill = await prisma.studentSkill.create({
     *   data: {
     *     // ... data to create a StudentSkill
     *   }
     * })
     * 
     */
    create<T extends StudentSkillCreateArgs>(args: SelectSubset<T, StudentSkillCreateArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StudentSkills.
     * @param {StudentSkillCreateManyArgs} args - Arguments to create many StudentSkills.
     * @example
     * // Create many StudentSkills
     * const studentSkill = await prisma.studentSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentSkillCreateManyArgs>(args?: SelectSubset<T, StudentSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentSkills and returns the data saved in the database.
     * @param {StudentSkillCreateManyAndReturnArgs} args - Arguments to create many StudentSkills.
     * @example
     * // Create many StudentSkills
     * const studentSkill = await prisma.studentSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentSkills and only return the `id`
     * const studentSkillWithIdOnly = await prisma.studentSkill.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a StudentSkill.
     * @param {StudentSkillDeleteArgs} args - Arguments to delete one StudentSkill.
     * @example
     * // Delete one StudentSkill
     * const StudentSkill = await prisma.studentSkill.delete({
     *   where: {
     *     // ... filter to delete one StudentSkill
     *   }
     * })
     * 
     */
    delete<T extends StudentSkillDeleteArgs>(args: SelectSubset<T, StudentSkillDeleteArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StudentSkill.
     * @param {StudentSkillUpdateArgs} args - Arguments to update one StudentSkill.
     * @example
     * // Update one StudentSkill
     * const studentSkill = await prisma.studentSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentSkillUpdateArgs>(args: SelectSubset<T, StudentSkillUpdateArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StudentSkills.
     * @param {StudentSkillDeleteManyArgs} args - Arguments to filter StudentSkills to delete.
     * @example
     * // Delete a few StudentSkills
     * const { count } = await prisma.studentSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentSkillDeleteManyArgs>(args?: SelectSubset<T, StudentSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentSkills
     * const studentSkill = await prisma.studentSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentSkillUpdateManyArgs>(args: SelectSubset<T, StudentSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StudentSkill.
     * @param {StudentSkillUpsertArgs} args - Arguments to update or create a StudentSkill.
     * @example
     * // Update or create a StudentSkill
     * const studentSkill = await prisma.studentSkill.upsert({
     *   create: {
     *     // ... data to create a StudentSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentSkill we want to update
     *   }
     * })
     */
    upsert<T extends StudentSkillUpsertArgs>(args: SelectSubset<T, StudentSkillUpsertArgs<ExtArgs>>): Prisma__StudentSkillClient<$Result.GetResult<Prisma.$StudentSkillPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StudentSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillCountArgs} args - Arguments to filter StudentSkills to count.
     * @example
     * // Count the number of StudentSkills
     * const count = await prisma.studentSkill.count({
     *   where: {
     *     // ... the filter for the StudentSkills we want to count
     *   }
     * })
    **/
    count<T extends StudentSkillCountArgs>(
      args?: Subset<T, StudentSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentSkillAggregateArgs>(args: Subset<T, StudentSkillAggregateArgs>): Prisma.PrismaPromise<GetStudentSkillAggregateType<T>>

    /**
     * Group by StudentSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentSkillGroupByArgs['orderBy'] }
        : { orderBy?: StudentSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentSkill model
   */
  readonly fields: StudentSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentSkill model
   */ 
  interface StudentSkillFieldRefs {
    readonly id: FieldRef<"StudentSkill", 'String'>
    readonly studentId: FieldRef<"StudentSkill", 'String'>
    readonly skillId: FieldRef<"StudentSkill", 'String'>
    readonly proficiencyLevel: FieldRef<"StudentSkill", 'Int'>
    readonly yearsExperience: FieldRef<"StudentSkill", 'Float'>
    readonly source: FieldRef<"StudentSkill", 'String'>
    readonly createdAt: FieldRef<"StudentSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentSkill findUnique
   */
  export type StudentSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill findUniqueOrThrow
   */
  export type StudentSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill findFirst
   */
  export type StudentSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSkills.
     */
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill findFirstOrThrow
   */
  export type StudentSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkill to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentSkills.
     */
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill findMany
   */
  export type StudentSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter, which StudentSkills to fetch.
     */
    where?: StudentSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentSkills to fetch.
     */
    orderBy?: StudentSkillOrderByWithRelationInput | StudentSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentSkills.
     */
    cursor?: StudentSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StudentSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentSkills.
     */
    skip?: number
    distinct?: StudentSkillScalarFieldEnum | StudentSkillScalarFieldEnum[]
  }

  /**
   * StudentSkill create
   */
  export type StudentSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentSkill.
     */
    data: XOR<StudentSkillCreateInput, StudentSkillUncheckedCreateInput>
  }

  /**
   * StudentSkill createMany
   */
  export type StudentSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentSkills.
     */
    data: StudentSkillCreateManyInput | StudentSkillCreateManyInput[]
  }

  /**
   * StudentSkill createManyAndReturn
   */
  export type StudentSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many StudentSkills.
     */
    data: StudentSkillCreateManyInput | StudentSkillCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentSkill update
   */
  export type StudentSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentSkill.
     */
    data: XOR<StudentSkillUpdateInput, StudentSkillUncheckedUpdateInput>
    /**
     * Choose, which StudentSkill to update.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill updateMany
   */
  export type StudentSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentSkills.
     */
    data: XOR<StudentSkillUpdateManyMutationInput, StudentSkillUncheckedUpdateManyInput>
    /**
     * Filter which StudentSkills to update
     */
    where?: StudentSkillWhereInput
  }

  /**
   * StudentSkill upsert
   */
  export type StudentSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentSkill to update in case it exists.
     */
    where: StudentSkillWhereUniqueInput
    /**
     * In case the StudentSkill found by the `where` argument doesn't exist, create a new StudentSkill with this data.
     */
    create: XOR<StudentSkillCreateInput, StudentSkillUncheckedCreateInput>
    /**
     * In case the StudentSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentSkillUpdateInput, StudentSkillUncheckedUpdateInput>
  }

  /**
   * StudentSkill delete
   */
  export type StudentSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
    /**
     * Filter which StudentSkill to delete.
     */
    where: StudentSkillWhereUniqueInput
  }

  /**
   * StudentSkill deleteMany
   */
  export type StudentSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentSkills to delete
     */
    where?: StudentSkillWhereInput
  }

  /**
   * StudentSkill without action
   */
  export type StudentSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentSkill
     */
    select?: StudentSkillSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentSkillInclude<ExtArgs> | null
  }


  /**
   * Model CVGeneration
   */

  export type AggregateCVGeneration = {
    _count: CVGenerationCountAggregateOutputType | null
    _min: CVGenerationMinAggregateOutputType | null
    _max: CVGenerationMaxAggregateOutputType | null
  }

  export type CVGenerationMinAggregateOutputType = {
    id: string | null
    studentId: string | null
    templateName: string | null
    fileUrl: string | null
    format: string | null
    generatedAt: Date | null
    metadata: string | null
  }

  export type CVGenerationMaxAggregateOutputType = {
    id: string | null
    studentId: string | null
    templateName: string | null
    fileUrl: string | null
    format: string | null
    generatedAt: Date | null
    metadata: string | null
  }

  export type CVGenerationCountAggregateOutputType = {
    id: number
    studentId: number
    templateName: number
    fileUrl: number
    format: number
    generatedAt: number
    metadata: number
    _all: number
  }


  export type CVGenerationMinAggregateInputType = {
    id?: true
    studentId?: true
    templateName?: true
    fileUrl?: true
    format?: true
    generatedAt?: true
    metadata?: true
  }

  export type CVGenerationMaxAggregateInputType = {
    id?: true
    studentId?: true
    templateName?: true
    fileUrl?: true
    format?: true
    generatedAt?: true
    metadata?: true
  }

  export type CVGenerationCountAggregateInputType = {
    id?: true
    studentId?: true
    templateName?: true
    fileUrl?: true
    format?: true
    generatedAt?: true
    metadata?: true
    _all?: true
  }

  export type CVGenerationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CVGeneration to aggregate.
     */
    where?: CVGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CVGenerations to fetch.
     */
    orderBy?: CVGenerationOrderByWithRelationInput | CVGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CVGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CVGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CVGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CVGenerations
    **/
    _count?: true | CVGenerationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CVGenerationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CVGenerationMaxAggregateInputType
  }

  export type GetCVGenerationAggregateType<T extends CVGenerationAggregateArgs> = {
        [P in keyof T & keyof AggregateCVGeneration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCVGeneration[P]>
      : GetScalarType<T[P], AggregateCVGeneration[P]>
  }




  export type CVGenerationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CVGenerationWhereInput
    orderBy?: CVGenerationOrderByWithAggregationInput | CVGenerationOrderByWithAggregationInput[]
    by: CVGenerationScalarFieldEnum[] | CVGenerationScalarFieldEnum
    having?: CVGenerationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CVGenerationCountAggregateInputType | true
    _min?: CVGenerationMinAggregateInputType
    _max?: CVGenerationMaxAggregateInputType
  }

  export type CVGenerationGroupByOutputType = {
    id: string
    studentId: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt: Date
    metadata: string | null
    _count: CVGenerationCountAggregateOutputType | null
    _min: CVGenerationMinAggregateOutputType | null
    _max: CVGenerationMaxAggregateOutputType | null
  }

  type GetCVGenerationGroupByPayload<T extends CVGenerationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CVGenerationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CVGenerationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CVGenerationGroupByOutputType[P]>
            : GetScalarType<T[P], CVGenerationGroupByOutputType[P]>
        }
      >
    >


  export type CVGenerationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    templateName?: boolean
    fileUrl?: boolean
    format?: boolean
    generatedAt?: boolean
    metadata?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cVGeneration"]>

  export type CVGenerationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    studentId?: boolean
    templateName?: boolean
    fileUrl?: boolean
    format?: boolean
    generatedAt?: boolean
    metadata?: boolean
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cVGeneration"]>

  export type CVGenerationSelectScalar = {
    id?: boolean
    studentId?: boolean
    templateName?: boolean
    fileUrl?: boolean
    format?: boolean
    generatedAt?: boolean
    metadata?: boolean
  }

  export type CVGenerationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }
  export type CVGenerationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentDefaultArgs<ExtArgs>
  }

  export type $CVGenerationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CVGeneration"
    objects: {
      student: Prisma.$StudentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      studentId: string
      templateName: string
      fileUrl: string
      format: string
      generatedAt: Date
      metadata: string | null
    }, ExtArgs["result"]["cVGeneration"]>
    composites: {}
  }

  type CVGenerationGetPayload<S extends boolean | null | undefined | CVGenerationDefaultArgs> = $Result.GetResult<Prisma.$CVGenerationPayload, S>

  type CVGenerationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CVGenerationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CVGenerationCountAggregateInputType | true
    }

  export interface CVGenerationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CVGeneration'], meta: { name: 'CVGeneration' } }
    /**
     * Find zero or one CVGeneration that matches the filter.
     * @param {CVGenerationFindUniqueArgs} args - Arguments to find a CVGeneration
     * @example
     * // Get one CVGeneration
     * const cVGeneration = await prisma.cVGeneration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CVGenerationFindUniqueArgs>(args: SelectSubset<T, CVGenerationFindUniqueArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CVGeneration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CVGenerationFindUniqueOrThrowArgs} args - Arguments to find a CVGeneration
     * @example
     * // Get one CVGeneration
     * const cVGeneration = await prisma.cVGeneration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CVGenerationFindUniqueOrThrowArgs>(args: SelectSubset<T, CVGenerationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CVGeneration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationFindFirstArgs} args - Arguments to find a CVGeneration
     * @example
     * // Get one CVGeneration
     * const cVGeneration = await prisma.cVGeneration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CVGenerationFindFirstArgs>(args?: SelectSubset<T, CVGenerationFindFirstArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CVGeneration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationFindFirstOrThrowArgs} args - Arguments to find a CVGeneration
     * @example
     * // Get one CVGeneration
     * const cVGeneration = await prisma.cVGeneration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CVGenerationFindFirstOrThrowArgs>(args?: SelectSubset<T, CVGenerationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CVGenerations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CVGenerations
     * const cVGenerations = await prisma.cVGeneration.findMany()
     * 
     * // Get first 10 CVGenerations
     * const cVGenerations = await prisma.cVGeneration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cVGenerationWithIdOnly = await prisma.cVGeneration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CVGenerationFindManyArgs>(args?: SelectSubset<T, CVGenerationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CVGeneration.
     * @param {CVGenerationCreateArgs} args - Arguments to create a CVGeneration.
     * @example
     * // Create one CVGeneration
     * const CVGeneration = await prisma.cVGeneration.create({
     *   data: {
     *     // ... data to create a CVGeneration
     *   }
     * })
     * 
     */
    create<T extends CVGenerationCreateArgs>(args: SelectSubset<T, CVGenerationCreateArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CVGenerations.
     * @param {CVGenerationCreateManyArgs} args - Arguments to create many CVGenerations.
     * @example
     * // Create many CVGenerations
     * const cVGeneration = await prisma.cVGeneration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CVGenerationCreateManyArgs>(args?: SelectSubset<T, CVGenerationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CVGenerations and returns the data saved in the database.
     * @param {CVGenerationCreateManyAndReturnArgs} args - Arguments to create many CVGenerations.
     * @example
     * // Create many CVGenerations
     * const cVGeneration = await prisma.cVGeneration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CVGenerations and only return the `id`
     * const cVGenerationWithIdOnly = await prisma.cVGeneration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CVGenerationCreateManyAndReturnArgs>(args?: SelectSubset<T, CVGenerationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CVGeneration.
     * @param {CVGenerationDeleteArgs} args - Arguments to delete one CVGeneration.
     * @example
     * // Delete one CVGeneration
     * const CVGeneration = await prisma.cVGeneration.delete({
     *   where: {
     *     // ... filter to delete one CVGeneration
     *   }
     * })
     * 
     */
    delete<T extends CVGenerationDeleteArgs>(args: SelectSubset<T, CVGenerationDeleteArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CVGeneration.
     * @param {CVGenerationUpdateArgs} args - Arguments to update one CVGeneration.
     * @example
     * // Update one CVGeneration
     * const cVGeneration = await prisma.cVGeneration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CVGenerationUpdateArgs>(args: SelectSubset<T, CVGenerationUpdateArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CVGenerations.
     * @param {CVGenerationDeleteManyArgs} args - Arguments to filter CVGenerations to delete.
     * @example
     * // Delete a few CVGenerations
     * const { count } = await prisma.cVGeneration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CVGenerationDeleteManyArgs>(args?: SelectSubset<T, CVGenerationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CVGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CVGenerations
     * const cVGeneration = await prisma.cVGeneration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CVGenerationUpdateManyArgs>(args: SelectSubset<T, CVGenerationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CVGeneration.
     * @param {CVGenerationUpsertArgs} args - Arguments to update or create a CVGeneration.
     * @example
     * // Update or create a CVGeneration
     * const cVGeneration = await prisma.cVGeneration.upsert({
     *   create: {
     *     // ... data to create a CVGeneration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CVGeneration we want to update
     *   }
     * })
     */
    upsert<T extends CVGenerationUpsertArgs>(args: SelectSubset<T, CVGenerationUpsertArgs<ExtArgs>>): Prisma__CVGenerationClient<$Result.GetResult<Prisma.$CVGenerationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CVGenerations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationCountArgs} args - Arguments to filter CVGenerations to count.
     * @example
     * // Count the number of CVGenerations
     * const count = await prisma.cVGeneration.count({
     *   where: {
     *     // ... the filter for the CVGenerations we want to count
     *   }
     * })
    **/
    count<T extends CVGenerationCountArgs>(
      args?: Subset<T, CVGenerationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CVGenerationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CVGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CVGenerationAggregateArgs>(args: Subset<T, CVGenerationAggregateArgs>): Prisma.PrismaPromise<GetCVGenerationAggregateType<T>>

    /**
     * Group by CVGeneration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CVGenerationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CVGenerationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CVGenerationGroupByArgs['orderBy'] }
        : { orderBy?: CVGenerationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CVGenerationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCVGenerationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CVGeneration model
   */
  readonly fields: CVGenerationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CVGeneration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CVGenerationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentDefaultArgs<ExtArgs>>): Prisma__StudentClient<$Result.GetResult<Prisma.$StudentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CVGeneration model
   */ 
  interface CVGenerationFieldRefs {
    readonly id: FieldRef<"CVGeneration", 'String'>
    readonly studentId: FieldRef<"CVGeneration", 'String'>
    readonly templateName: FieldRef<"CVGeneration", 'String'>
    readonly fileUrl: FieldRef<"CVGeneration", 'String'>
    readonly format: FieldRef<"CVGeneration", 'String'>
    readonly generatedAt: FieldRef<"CVGeneration", 'DateTime'>
    readonly metadata: FieldRef<"CVGeneration", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CVGeneration findUnique
   */
  export type CVGenerationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter, which CVGeneration to fetch.
     */
    where: CVGenerationWhereUniqueInput
  }

  /**
   * CVGeneration findUniqueOrThrow
   */
  export type CVGenerationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter, which CVGeneration to fetch.
     */
    where: CVGenerationWhereUniqueInput
  }

  /**
   * CVGeneration findFirst
   */
  export type CVGenerationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter, which CVGeneration to fetch.
     */
    where?: CVGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CVGenerations to fetch.
     */
    orderBy?: CVGenerationOrderByWithRelationInput | CVGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CVGenerations.
     */
    cursor?: CVGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CVGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CVGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CVGenerations.
     */
    distinct?: CVGenerationScalarFieldEnum | CVGenerationScalarFieldEnum[]
  }

  /**
   * CVGeneration findFirstOrThrow
   */
  export type CVGenerationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter, which CVGeneration to fetch.
     */
    where?: CVGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CVGenerations to fetch.
     */
    orderBy?: CVGenerationOrderByWithRelationInput | CVGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CVGenerations.
     */
    cursor?: CVGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CVGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CVGenerations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CVGenerations.
     */
    distinct?: CVGenerationScalarFieldEnum | CVGenerationScalarFieldEnum[]
  }

  /**
   * CVGeneration findMany
   */
  export type CVGenerationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter, which CVGenerations to fetch.
     */
    where?: CVGenerationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CVGenerations to fetch.
     */
    orderBy?: CVGenerationOrderByWithRelationInput | CVGenerationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CVGenerations.
     */
    cursor?: CVGenerationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CVGenerations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CVGenerations.
     */
    skip?: number
    distinct?: CVGenerationScalarFieldEnum | CVGenerationScalarFieldEnum[]
  }

  /**
   * CVGeneration create
   */
  export type CVGenerationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * The data needed to create a CVGeneration.
     */
    data: XOR<CVGenerationCreateInput, CVGenerationUncheckedCreateInput>
  }

  /**
   * CVGeneration createMany
   */
  export type CVGenerationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CVGenerations.
     */
    data: CVGenerationCreateManyInput | CVGenerationCreateManyInput[]
  }

  /**
   * CVGeneration createManyAndReturn
   */
  export type CVGenerationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CVGenerations.
     */
    data: CVGenerationCreateManyInput | CVGenerationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CVGeneration update
   */
  export type CVGenerationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * The data needed to update a CVGeneration.
     */
    data: XOR<CVGenerationUpdateInput, CVGenerationUncheckedUpdateInput>
    /**
     * Choose, which CVGeneration to update.
     */
    where: CVGenerationWhereUniqueInput
  }

  /**
   * CVGeneration updateMany
   */
  export type CVGenerationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CVGenerations.
     */
    data: XOR<CVGenerationUpdateManyMutationInput, CVGenerationUncheckedUpdateManyInput>
    /**
     * Filter which CVGenerations to update
     */
    where?: CVGenerationWhereInput
  }

  /**
   * CVGeneration upsert
   */
  export type CVGenerationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * The filter to search for the CVGeneration to update in case it exists.
     */
    where: CVGenerationWhereUniqueInput
    /**
     * In case the CVGeneration found by the `where` argument doesn't exist, create a new CVGeneration with this data.
     */
    create: XOR<CVGenerationCreateInput, CVGenerationUncheckedCreateInput>
    /**
     * In case the CVGeneration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CVGenerationUpdateInput, CVGenerationUncheckedUpdateInput>
  }

  /**
   * CVGeneration delete
   */
  export type CVGenerationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
    /**
     * Filter which CVGeneration to delete.
     */
    where: CVGenerationWhereUniqueInput
  }

  /**
   * CVGeneration deleteMany
   */
  export type CVGenerationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CVGenerations to delete
     */
    where?: CVGenerationWhereInput
  }

  /**
   * CVGeneration without action
   */
  export type CVGenerationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CVGeneration
     */
    select?: CVGenerationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CVGenerationInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: bigint | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalFilename: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: bigint | null
    category: string | null
    uploadedAt: Date | null
    metadata: string | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    filename: string | null
    originalFilename: string | null
    fileUrl: string | null
    fileType: string | null
    fileSize: bigint | null
    category: string | null
    uploadedAt: Date | null
    metadata: string | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    userId: number
    filename: number
    originalFilename: number
    fileUrl: number
    fileType: number
    fileSize: number
    category: number
    uploadedAt: number
    metadata: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalFilename?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    category?: true
    uploadedAt?: true
    metadata?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalFilename?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    category?: true
    uploadedAt?: true
    metadata?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    userId?: true
    filename?: true
    originalFilename?: true
    fileUrl?: true
    fileType?: true
    fileSize?: true
    category?: true
    uploadedAt?: true
    metadata?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    userId: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType: string | null
    fileSize: bigint | null
    category: string | null
    uploadedAt: Date
    metadata: string | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    category?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    category?: boolean
    uploadedAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    userId?: boolean
    filename?: boolean
    originalFilename?: boolean
    fileUrl?: boolean
    fileType?: boolean
    fileSize?: boolean
    category?: boolean
    uploadedAt?: boolean
    metadata?: boolean
  }

  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      filename: string
      originalFilename: string
      fileUrl: string
      fileType: string | null
      fileSize: bigint | null
      category: string | null
      uploadedAt: Date
      metadata: string | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */ 
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly userId: FieldRef<"Document", 'String'>
    readonly filename: FieldRef<"Document", 'String'>
    readonly originalFilename: FieldRef<"Document", 'String'>
    readonly fileUrl: FieldRef<"Document", 'String'>
    readonly fileType: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'BigInt'>
    readonly category: FieldRef<"Document", 'String'>
    readonly uploadedAt: FieldRef<"Document", 'DateTime'>
    readonly metadata: FieldRef<"Document", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    teamRole: 'teamRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    githubUsername: 'githubUsername',
    githubToken: 'githubToken',
    githubConnectedAt: 'githubConnectedAt',
    lastGithubSync: 'lastGithubSync',
    profilePictureUrl: 'profilePictureUrl',
    resumeUrl: 'resumeUrl'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const WorkspaceScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    folderId: 'folderId',
    teamId: 'teamId',
    userId: 'userId'
  };

  export type WorkspaceScalarFieldEnum = (typeof WorkspaceScalarFieldEnum)[keyof typeof WorkspaceScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const InviteScalarFieldEnum: {
    id: 'id',
    inviteId: 'inviteId',
    workspaceId: 'workspaceId',
    type: 'type',
    inviterId: 'inviterId'
  };

  export type InviteScalarFieldEnum = (typeof InviteScalarFieldEnum)[keyof typeof InviteScalarFieldEnum]


  export const ChatScalarFieldEnum: {
    id: 'id',
    duration: 'duration',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    workspaceId: 'workspaceId',
    userId: 'userId'
  };

  export type ChatScalarFieldEnum = (typeof ChatScalarFieldEnum)[keyof typeof ChatScalarFieldEnum]


  export const StudentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    rollNumber: 'rollNumber',
    department: 'department',
    semester: 'semester',
    cgpa: 'cgpa',
    dateOfBirth: 'dateOfBirth',
    phone: 'phone',
    approved: 'approved',
    approvedAt: 'approvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentScalarFieldEnum = (typeof StudentScalarFieldEnum)[keyof typeof StudentScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    bio: 'bio',
    gender: 'gender',
    dob: 'dob',
    avatarUrl: 'avatarUrl',
    github: 'github',
    linkedin: 'linkedin',
    skills: 'skills',
    interests: 'interests',
    resumeUrl: 'resumeUrl',
    department: 'department',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const InternshipScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    companyName: 'companyName',
    location: 'location',
    type: 'type',
    duration: 'duration',
    stipend: 'stipend',
    requiredSkills: 'requiredSkills',
    startDate: 'startDate',
    endDate: 'endDate',
    applicationDeadline: 'applicationDeadline',
    isActive: 'isActive',
    postedBy: 'postedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InternshipScalarFieldEnum = (typeof InternshipScalarFieldEnum)[keyof typeof InternshipScalarFieldEnum]


  export const InternshipApplicationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    internshipId: 'internshipId',
    status: 'status',
    coverLetter: 'coverLetter',
    resumeUrl: 'resumeUrl',
    appliedAt: 'appliedAt',
    reviewedAt: 'reviewedAt',
    rejectionReason: 'rejectionReason'
  };

  export type InternshipApplicationScalarFieldEnum = (typeof InternshipApplicationScalarFieldEnum)[keyof typeof InternshipApplicationScalarFieldEnum]


  export const InternshipEvaluationScalarFieldEnum: {
    id: 'id',
    internshipId: 'internshipId',
    evaluatorId: 'evaluatorId',
    facultyId: 'facultyId',
    rubricJson: 'rubricJson',
    comments: 'comments',
    finalScore: 'finalScore',
    createdAt: 'createdAt'
  };

  export type InternshipEvaluationScalarFieldEnum = (typeof InternshipEvaluationScalarFieldEnum)[keyof typeof InternshipEvaluationScalarFieldEnum]


  export const CourseScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    type: 'type',
    price: 'price',
    thumbnail: 'thumbnail',
    instructorId: 'instructorId',
    thumbnailUrl: 'thumbnailUrl',
    createdAt: 'createdAt'
  };

  export type CourseScalarFieldEnum = (typeof CourseScalarFieldEnum)[keyof typeof CourseScalarFieldEnum]


  export const CourseEnrollmentScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    courseId: 'courseId',
    enrolledAt: 'enrolledAt',
    progressPercent: 'progressPercent',
    completedAt: 'completedAt'
  };

  export type CourseEnrollmentScalarFieldEnum = (typeof CourseEnrollmentScalarFieldEnum)[keyof typeof CourseEnrollmentScalarFieldEnum]


  export const CheckpointScalarFieldEnum: {
    id: 'id',
    courseId: 'courseId',
    title: 'title',
    description: 'description',
    resourceUrl: 'resourceUrl'
  };

  export type CheckpointScalarFieldEnum = (typeof CheckpointScalarFieldEnum)[keyof typeof CheckpointScalarFieldEnum]


  export const PortfolioProjectScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    title: 'title',
    description: 'description',
    githubUrl: 'githubUrl',
    liveUrl: 'liveUrl',
    tags: 'tags',
    createdAt: 'createdAt',
    source: 'source',
    githubRepoId: 'githubRepoId',
    lastSyncedAt: 'lastSyncedAt',
    stars: 'stars',
    forks: 'forks',
    language: 'language'
  };

  export type PortfolioProjectScalarFieldEnum = (typeof PortfolioProjectScalarFieldEnum)[keyof typeof PortfolioProjectScalarFieldEnum]


  export const MentorSessionScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    mentorId: 'mentorId',
    scheduledAt: 'scheduledAt',
    status: 'status',
    meetingLink: 'meetingLink',
    createdAt: 'createdAt'
  };

  export type MentorSessionScalarFieldEnum = (typeof MentorSessionScalarFieldEnum)[keyof typeof MentorSessionScalarFieldEnum]


  export const MentorReviewScalarFieldEnum: {
    id: 'id',
    sessionId: 'sessionId',
    studentId: 'studentId',
    rating: 'rating',
    review: 'review'
  };

  export type MentorReviewScalarFieldEnum = (typeof MentorReviewScalarFieldEnum)[keyof typeof MentorReviewScalarFieldEnum]


  export const LogbookEntryScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    date: 'date',
    task: 'task',
    hours: 'hours',
    description: 'description',
    proofUrl: 'proofUrl',
    createdAt: 'createdAt'
  };

  export type LogbookEntryScalarFieldEnum = (typeof LogbookEntryScalarFieldEnum)[keyof typeof LogbookEntryScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    title: 'title',
    issuedAt: 'issuedAt',
    certificateUrl: 'certificateUrl'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const StudentLearningProgressScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    profileId: 'profileId',
    isCompleted: 'isCompleted',
    completedAt: 'completedAt',
    checkpointId: 'checkpointId'
  };

  export type StudentLearningProgressScalarFieldEnum = (typeof StudentLearningProgressScalarFieldEnum)[keyof typeof StudentLearningProgressScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    domain: 'domain'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const CertificationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    title: 'title',
    issuer: 'issuer',
    issueDate: 'issueDate',
    expiryDate: 'expiryDate',
    credentialId: 'credentialId',
    credentialUrl: 'credentialUrl',
    source: 'source',
    documentUrl: 'documentUrl',
    verified: 'verified',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CertificationScalarFieldEnum = (typeof CertificationScalarFieldEnum)[keyof typeof CertificationScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const StudentSkillScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    skillId: 'skillId',
    proficiencyLevel: 'proficiencyLevel',
    yearsExperience: 'yearsExperience',
    source: 'source',
    createdAt: 'createdAt'
  };

  export type StudentSkillScalarFieldEnum = (typeof StudentSkillScalarFieldEnum)[keyof typeof StudentSkillScalarFieldEnum]


  export const CVGenerationScalarFieldEnum: {
    id: 'id',
    studentId: 'studentId',
    templateName: 'templateName',
    fileUrl: 'fileUrl',
    format: 'format',
    generatedAt: 'generatedAt',
    metadata: 'metadata'
  };

  export type CVGenerationScalarFieldEnum = (typeof CVGenerationScalarFieldEnum)[keyof typeof CVGenerationScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    filename: 'filename',
    originalFilename: 'originalFilename',
    fileUrl: 'fileUrl',
    fileType: 'fileType',
    fileSize: 'fileSize',
    category: 'category',
    uploadedAt: 'uploadedAt',
    metadata: 'metadata'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    teamRole?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    githubUsername?: StringNullableFilter<"User"> | string | null
    githubToken?: StringNullableFilter<"User"> | string | null
    githubConnectedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastGithubSync?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    resumeUrl?: StringNullableFilter<"User"> | string | null
    workspaces?: WorkspaceListRelationFilter
    invites?: InviteListRelationFilter
    teams?: TeamListRelationFilter
    chats?: ChatListRelationFilter
    documents?: DocumentListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    mentorSessions?: MentorSessionListRelationFilter
    evaluationsGiven?: InternshipEvaluationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    teamRole?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubUsername?: SortOrderInput | SortOrder
    githubToken?: SortOrderInput | SortOrder
    githubConnectedAt?: SortOrderInput | SortOrder
    lastGithubSync?: SortOrderInput | SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    workspaces?: WorkspaceOrderByRelationAggregateInput
    invites?: InviteOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    chats?: ChatOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    student?: StudentOrderByWithRelationInput
    mentorSessions?: MentorSessionOrderByRelationAggregateInput
    evaluationsGiven?: InternshipEvaluationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    teamRole?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    githubUsername?: StringNullableFilter<"User"> | string | null
    githubToken?: StringNullableFilter<"User"> | string | null
    githubConnectedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastGithubSync?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    resumeUrl?: StringNullableFilter<"User"> | string | null
    workspaces?: WorkspaceListRelationFilter
    invites?: InviteListRelationFilter
    teams?: TeamListRelationFilter
    chats?: ChatListRelationFilter
    documents?: DocumentListRelationFilter
    student?: XOR<StudentNullableRelationFilter, StudentWhereInput> | null
    mentorSessions?: MentorSessionListRelationFilter
    evaluationsGiven?: InternshipEvaluationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    teamRole?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubUsername?: SortOrderInput | SortOrder
    githubToken?: SortOrderInput | SortOrder
    githubConnectedAt?: SortOrderInput | SortOrder
    lastGithubSync?: SortOrderInput | SortOrder
    profilePictureUrl?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    teamRole?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    githubUsername?: StringNullableWithAggregatesFilter<"User"> | string | null
    githubToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    githubConnectedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastGithubSync?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    profilePictureUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type WorkspaceWhereInput = {
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    id?: StringFilter<"Workspace"> | string
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    folderId?: StringNullableFilter<"Workspace"> | string | null
    teamId?: StringNullableFilter<"Workspace"> | string | null
    userId?: StringFilter<"Workspace"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableRelationFilter, FolderWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    chats?: ChatListRelationFilter
    invites?: InviteListRelationFilter
  }

  export type WorkspaceOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    folderId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
    chats?: ChatOrderByRelationAggregateInput
    invites?: InviteOrderByRelationAggregateInput
  }

  export type WorkspaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkspaceWhereInput | WorkspaceWhereInput[]
    OR?: WorkspaceWhereInput[]
    NOT?: WorkspaceWhereInput | WorkspaceWhereInput[]
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    folderId?: StringNullableFilter<"Workspace"> | string | null
    teamId?: StringNullableFilter<"Workspace"> | string | null
    userId?: StringFilter<"Workspace"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    folder?: XOR<FolderNullableRelationFilter, FolderWhereInput> | null
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
    chats?: ChatListRelationFilter
    invites?: InviteListRelationFilter
  }, "id">

  export type WorkspaceOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    folderId?: SortOrderInput | SortOrder
    teamId?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: WorkspaceCountOrderByAggregateInput
    _max?: WorkspaceMaxOrderByAggregateInput
    _min?: WorkspaceMinOrderByAggregateInput
  }

  export type WorkspaceScalarWhereWithAggregatesInput = {
    AND?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    OR?: WorkspaceScalarWhereWithAggregatesInput[]
    NOT?: WorkspaceScalarWhereWithAggregatesInput | WorkspaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Workspace"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Workspace"> | Date | string
    folderId?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"Workspace"> | string | null
    userId?: StringWithAggregatesFilter<"Workspace"> | string
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    workspaces?: WorkspaceListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    workspaces?: WorkspaceOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    name?: StringFilter<"Folder"> | string
    workspaces?: WorkspaceListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
    workspaces?: WorkspaceListRelationFilter
    users?: UserListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    workspaces?: WorkspaceOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    name?: StringFilter<"Team"> | string
    workspaces?: WorkspaceListRelationFilter
    users?: UserListRelationFilter
  }, "id">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    name?: StringWithAggregatesFilter<"Team"> | string
  }

  export type InviteWhereInput = {
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    id?: StringFilter<"Invite"> | string
    inviteId?: StringFilter<"Invite"> | string
    workspaceId?: StringFilter<"Invite"> | string
    type?: StringFilter<"Invite"> | string
    inviterId?: StringFilter<"Invite"> | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InviteOrderByWithRelationInput = {
    id?: SortOrder
    inviteId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    inviterId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    inviter?: UserOrderByWithRelationInput
  }

  export type InviteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteId?: string
    AND?: InviteWhereInput | InviteWhereInput[]
    OR?: InviteWhereInput[]
    NOT?: InviteWhereInput | InviteWhereInput[]
    workspaceId?: StringFilter<"Invite"> | string
    type?: StringFilter<"Invite"> | string
    inviterId?: StringFilter<"Invite"> | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    inviter?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "inviteId">

  export type InviteOrderByWithAggregationInput = {
    id?: SortOrder
    inviteId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    inviterId?: SortOrder
    _count?: InviteCountOrderByAggregateInput
    _max?: InviteMaxOrderByAggregateInput
    _min?: InviteMinOrderByAggregateInput
  }

  export type InviteScalarWhereWithAggregatesInput = {
    AND?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    OR?: InviteScalarWhereWithAggregatesInput[]
    NOT?: InviteScalarWhereWithAggregatesInput | InviteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invite"> | string
    inviteId?: StringWithAggregatesFilter<"Invite"> | string
    workspaceId?: StringWithAggregatesFilter<"Invite"> | string
    type?: StringWithAggregatesFilter<"Invite"> | string
    inviterId?: StringWithAggregatesFilter<"Invite"> | string
  }

  export type ChatWhereInput = {
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    id?: StringFilter<"Chat"> | string
    duration?: IntNullableFilter<"Chat"> | number | null
    startedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    workspaceId?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ChatOrderByWithRelationInput = {
    id?: SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    workspace?: WorkspaceOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ChatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatWhereInput | ChatWhereInput[]
    OR?: ChatWhereInput[]
    NOT?: ChatWhereInput | ChatWhereInput[]
    duration?: IntNullableFilter<"Chat"> | number | null
    startedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    workspaceId?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
    workspace?: XOR<WorkspaceRelationFilter, WorkspaceWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ChatOrderByWithAggregationInput = {
    id?: SortOrder
    duration?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
    _count?: ChatCountOrderByAggregateInput
    _avg?: ChatAvgOrderByAggregateInput
    _max?: ChatMaxOrderByAggregateInput
    _min?: ChatMinOrderByAggregateInput
    _sum?: ChatSumOrderByAggregateInput
  }

  export type ChatScalarWhereWithAggregatesInput = {
    AND?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    OR?: ChatScalarWhereWithAggregatesInput[]
    NOT?: ChatScalarWhereWithAggregatesInput | ChatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Chat"> | string
    duration?: IntNullableWithAggregatesFilter<"Chat"> | number | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"Chat"> | Date | string | null
    workspaceId?: StringWithAggregatesFilter<"Chat"> | string
    userId?: StringWithAggregatesFilter<"Chat"> | string
  }

  export type StudentWhereInput = {
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    id?: StringFilter<"Student"> | string
    userId?: StringFilter<"Student"> | string
    rollNumber?: StringNullableFilter<"Student"> | string | null
    department?: StringNullableFilter<"Student"> | string | null
    semester?: IntNullableFilter<"Student"> | number | null
    cgpa?: FloatNullableFilter<"Student"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    approved?: BoolFilter<"Student"> | boolean
    approvedAt?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    applications?: InternshipApplicationListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    projects?: PortfolioProjectListRelationFilter
    mentorSessions?: MentorSessionListRelationFilter
    reviews?: MentorReviewListRelationFilter
    logbookEntries?: LogbookEntryListRelationFilter
    certificates?: CertificateListRelationFilter
    learningProgress?: StudentLearningProgressListRelationFilter
    certifications?: CertificationListRelationFilter
    studentSkills?: StudentSkillListRelationFilter
    cvGenerations?: CVGenerationListRelationFilter
  }

  export type StudentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    rollNumber?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    approved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    applications?: InternshipApplicationOrderByRelationAggregateInput
    enrollments?: CourseEnrollmentOrderByRelationAggregateInput
    projects?: PortfolioProjectOrderByRelationAggregateInput
    mentorSessions?: MentorSessionOrderByRelationAggregateInput
    reviews?: MentorReviewOrderByRelationAggregateInput
    logbookEntries?: LogbookEntryOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    learningProgress?: StudentLearningProgressOrderByRelationAggregateInput
    certifications?: CertificationOrderByRelationAggregateInput
    studentSkills?: StudentSkillOrderByRelationAggregateInput
    cvGenerations?: CVGenerationOrderByRelationAggregateInput
  }

  export type StudentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    rollNumber?: string
    AND?: StudentWhereInput | StudentWhereInput[]
    OR?: StudentWhereInput[]
    NOT?: StudentWhereInput | StudentWhereInput[]
    department?: StringNullableFilter<"Student"> | string | null
    semester?: IntNullableFilter<"Student"> | number | null
    cgpa?: FloatNullableFilter<"Student"> | number | null
    dateOfBirth?: DateTimeNullableFilter<"Student"> | Date | string | null
    phone?: StringNullableFilter<"Student"> | string | null
    approved?: BoolFilter<"Student"> | boolean
    approvedAt?: DateTimeNullableFilter<"Student"> | Date | string | null
    createdAt?: DateTimeFilter<"Student"> | Date | string
    updatedAt?: DateTimeFilter<"Student"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    applications?: InternshipApplicationListRelationFilter
    enrollments?: CourseEnrollmentListRelationFilter
    projects?: PortfolioProjectListRelationFilter
    mentorSessions?: MentorSessionListRelationFilter
    reviews?: MentorReviewListRelationFilter
    logbookEntries?: LogbookEntryListRelationFilter
    certificates?: CertificateListRelationFilter
    learningProgress?: StudentLearningProgressListRelationFilter
    certifications?: CertificationListRelationFilter
    studentSkills?: StudentSkillListRelationFilter
    cvGenerations?: CVGenerationListRelationFilter
  }, "id" | "userId" | "rollNumber">

  export type StudentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    rollNumber?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    semester?: SortOrderInput | SortOrder
    cgpa?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    approved?: SortOrder
    approvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentCountOrderByAggregateInput
    _avg?: StudentAvgOrderByAggregateInput
    _max?: StudentMaxOrderByAggregateInput
    _min?: StudentMinOrderByAggregateInput
    _sum?: StudentSumOrderByAggregateInput
  }

  export type StudentScalarWhereWithAggregatesInput = {
    AND?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    OR?: StudentScalarWhereWithAggregatesInput[]
    NOT?: StudentScalarWhereWithAggregatesInput | StudentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Student"> | string
    userId?: StringWithAggregatesFilter<"Student"> | string
    rollNumber?: StringNullableWithAggregatesFilter<"Student"> | string | null
    department?: StringNullableWithAggregatesFilter<"Student"> | string | null
    semester?: IntNullableWithAggregatesFilter<"Student"> | number | null
    cgpa?: FloatNullableWithAggregatesFilter<"Student"> | number | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    phone?: StringNullableWithAggregatesFilter<"Student"> | string | null
    approved?: BoolWithAggregatesFilter<"Student"> | boolean
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Student"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Student"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    studentId?: StringFilter<"Profile"> | string
    bio?: StringNullableFilter<"Profile"> | string | null
    gender?: StringNullableFilter<"Profile"> | string | null
    dob?: DateTimeNullableFilter<"Profile"> | Date | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    github?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    skills?: StringNullableFilter<"Profile"> | string | null
    interests?: StringNullableFilter<"Profile"> | string | null
    resumeUrl?: StringNullableFilter<"Profile"> | string | null
    department?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    bio?: StringNullableFilter<"Profile"> | string | null
    gender?: StringNullableFilter<"Profile"> | string | null
    dob?: DateTimeNullableFilter<"Profile"> | Date | string | null
    avatarUrl?: StringNullableFilter<"Profile"> | string | null
    github?: StringNullableFilter<"Profile"> | string | null
    linkedin?: StringNullableFilter<"Profile"> | string | null
    skills?: StringNullableFilter<"Profile"> | string | null
    interests?: StringNullableFilter<"Profile"> | string | null
    resumeUrl?: StringNullableFilter<"Profile"> | string | null
    department?: StringNullableFilter<"Profile"> | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id" | "studentId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    bio?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    dob?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    linkedin?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    interests?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    department?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    studentId?: StringWithAggregatesFilter<"Profile"> | string
    bio?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    gender?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    dob?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    github?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    linkedin?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    skills?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    interests?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    department?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type InternshipWhereInput = {
    AND?: InternshipWhereInput | InternshipWhereInput[]
    OR?: InternshipWhereInput[]
    NOT?: InternshipWhereInput | InternshipWhereInput[]
    id?: StringFilter<"Internship"> | string
    title?: StringFilter<"Internship"> | string
    description?: StringFilter<"Internship"> | string
    companyName?: StringFilter<"Internship"> | string
    location?: StringFilter<"Internship"> | string
    type?: StringFilter<"Internship"> | string
    duration?: IntFilter<"Internship"> | number
    stipend?: IntNullableFilter<"Internship"> | number | null
    requiredSkills?: StringFilter<"Internship"> | string
    startDate?: DateTimeNullableFilter<"Internship"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Internship"> | Date | string | null
    applicationDeadline?: DateTimeNullableFilter<"Internship"> | Date | string | null
    isActive?: BoolFilter<"Internship"> | boolean
    postedBy?: StringFilter<"Internship"> | string
    createdAt?: DateTimeFilter<"Internship"> | Date | string
    updatedAt?: DateTimeFilter<"Internship"> | Date | string
    applications?: InternshipApplicationListRelationFilter
    evaluations?: InternshipEvaluationListRelationFilter
  }

  export type InternshipOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    location?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    stipend?: SortOrderInput | SortOrder
    requiredSkills?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    applicationDeadline?: SortOrderInput | SortOrder
    isActive?: SortOrder
    postedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    applications?: InternshipApplicationOrderByRelationAggregateInput
    evaluations?: InternshipEvaluationOrderByRelationAggregateInput
  }

  export type InternshipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InternshipWhereInput | InternshipWhereInput[]
    OR?: InternshipWhereInput[]
    NOT?: InternshipWhereInput | InternshipWhereInput[]
    title?: StringFilter<"Internship"> | string
    description?: StringFilter<"Internship"> | string
    companyName?: StringFilter<"Internship"> | string
    location?: StringFilter<"Internship"> | string
    type?: StringFilter<"Internship"> | string
    duration?: IntFilter<"Internship"> | number
    stipend?: IntNullableFilter<"Internship"> | number | null
    requiredSkills?: StringFilter<"Internship"> | string
    startDate?: DateTimeNullableFilter<"Internship"> | Date | string | null
    endDate?: DateTimeNullableFilter<"Internship"> | Date | string | null
    applicationDeadline?: DateTimeNullableFilter<"Internship"> | Date | string | null
    isActive?: BoolFilter<"Internship"> | boolean
    postedBy?: StringFilter<"Internship"> | string
    createdAt?: DateTimeFilter<"Internship"> | Date | string
    updatedAt?: DateTimeFilter<"Internship"> | Date | string
    applications?: InternshipApplicationListRelationFilter
    evaluations?: InternshipEvaluationListRelationFilter
  }, "id">

  export type InternshipOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    location?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    stipend?: SortOrderInput | SortOrder
    requiredSkills?: SortOrder
    startDate?: SortOrderInput | SortOrder
    endDate?: SortOrderInput | SortOrder
    applicationDeadline?: SortOrderInput | SortOrder
    isActive?: SortOrder
    postedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InternshipCountOrderByAggregateInput
    _avg?: InternshipAvgOrderByAggregateInput
    _max?: InternshipMaxOrderByAggregateInput
    _min?: InternshipMinOrderByAggregateInput
    _sum?: InternshipSumOrderByAggregateInput
  }

  export type InternshipScalarWhereWithAggregatesInput = {
    AND?: InternshipScalarWhereWithAggregatesInput | InternshipScalarWhereWithAggregatesInput[]
    OR?: InternshipScalarWhereWithAggregatesInput[]
    NOT?: InternshipScalarWhereWithAggregatesInput | InternshipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Internship"> | string
    title?: StringWithAggregatesFilter<"Internship"> | string
    description?: StringWithAggregatesFilter<"Internship"> | string
    companyName?: StringWithAggregatesFilter<"Internship"> | string
    location?: StringWithAggregatesFilter<"Internship"> | string
    type?: StringWithAggregatesFilter<"Internship"> | string
    duration?: IntWithAggregatesFilter<"Internship"> | number
    stipend?: IntNullableWithAggregatesFilter<"Internship"> | number | null
    requiredSkills?: StringWithAggregatesFilter<"Internship"> | string
    startDate?: DateTimeNullableWithAggregatesFilter<"Internship"> | Date | string | null
    endDate?: DateTimeNullableWithAggregatesFilter<"Internship"> | Date | string | null
    applicationDeadline?: DateTimeNullableWithAggregatesFilter<"Internship"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Internship"> | boolean
    postedBy?: StringWithAggregatesFilter<"Internship"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Internship"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Internship"> | Date | string
  }

  export type InternshipApplicationWhereInput = {
    AND?: InternshipApplicationWhereInput | InternshipApplicationWhereInput[]
    OR?: InternshipApplicationWhereInput[]
    NOT?: InternshipApplicationWhereInput | InternshipApplicationWhereInput[]
    id?: StringFilter<"InternshipApplication"> | string
    studentId?: StringFilter<"InternshipApplication"> | string
    internshipId?: StringFilter<"InternshipApplication"> | string
    status?: StringFilter<"InternshipApplication"> | string
    coverLetter?: StringNullableFilter<"InternshipApplication"> | string | null
    resumeUrl?: StringNullableFilter<"InternshipApplication"> | string | null
    appliedAt?: DateTimeFilter<"InternshipApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"InternshipApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"InternshipApplication"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
  }

  export type InternshipApplicationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    internshipId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    internship?: InternshipOrderByWithRelationInput
  }

  export type InternshipApplicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_internshipId?: InternshipApplicationStudentIdInternshipIdCompoundUniqueInput
    AND?: InternshipApplicationWhereInput | InternshipApplicationWhereInput[]
    OR?: InternshipApplicationWhereInput[]
    NOT?: InternshipApplicationWhereInput | InternshipApplicationWhereInput[]
    studentId?: StringFilter<"InternshipApplication"> | string
    internshipId?: StringFilter<"InternshipApplication"> | string
    status?: StringFilter<"InternshipApplication"> | string
    coverLetter?: StringNullableFilter<"InternshipApplication"> | string | null
    resumeUrl?: StringNullableFilter<"InternshipApplication"> | string | null
    appliedAt?: DateTimeFilter<"InternshipApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"InternshipApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"InternshipApplication"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
  }, "id" | "studentId_internshipId">

  export type InternshipApplicationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    internshipId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrderInput | SortOrder
    resumeUrl?: SortOrderInput | SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    _count?: InternshipApplicationCountOrderByAggregateInput
    _max?: InternshipApplicationMaxOrderByAggregateInput
    _min?: InternshipApplicationMinOrderByAggregateInput
  }

  export type InternshipApplicationScalarWhereWithAggregatesInput = {
    AND?: InternshipApplicationScalarWhereWithAggregatesInput | InternshipApplicationScalarWhereWithAggregatesInput[]
    OR?: InternshipApplicationScalarWhereWithAggregatesInput[]
    NOT?: InternshipApplicationScalarWhereWithAggregatesInput | InternshipApplicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternshipApplication"> | string
    studentId?: StringWithAggregatesFilter<"InternshipApplication"> | string
    internshipId?: StringWithAggregatesFilter<"InternshipApplication"> | string
    status?: StringWithAggregatesFilter<"InternshipApplication"> | string
    coverLetter?: StringNullableWithAggregatesFilter<"InternshipApplication"> | string | null
    resumeUrl?: StringNullableWithAggregatesFilter<"InternshipApplication"> | string | null
    appliedAt?: DateTimeWithAggregatesFilter<"InternshipApplication"> | Date | string
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"InternshipApplication"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"InternshipApplication"> | string | null
  }

  export type InternshipEvaluationWhereInput = {
    AND?: InternshipEvaluationWhereInput | InternshipEvaluationWhereInput[]
    OR?: InternshipEvaluationWhereInput[]
    NOT?: InternshipEvaluationWhereInput | InternshipEvaluationWhereInput[]
    id?: StringFilter<"InternshipEvaluation"> | string
    internshipId?: StringFilter<"InternshipEvaluation"> | string
    evaluatorId?: StringFilter<"InternshipEvaluation"> | string
    facultyId?: StringFilter<"InternshipEvaluation"> | string
    rubricJson?: StringFilter<"InternshipEvaluation"> | string
    comments?: StringNullableFilter<"InternshipEvaluation"> | string | null
    finalScore?: FloatFilter<"InternshipEvaluation"> | number
    createdAt?: DateTimeFilter<"InternshipEvaluation"> | Date | string
    internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
    evaluator?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type InternshipEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    internshipId?: SortOrder
    evaluatorId?: SortOrder
    facultyId?: SortOrder
    rubricJson?: SortOrder
    comments?: SortOrderInput | SortOrder
    finalScore?: SortOrder
    createdAt?: SortOrder
    internship?: InternshipOrderByWithRelationInput
    evaluator?: UserOrderByWithRelationInput
  }

  export type InternshipEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InternshipEvaluationWhereInput | InternshipEvaluationWhereInput[]
    OR?: InternshipEvaluationWhereInput[]
    NOT?: InternshipEvaluationWhereInput | InternshipEvaluationWhereInput[]
    internshipId?: StringFilter<"InternshipEvaluation"> | string
    evaluatorId?: StringFilter<"InternshipEvaluation"> | string
    facultyId?: StringFilter<"InternshipEvaluation"> | string
    rubricJson?: StringFilter<"InternshipEvaluation"> | string
    comments?: StringNullableFilter<"InternshipEvaluation"> | string | null
    finalScore?: FloatFilter<"InternshipEvaluation"> | number
    createdAt?: DateTimeFilter<"InternshipEvaluation"> | Date | string
    internship?: XOR<InternshipRelationFilter, InternshipWhereInput>
    evaluator?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type InternshipEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    internshipId?: SortOrder
    evaluatorId?: SortOrder
    facultyId?: SortOrder
    rubricJson?: SortOrder
    comments?: SortOrderInput | SortOrder
    finalScore?: SortOrder
    createdAt?: SortOrder
    _count?: InternshipEvaluationCountOrderByAggregateInput
    _avg?: InternshipEvaluationAvgOrderByAggregateInput
    _max?: InternshipEvaluationMaxOrderByAggregateInput
    _min?: InternshipEvaluationMinOrderByAggregateInput
    _sum?: InternshipEvaluationSumOrderByAggregateInput
  }

  export type InternshipEvaluationScalarWhereWithAggregatesInput = {
    AND?: InternshipEvaluationScalarWhereWithAggregatesInput | InternshipEvaluationScalarWhereWithAggregatesInput[]
    OR?: InternshipEvaluationScalarWhereWithAggregatesInput[]
    NOT?: InternshipEvaluationScalarWhereWithAggregatesInput | InternshipEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InternshipEvaluation"> | string
    internshipId?: StringWithAggregatesFilter<"InternshipEvaluation"> | string
    evaluatorId?: StringWithAggregatesFilter<"InternshipEvaluation"> | string
    facultyId?: StringWithAggregatesFilter<"InternshipEvaluation"> | string
    rubricJson?: StringWithAggregatesFilter<"InternshipEvaluation"> | string
    comments?: StringNullableWithAggregatesFilter<"InternshipEvaluation"> | string | null
    finalScore?: FloatWithAggregatesFilter<"InternshipEvaluation"> | number
    createdAt?: DateTimeWithAggregatesFilter<"InternshipEvaluation"> | Date | string
  }

  export type CourseWhereInput = {
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    id?: StringFilter<"Course"> | string
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    type?: StringFilter<"Course"> | string
    price?: FloatNullableFilter<"Course"> | number | null
    thumbnail?: StringNullableFilter<"Course"> | string | null
    instructorId?: StringFilter<"Course"> | string
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    enrollments?: CourseEnrollmentListRelationFilter
    checkpoints?: CheckpointListRelationFilter
  }

  export type CourseOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    enrollments?: CourseEnrollmentOrderByRelationAggregateInput
    checkpoints?: CheckpointOrderByRelationAggregateInput
  }

  export type CourseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CourseWhereInput | CourseWhereInput[]
    OR?: CourseWhereInput[]
    NOT?: CourseWhereInput | CourseWhereInput[]
    title?: StringFilter<"Course"> | string
    description?: StringFilter<"Course"> | string
    type?: StringFilter<"Course"> | string
    price?: FloatNullableFilter<"Course"> | number | null
    thumbnail?: StringNullableFilter<"Course"> | string | null
    instructorId?: StringFilter<"Course"> | string
    thumbnailUrl?: StringNullableFilter<"Course"> | string | null
    createdAt?: DateTimeFilter<"Course"> | Date | string
    enrollments?: CourseEnrollmentListRelationFilter
    checkpoints?: CheckpointListRelationFilter
  }, "id">

  export type CourseOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    instructorId?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CourseCountOrderByAggregateInput
    _avg?: CourseAvgOrderByAggregateInput
    _max?: CourseMaxOrderByAggregateInput
    _min?: CourseMinOrderByAggregateInput
    _sum?: CourseSumOrderByAggregateInput
  }

  export type CourseScalarWhereWithAggregatesInput = {
    AND?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    OR?: CourseScalarWhereWithAggregatesInput[]
    NOT?: CourseScalarWhereWithAggregatesInput | CourseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Course"> | string
    title?: StringWithAggregatesFilter<"Course"> | string
    description?: StringWithAggregatesFilter<"Course"> | string
    type?: StringWithAggregatesFilter<"Course"> | string
    price?: FloatNullableWithAggregatesFilter<"Course"> | number | null
    thumbnail?: StringNullableWithAggregatesFilter<"Course"> | string | null
    instructorId?: StringWithAggregatesFilter<"Course"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Course"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Course"> | Date | string
  }

  export type CourseEnrollmentWhereInput = {
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    studentId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    progressPercent?: IntFilter<"CourseEnrollment"> | number
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CourseEnrollmentOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    progressPercent?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
    course?: CourseOrderByWithRelationInput
  }

  export type CourseEnrollmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_courseId?: CourseEnrollmentStudentIdCourseIdCompoundUniqueInput
    AND?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    OR?: CourseEnrollmentWhereInput[]
    NOT?: CourseEnrollmentWhereInput | CourseEnrollmentWhereInput[]
    studentId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    progressPercent?: IntFilter<"CourseEnrollment"> | number
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id" | "studentId_courseId">

  export type CourseEnrollmentOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    progressPercent?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    _count?: CourseEnrollmentCountOrderByAggregateInput
    _avg?: CourseEnrollmentAvgOrderByAggregateInput
    _max?: CourseEnrollmentMaxOrderByAggregateInput
    _min?: CourseEnrollmentMinOrderByAggregateInput
    _sum?: CourseEnrollmentSumOrderByAggregateInput
  }

  export type CourseEnrollmentScalarWhereWithAggregatesInput = {
    AND?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    OR?: CourseEnrollmentScalarWhereWithAggregatesInput[]
    NOT?: CourseEnrollmentScalarWhereWithAggregatesInput | CourseEnrollmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    studentId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    courseId?: StringWithAggregatesFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeWithAggregatesFilter<"CourseEnrollment"> | Date | string
    progressPercent?: IntWithAggregatesFilter<"CourseEnrollment"> | number
    completedAt?: DateTimeNullableWithAggregatesFilter<"CourseEnrollment"> | Date | string | null
  }

  export type CheckpointWhereInput = {
    AND?: CheckpointWhereInput | CheckpointWhereInput[]
    OR?: CheckpointWhereInput[]
    NOT?: CheckpointWhereInput | CheckpointWhereInput[]
    id?: StringFilter<"Checkpoint"> | string
    courseId?: StringFilter<"Checkpoint"> | string
    title?: StringFilter<"Checkpoint"> | string
    description?: StringNullableFilter<"Checkpoint"> | string | null
    resourceUrl?: StringNullableFilter<"Checkpoint"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }

  export type CheckpointOrderByWithRelationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resourceUrl?: SortOrderInput | SortOrder
    course?: CourseOrderByWithRelationInput
  }

  export type CheckpointWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CheckpointWhereInput | CheckpointWhereInput[]
    OR?: CheckpointWhereInput[]
    NOT?: CheckpointWhereInput | CheckpointWhereInput[]
    courseId?: StringFilter<"Checkpoint"> | string
    title?: StringFilter<"Checkpoint"> | string
    description?: StringNullableFilter<"Checkpoint"> | string | null
    resourceUrl?: StringNullableFilter<"Checkpoint"> | string | null
    course?: XOR<CourseRelationFilter, CourseWhereInput>
  }, "id">

  export type CheckpointOrderByWithAggregationInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resourceUrl?: SortOrderInput | SortOrder
    _count?: CheckpointCountOrderByAggregateInput
    _max?: CheckpointMaxOrderByAggregateInput
    _min?: CheckpointMinOrderByAggregateInput
  }

  export type CheckpointScalarWhereWithAggregatesInput = {
    AND?: CheckpointScalarWhereWithAggregatesInput | CheckpointScalarWhereWithAggregatesInput[]
    OR?: CheckpointScalarWhereWithAggregatesInput[]
    NOT?: CheckpointScalarWhereWithAggregatesInput | CheckpointScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Checkpoint"> | string
    courseId?: StringWithAggregatesFilter<"Checkpoint"> | string
    title?: StringWithAggregatesFilter<"Checkpoint"> | string
    description?: StringNullableWithAggregatesFilter<"Checkpoint"> | string | null
    resourceUrl?: StringNullableWithAggregatesFilter<"Checkpoint"> | string | null
  }

  export type PortfolioProjectWhereInput = {
    AND?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    OR?: PortfolioProjectWhereInput[]
    NOT?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    id?: StringFilter<"PortfolioProject"> | string
    studentId?: StringFilter<"PortfolioProject"> | string
    title?: StringFilter<"PortfolioProject"> | string
    description?: StringFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    liveUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    tags?: StringNullableFilter<"PortfolioProject"> | string | null
    createdAt?: DateTimeFilter<"PortfolioProject"> | Date | string
    source?: StringFilter<"PortfolioProject"> | string
    githubRepoId?: StringNullableFilter<"PortfolioProject"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"PortfolioProject"> | Date | string | null
    stars?: IntFilter<"PortfolioProject"> | number
    forks?: IntFilter<"PortfolioProject"> | number
    language?: StringNullableFilter<"PortfolioProject"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type PortfolioProjectOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    githubRepoId?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    stars?: SortOrder
    forks?: SortOrder
    language?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type PortfolioProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    OR?: PortfolioProjectWhereInput[]
    NOT?: PortfolioProjectWhereInput | PortfolioProjectWhereInput[]
    studentId?: StringFilter<"PortfolioProject"> | string
    title?: StringFilter<"PortfolioProject"> | string
    description?: StringFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    liveUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    tags?: StringNullableFilter<"PortfolioProject"> | string | null
    createdAt?: DateTimeFilter<"PortfolioProject"> | Date | string
    source?: StringFilter<"PortfolioProject"> | string
    githubRepoId?: StringNullableFilter<"PortfolioProject"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"PortfolioProject"> | Date | string | null
    stars?: IntFilter<"PortfolioProject"> | number
    forks?: IntFilter<"PortfolioProject"> | number
    language?: StringNullableFilter<"PortfolioProject"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type PortfolioProjectOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    githubUrl?: SortOrderInput | SortOrder
    liveUrl?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    githubRepoId?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    stars?: SortOrder
    forks?: SortOrder
    language?: SortOrderInput | SortOrder
    _count?: PortfolioProjectCountOrderByAggregateInput
    _avg?: PortfolioProjectAvgOrderByAggregateInput
    _max?: PortfolioProjectMaxOrderByAggregateInput
    _min?: PortfolioProjectMinOrderByAggregateInput
    _sum?: PortfolioProjectSumOrderByAggregateInput
  }

  export type PortfolioProjectScalarWhereWithAggregatesInput = {
    AND?: PortfolioProjectScalarWhereWithAggregatesInput | PortfolioProjectScalarWhereWithAggregatesInput[]
    OR?: PortfolioProjectScalarWhereWithAggregatesInput[]
    NOT?: PortfolioProjectScalarWhereWithAggregatesInput | PortfolioProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PortfolioProject"> | string
    studentId?: StringWithAggregatesFilter<"PortfolioProject"> | string
    title?: StringWithAggregatesFilter<"PortfolioProject"> | string
    description?: StringWithAggregatesFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
    liveUrl?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
    tags?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PortfolioProject"> | Date | string
    source?: StringWithAggregatesFilter<"PortfolioProject"> | string
    githubRepoId?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"PortfolioProject"> | Date | string | null
    stars?: IntWithAggregatesFilter<"PortfolioProject"> | number
    forks?: IntWithAggregatesFilter<"PortfolioProject"> | number
    language?: StringNullableWithAggregatesFilter<"PortfolioProject"> | string | null
  }

  export type MentorSessionWhereInput = {
    AND?: MentorSessionWhereInput | MentorSessionWhereInput[]
    OR?: MentorSessionWhereInput[]
    NOT?: MentorSessionWhereInput | MentorSessionWhereInput[]
    id?: StringFilter<"MentorSession"> | string
    studentId?: StringFilter<"MentorSession"> | string
    mentorId?: StringFilter<"MentorSession"> | string
    scheduledAt?: DateTimeFilter<"MentorSession"> | Date | string
    status?: StringFilter<"MentorSession"> | string
    meetingLink?: StringNullableFilter<"MentorSession"> | string | null
    createdAt?: DateTimeFilter<"MentorSession"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    mentor?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: MentorReviewListRelationFilter
  }

  export type MentorSessionOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    mentor?: UserOrderByWithRelationInput
    reviews?: MentorReviewOrderByRelationAggregateInput
  }

  export type MentorSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MentorSessionWhereInput | MentorSessionWhereInput[]
    OR?: MentorSessionWhereInput[]
    NOT?: MentorSessionWhereInput | MentorSessionWhereInput[]
    studentId?: StringFilter<"MentorSession"> | string
    mentorId?: StringFilter<"MentorSession"> | string
    scheduledAt?: DateTimeFilter<"MentorSession"> | Date | string
    status?: StringFilter<"MentorSession"> | string
    meetingLink?: StringNullableFilter<"MentorSession"> | string | null
    createdAt?: DateTimeFilter<"MentorSession"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    mentor?: XOR<UserRelationFilter, UserWhereInput>
    reviews?: MentorReviewListRelationFilter
  }, "id">

  export type MentorSessionOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MentorSessionCountOrderByAggregateInput
    _max?: MentorSessionMaxOrderByAggregateInput
    _min?: MentorSessionMinOrderByAggregateInput
  }

  export type MentorSessionScalarWhereWithAggregatesInput = {
    AND?: MentorSessionScalarWhereWithAggregatesInput | MentorSessionScalarWhereWithAggregatesInput[]
    OR?: MentorSessionScalarWhereWithAggregatesInput[]
    NOT?: MentorSessionScalarWhereWithAggregatesInput | MentorSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MentorSession"> | string
    studentId?: StringWithAggregatesFilter<"MentorSession"> | string
    mentorId?: StringWithAggregatesFilter<"MentorSession"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"MentorSession"> | Date | string
    status?: StringWithAggregatesFilter<"MentorSession"> | string
    meetingLink?: StringNullableWithAggregatesFilter<"MentorSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MentorSession"> | Date | string
  }

  export type MentorReviewWhereInput = {
    AND?: MentorReviewWhereInput | MentorReviewWhereInput[]
    OR?: MentorReviewWhereInput[]
    NOT?: MentorReviewWhereInput | MentorReviewWhereInput[]
    id?: StringFilter<"MentorReview"> | string
    sessionId?: StringFilter<"MentorReview"> | string
    studentId?: StringFilter<"MentorReview"> | string
    rating?: FloatFilter<"MentorReview"> | number
    review?: StringNullableFilter<"MentorReview"> | string | null
    session?: XOR<MentorSessionRelationFilter, MentorSessionWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type MentorReviewOrderByWithRelationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    session?: MentorSessionOrderByWithRelationInput
    student?: StudentOrderByWithRelationInput
  }

  export type MentorReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MentorReviewWhereInput | MentorReviewWhereInput[]
    OR?: MentorReviewWhereInput[]
    NOT?: MentorReviewWhereInput | MentorReviewWhereInput[]
    sessionId?: StringFilter<"MentorReview"> | string
    studentId?: StringFilter<"MentorReview"> | string
    rating?: FloatFilter<"MentorReview"> | number
    review?: StringNullableFilter<"MentorReview"> | string | null
    session?: XOR<MentorSessionRelationFilter, MentorSessionWhereInput>
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type MentorReviewOrderByWithAggregationInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    _count?: MentorReviewCountOrderByAggregateInput
    _avg?: MentorReviewAvgOrderByAggregateInput
    _max?: MentorReviewMaxOrderByAggregateInput
    _min?: MentorReviewMinOrderByAggregateInput
    _sum?: MentorReviewSumOrderByAggregateInput
  }

  export type MentorReviewScalarWhereWithAggregatesInput = {
    AND?: MentorReviewScalarWhereWithAggregatesInput | MentorReviewScalarWhereWithAggregatesInput[]
    OR?: MentorReviewScalarWhereWithAggregatesInput[]
    NOT?: MentorReviewScalarWhereWithAggregatesInput | MentorReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MentorReview"> | string
    sessionId?: StringWithAggregatesFilter<"MentorReview"> | string
    studentId?: StringWithAggregatesFilter<"MentorReview"> | string
    rating?: FloatWithAggregatesFilter<"MentorReview"> | number
    review?: StringNullableWithAggregatesFilter<"MentorReview"> | string | null
  }

  export type LogbookEntryWhereInput = {
    AND?: LogbookEntryWhereInput | LogbookEntryWhereInput[]
    OR?: LogbookEntryWhereInput[]
    NOT?: LogbookEntryWhereInput | LogbookEntryWhereInput[]
    id?: StringFilter<"LogbookEntry"> | string
    studentId?: StringFilter<"LogbookEntry"> | string
    date?: DateTimeFilter<"LogbookEntry"> | Date | string
    task?: StringFilter<"LogbookEntry"> | string
    hours?: IntFilter<"LogbookEntry"> | number
    description?: StringFilter<"LogbookEntry"> | string
    proofUrl?: StringNullableFilter<"LogbookEntry"> | string | null
    createdAt?: DateTimeFilter<"LogbookEntry"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type LogbookEntryOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    task?: SortOrder
    hours?: SortOrder
    description?: SortOrder
    proofUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type LogbookEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LogbookEntryWhereInput | LogbookEntryWhereInput[]
    OR?: LogbookEntryWhereInput[]
    NOT?: LogbookEntryWhereInput | LogbookEntryWhereInput[]
    studentId?: StringFilter<"LogbookEntry"> | string
    date?: DateTimeFilter<"LogbookEntry"> | Date | string
    task?: StringFilter<"LogbookEntry"> | string
    hours?: IntFilter<"LogbookEntry"> | number
    description?: StringFilter<"LogbookEntry"> | string
    proofUrl?: StringNullableFilter<"LogbookEntry"> | string | null
    createdAt?: DateTimeFilter<"LogbookEntry"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type LogbookEntryOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    task?: SortOrder
    hours?: SortOrder
    description?: SortOrder
    proofUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LogbookEntryCountOrderByAggregateInput
    _avg?: LogbookEntryAvgOrderByAggregateInput
    _max?: LogbookEntryMaxOrderByAggregateInput
    _min?: LogbookEntryMinOrderByAggregateInput
    _sum?: LogbookEntrySumOrderByAggregateInput
  }

  export type LogbookEntryScalarWhereWithAggregatesInput = {
    AND?: LogbookEntryScalarWhereWithAggregatesInput | LogbookEntryScalarWhereWithAggregatesInput[]
    OR?: LogbookEntryScalarWhereWithAggregatesInput[]
    NOT?: LogbookEntryScalarWhereWithAggregatesInput | LogbookEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LogbookEntry"> | string
    studentId?: StringWithAggregatesFilter<"LogbookEntry"> | string
    date?: DateTimeWithAggregatesFilter<"LogbookEntry"> | Date | string
    task?: StringWithAggregatesFilter<"LogbookEntry"> | string
    hours?: IntWithAggregatesFilter<"LogbookEntry"> | number
    description?: StringWithAggregatesFilter<"LogbookEntry"> | string
    proofUrl?: StringNullableWithAggregatesFilter<"LogbookEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LogbookEntry"> | Date | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    studentId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuedAt?: SortOrder
    certificateUrl?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    studentId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuedAt?: SortOrder
    certificateUrl?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    studentId?: StringWithAggregatesFilter<"Certificate"> | string
    title?: StringWithAggregatesFilter<"Certificate"> | string
    issuedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
    certificateUrl?: StringWithAggregatesFilter<"Certificate"> | string
  }

  export type StudentLearningProgressWhereInput = {
    AND?: StudentLearningProgressWhereInput | StudentLearningProgressWhereInput[]
    OR?: StudentLearningProgressWhereInput[]
    NOT?: StudentLearningProgressWhereInput | StudentLearningProgressWhereInput[]
    id?: StringFilter<"StudentLearningProgress"> | string
    studentId?: StringFilter<"StudentLearningProgress"> | string
    profileId?: StringFilter<"StudentLearningProgress"> | string
    isCompleted?: BoolFilter<"StudentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"StudentLearningProgress"> | Date | string | null
    checkpointId?: StringFilter<"StudentLearningProgress"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type StudentLearningProgressOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    profileId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    checkpointId?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type StudentLearningProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StudentLearningProgressWhereInput | StudentLearningProgressWhereInput[]
    OR?: StudentLearningProgressWhereInput[]
    NOT?: StudentLearningProgressWhereInput | StudentLearningProgressWhereInput[]
    studentId?: StringFilter<"StudentLearningProgress"> | string
    profileId?: StringFilter<"StudentLearningProgress"> | string
    isCompleted?: BoolFilter<"StudentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"StudentLearningProgress"> | Date | string | null
    checkpointId?: StringFilter<"StudentLearningProgress"> | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type StudentLearningProgressOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    profileId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    checkpointId?: SortOrder
    _count?: StudentLearningProgressCountOrderByAggregateInput
    _max?: StudentLearningProgressMaxOrderByAggregateInput
    _min?: StudentLearningProgressMinOrderByAggregateInput
  }

  export type StudentLearningProgressScalarWhereWithAggregatesInput = {
    AND?: StudentLearningProgressScalarWhereWithAggregatesInput | StudentLearningProgressScalarWhereWithAggregatesInput[]
    OR?: StudentLearningProgressScalarWhereWithAggregatesInput[]
    NOT?: StudentLearningProgressScalarWhereWithAggregatesInput | StudentLearningProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentLearningProgress"> | string
    studentId?: StringWithAggregatesFilter<"StudentLearningProgress"> | string
    profileId?: StringWithAggregatesFilter<"StudentLearningProgress"> | string
    isCompleted?: BoolWithAggregatesFilter<"StudentLearningProgress"> | boolean
    completedAt?: DateTimeNullableWithAggregatesFilter<"StudentLearningProgress"> | Date | string | null
    checkpointId?: StringWithAggregatesFilter<"StudentLearningProgress"> | string
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    title?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    domain?: StringFilter<"Roadmap"> | string
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrder
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    title?: StringFilter<"Roadmap"> | string
    description?: StringNullableFilter<"Roadmap"> | string | null
    domain?: StringFilter<"Roadmap"> | string
  }, "id">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    domain?: SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    title?: StringWithAggregatesFilter<"Roadmap"> | string
    description?: StringNullableWithAggregatesFilter<"Roadmap"> | string | null
    domain?: StringWithAggregatesFilter<"Roadmap"> | string
  }

  export type CertificationWhereInput = {
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    id?: StringFilter<"Certification"> | string
    studentId?: StringFilter<"Certification"> | string
    title?: StringFilter<"Certification"> | string
    issuer?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    credentialUrl?: StringNullableFilter<"Certification"> | string | null
    source?: StringFilter<"Certification"> | string
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    verified?: BoolFilter<"Certification"> | boolean
    metadata?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CertificationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuer?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    credentialUrl?: SortOrderInput | SortOrder
    source?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type CertificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CertificationWhereInput | CertificationWhereInput[]
    OR?: CertificationWhereInput[]
    NOT?: CertificationWhereInput | CertificationWhereInput[]
    studentId?: StringFilter<"Certification"> | string
    title?: StringFilter<"Certification"> | string
    issuer?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    credentialUrl?: StringNullableFilter<"Certification"> | string | null
    source?: StringFilter<"Certification"> | string
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    verified?: BoolFilter<"Certification"> | boolean
    metadata?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type CertificationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuer?: SortOrderInput | SortOrder
    issueDate?: SortOrderInput | SortOrder
    expiryDate?: SortOrderInput | SortOrder
    credentialId?: SortOrderInput | SortOrder
    credentialUrl?: SortOrderInput | SortOrder
    source?: SortOrder
    documentUrl?: SortOrderInput | SortOrder
    verified?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CertificationCountOrderByAggregateInput
    _max?: CertificationMaxOrderByAggregateInput
    _min?: CertificationMinOrderByAggregateInput
  }

  export type CertificationScalarWhereWithAggregatesInput = {
    AND?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    OR?: CertificationScalarWhereWithAggregatesInput[]
    NOT?: CertificationScalarWhereWithAggregatesInput | CertificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certification"> | string
    studentId?: StringWithAggregatesFilter<"Certification"> | string
    title?: StringWithAggregatesFilter<"Certification"> | string
    issuer?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    expiryDate?: DateTimeNullableWithAggregatesFilter<"Certification"> | Date | string | null
    credentialId?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    credentialUrl?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    source?: StringWithAggregatesFilter<"Certification"> | string
    documentUrl?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    verified?: BoolWithAggregatesFilter<"Certification"> | boolean
    metadata?: StringNullableWithAggregatesFilter<"Certification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Certification"> | Date | string
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: StringFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    category?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    studentSkills?: StudentSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    studentSkills?: StudentSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    category?: StringNullableFilter<"Skill"> | string | null
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    studentSkills?: StudentSkillListRelationFilter
  }, "id" | "name">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    category?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
  }

  export type StudentSkillWhereInput = {
    AND?: StudentSkillWhereInput | StudentSkillWhereInput[]
    OR?: StudentSkillWhereInput[]
    NOT?: StudentSkillWhereInput | StudentSkillWhereInput[]
    id?: StringFilter<"StudentSkill"> | string
    studentId?: StringFilter<"StudentSkill"> | string
    skillId?: StringFilter<"StudentSkill"> | string
    proficiencyLevel?: IntFilter<"StudentSkill"> | number
    yearsExperience?: FloatNullableFilter<"StudentSkill"> | number | null
    source?: StringFilter<"StudentSkill"> | string
    createdAt?: DateTimeFilter<"StudentSkill"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }

  export type StudentSkillOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    student?: StudentOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type StudentSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    studentId_skillId?: StudentSkillStudentIdSkillIdCompoundUniqueInput
    AND?: StudentSkillWhereInput | StudentSkillWhereInput[]
    OR?: StudentSkillWhereInput[]
    NOT?: StudentSkillWhereInput | StudentSkillWhereInput[]
    studentId?: StringFilter<"StudentSkill"> | string
    skillId?: StringFilter<"StudentSkill"> | string
    proficiencyLevel?: IntFilter<"StudentSkill"> | number
    yearsExperience?: FloatNullableFilter<"StudentSkill"> | number | null
    source?: StringFilter<"StudentSkill"> | string
    createdAt?: DateTimeFilter<"StudentSkill"> | Date | string
    student?: XOR<StudentRelationFilter, StudentWhereInput>
    skill?: XOR<SkillRelationFilter, SkillWhereInput>
  }, "id" | "studentId_skillId">

  export type StudentSkillOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    _count?: StudentSkillCountOrderByAggregateInput
    _avg?: StudentSkillAvgOrderByAggregateInput
    _max?: StudentSkillMaxOrderByAggregateInput
    _min?: StudentSkillMinOrderByAggregateInput
    _sum?: StudentSkillSumOrderByAggregateInput
  }

  export type StudentSkillScalarWhereWithAggregatesInput = {
    AND?: StudentSkillScalarWhereWithAggregatesInput | StudentSkillScalarWhereWithAggregatesInput[]
    OR?: StudentSkillScalarWhereWithAggregatesInput[]
    NOT?: StudentSkillScalarWhereWithAggregatesInput | StudentSkillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentSkill"> | string
    studentId?: StringWithAggregatesFilter<"StudentSkill"> | string
    skillId?: StringWithAggregatesFilter<"StudentSkill"> | string
    proficiencyLevel?: IntWithAggregatesFilter<"StudentSkill"> | number
    yearsExperience?: FloatNullableWithAggregatesFilter<"StudentSkill"> | number | null
    source?: StringWithAggregatesFilter<"StudentSkill"> | string
    createdAt?: DateTimeWithAggregatesFilter<"StudentSkill"> | Date | string
  }

  export type CVGenerationWhereInput = {
    AND?: CVGenerationWhereInput | CVGenerationWhereInput[]
    OR?: CVGenerationWhereInput[]
    NOT?: CVGenerationWhereInput | CVGenerationWhereInput[]
    id?: StringFilter<"CVGeneration"> | string
    studentId?: StringFilter<"CVGeneration"> | string
    templateName?: StringFilter<"CVGeneration"> | string
    fileUrl?: StringFilter<"CVGeneration"> | string
    format?: StringFilter<"CVGeneration"> | string
    generatedAt?: DateTimeFilter<"CVGeneration"> | Date | string
    metadata?: StringNullableFilter<"CVGeneration"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }

  export type CVGenerationOrderByWithRelationInput = {
    id?: SortOrder
    studentId?: SortOrder
    templateName?: SortOrder
    fileUrl?: SortOrder
    format?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    student?: StudentOrderByWithRelationInput
  }

  export type CVGenerationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CVGenerationWhereInput | CVGenerationWhereInput[]
    OR?: CVGenerationWhereInput[]
    NOT?: CVGenerationWhereInput | CVGenerationWhereInput[]
    studentId?: StringFilter<"CVGeneration"> | string
    templateName?: StringFilter<"CVGeneration"> | string
    fileUrl?: StringFilter<"CVGeneration"> | string
    format?: StringFilter<"CVGeneration"> | string
    generatedAt?: DateTimeFilter<"CVGeneration"> | Date | string
    metadata?: StringNullableFilter<"CVGeneration"> | string | null
    student?: XOR<StudentRelationFilter, StudentWhereInput>
  }, "id">

  export type CVGenerationOrderByWithAggregationInput = {
    id?: SortOrder
    studentId?: SortOrder
    templateName?: SortOrder
    fileUrl?: SortOrder
    format?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: CVGenerationCountOrderByAggregateInput
    _max?: CVGenerationMaxOrderByAggregateInput
    _min?: CVGenerationMinOrderByAggregateInput
  }

  export type CVGenerationScalarWhereWithAggregatesInput = {
    AND?: CVGenerationScalarWhereWithAggregatesInput | CVGenerationScalarWhereWithAggregatesInput[]
    OR?: CVGenerationScalarWhereWithAggregatesInput[]
    NOT?: CVGenerationScalarWhereWithAggregatesInput | CVGenerationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CVGeneration"> | string
    studentId?: StringWithAggregatesFilter<"CVGeneration"> | string
    templateName?: StringWithAggregatesFilter<"CVGeneration"> | string
    fileUrl?: StringWithAggregatesFilter<"CVGeneration"> | string
    format?: StringWithAggregatesFilter<"CVGeneration"> | string
    generatedAt?: DateTimeWithAggregatesFilter<"CVGeneration"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"CVGeneration"> | string | null
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    fileSize?: BigIntNullableFilter<"Document"> | bigint | number | null
    category?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: StringNullableFilter<"Document"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    fileSize?: BigIntNullableFilter<"Document"> | bigint | number | null
    category?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: StringNullableFilter<"Document"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    userId?: StringWithAggregatesFilter<"Document"> | string
    filename?: StringWithAggregatesFilter<"Document"> | string
    originalFilename?: StringWithAggregatesFilter<"Document"> | string
    fileUrl?: StringWithAggregatesFilter<"Document"> | string
    fileType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileSize?: BigIntNullableWithAggregatesFilter<"Document"> | bigint | number | null
    category?: StringNullableWithAggregatesFilter<"Document"> | string | null
    uploadedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    metadata?: StringNullableWithAggregatesFilter<"Document"> | string | null
  }

  export type UserCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkspaceCreateInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    folder?: FolderCreateNestedOneWithoutWorkspacesInput
    team?: TeamCreateNestedOneWithoutWorkspacesInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    invites?: InviteCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
    userId: string
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    invites?: InviteUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    folder?: FolderUpdateOneWithoutWorkspacesNestedInput
    team?: TeamUpdateOneWithoutWorkspacesNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceCreateManyInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
    userId: string
  }

  export type WorkspaceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkspaceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    workspaces?: WorkspaceCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    name: string
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    name: string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamCreateInput = {
    id?: string
    name: string
    workspaces?: WorkspaceCreateNestedManyWithoutTeamInput
    users?: UserCreateNestedManyWithoutTeamsInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    name: string
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutTeamInput
    users?: UserUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUpdateManyWithoutTeamNestedInput
    users?: UserUpdateManyWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUncheckedUpdateManyWithoutTeamNestedInput
    users?: UserUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    name: string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type InviteCreateInput = {
    id?: string
    inviteId: string
    type: string
    workspace: WorkspaceCreateNestedOneWithoutInvitesInput
    inviter: UserCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateInput = {
    id?: string
    inviteId: string
    workspaceId: string
    type: string
    inviterId: string
  }

  export type InviteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitesNestedInput
    inviter?: UserUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InviteCreateManyInput = {
    id?: string
    inviteId: string
    workspaceId: string
    type: string
    inviterId: string
  }

  export type InviteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InviteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutChatsInput
    user: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspaceId: string
    userId: string
  }

  export type ChatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutChatsNestedInput
    user?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatCreateManyInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspaceId: string
    userId: string
  }

  export type ChatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentCreateInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateManyInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    avatarUrl?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: string | null
    interests?: string | null
    resumeUrl?: string | null
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    studentId: string
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    avatarUrl?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: string | null
    interests?: string | null
    resumeUrl?: string | null
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    studentId: string
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    avatarUrl?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: string | null
    interests?: string | null
    resumeUrl?: string | null
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipCreateInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: InternshipApplicationCreateNestedManyWithoutInternshipInput
    evaluations?: InternshipEvaluationCreateNestedManyWithoutInternshipInput
  }

  export type InternshipUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutInternshipInput
    evaluations?: InternshipEvaluationUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type InternshipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: InternshipApplicationUpdateManyWithoutInternshipNestedInput
    evaluations?: InternshipEvaluationUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: InternshipApplicationUncheckedUpdateManyWithoutInternshipNestedInput
    evaluations?: InternshipEvaluationUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipCreateManyInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InternshipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipApplicationCreateInput = {
    id?: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    student: StudentCreateNestedOneWithoutApplicationsInput
    internship: InternshipCreateNestedOneWithoutApplicationsInput
  }

  export type InternshipApplicationUncheckedCreateInput = {
    id?: string
    studentId: string
    internshipId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type InternshipApplicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutApplicationsNestedInput
    internship?: InternshipUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type InternshipApplicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationCreateManyInput = {
    id?: string
    studentId: string
    internshipId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type InternshipApplicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipEvaluationCreateInput = {
    id?: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
    internship: InternshipCreateNestedOneWithoutEvaluationsInput
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
  }

  export type InternshipEvaluationUncheckedCreateInput = {
    id?: string
    internshipId: string
    evaluatorId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type InternshipEvaluationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
  }

  export type InternshipEvaluationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipEvaluationCreateManyInput = {
    id?: string
    internshipId: string
    evaluatorId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type InternshipEvaluationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipEvaluationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
    checkpoints?: CheckpointCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
    checkpoints?: CheckpointUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
    checkpoints?: CheckpointUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
    checkpoints?: CheckpointUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateManyInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
  }

  export type CourseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentCreateInput = {
    id?: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
    student: StudentCreateNestedOneWithoutEnrollmentsInput
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateInput = {
    id?: string
    studentId: string
    courseId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type CourseEnrollmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseEnrollmentCreateManyInput = {
    id?: string
    studentId: string
    courseId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type CourseEnrollmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckpointCreateInput = {
    id?: string
    title: string
    description?: string | null
    resourceUrl?: string | null
    course: CourseCreateNestedOneWithoutCheckpointsInput
  }

  export type CheckpointUncheckedCreateInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    resourceUrl?: string | null
  }

  export type CheckpointUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    course?: CourseUpdateOneRequiredWithoutCheckpointsNestedInput
  }

  export type CheckpointUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckpointCreateManyInput = {
    id?: string
    courseId: string
    title: string
    description?: string | null
    resourceUrl?: string | null
  }

  export type CheckpointUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckpointUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioProjectCreateInput = {
    id?: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
    student: StudentCreateNestedOneWithoutProjectsInput
  }

  export type PortfolioProjectUncheckedCreateInput = {
    id?: string
    studentId: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
  }

  export type PortfolioProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type PortfolioProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioProjectCreateManyInput = {
    id?: string
    studentId: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
  }

  export type PortfolioProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorSessionCreateInput = {
    id?: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutMentorSessionsInput
    mentor: UserCreateNestedOneWithoutMentorSessionsInput
    reviews?: MentorReviewCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionUncheckedCreateInput = {
    id?: string
    studentId: string
    mentorId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMentorSessionsNestedInput
    mentor?: UserUpdateOneRequiredWithoutMentorSessionsNestedInput
    reviews?: MentorReviewUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: MentorReviewUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionCreateManyInput = {
    id?: string
    studentId: string
    mentorId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
  }

  export type MentorSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorReviewCreateInput = {
    id?: string
    rating: number
    review?: string | null
    session: MentorSessionCreateNestedOneWithoutReviewsInput
    student: StudentCreateNestedOneWithoutReviewsInput
  }

  export type MentorReviewUncheckedCreateInput = {
    id?: string
    sessionId: string
    studentId: string
    rating: number
    review?: string | null
  }

  export type MentorReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    session?: MentorSessionUpdateOneRequiredWithoutReviewsNestedInput
    student?: StudentUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type MentorReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorReviewCreateManyInput = {
    id?: string
    sessionId: string
    studentId: string
    rating: number
    review?: string | null
  }

  export type MentorReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogbookEntryCreateInput = {
    id?: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutLogbookEntriesInput
  }

  export type LogbookEntryUncheckedCreateInput = {
    id?: string
    studentId: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
  }

  export type LogbookEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutLogbookEntriesNestedInput
  }

  export type LogbookEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogbookEntryCreateManyInput = {
    id?: string
    studentId: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
  }

  export type LogbookEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogbookEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateInput = {
    id?: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
    student: StudentCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    studentId: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    studentId: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressCreateInput = {
    id?: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
    student: StudentCreateNestedOneWithoutLearningProgressInput
  }

  export type StudentLearningProgressUncheckedCreateInput = {
    id?: string
    studentId: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
  }

  export type StudentLearningProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
    student?: StudentUpdateOneRequiredWithoutLearningProgressNestedInput
  }

  export type StudentLearningProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressCreateManyInput = {
    id?: string
    studentId: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
  }

  export type StudentLearningProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapCreateInput = {
    id?: string
    title: string
    description?: string | null
    domain: string
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    domain: string
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    domain: string
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    domain?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationCreateInput = {
    id?: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentCreateNestedOneWithoutCertificationsInput
  }

  export type CertificationUncheckedCreateInput = {
    id?: string
    studentId: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutCertificationsNestedInput
  }

  export type CertificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationCreateManyInput = {
    id?: string
    studentId: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    category?: string | null
    createdAt?: Date | string
    studentSkills?: StudentSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    category?: string | null
    createdAt?: Date | string
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSkills?: StudentSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    category?: string | null
    createdAt?: Date | string
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillCreateInput = {
    id?: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSkillsInput
    skill: SkillCreateNestedOneWithoutStudentSkillsInput
  }

  export type StudentSkillUncheckedCreateInput = {
    id?: string
    studentId: string
    skillId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type StudentSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutStudentSkillsNestedInput
  }

  export type StudentSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillCreateManyInput = {
    id?: string
    studentId: string
    skillId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type StudentSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CVGenerationCreateInput = {
    id?: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
    student: StudentCreateNestedOneWithoutCvGenerationsInput
  }

  export type CVGenerationUncheckedCreateInput = {
    id?: string
    studentId: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
  }

  export type CVGenerationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutCvGenerationsNestedInput
  }

  export type CVGenerationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CVGenerationCreateManyInput = {
    id?: string
    studentId: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
  }

  export type CVGenerationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CVGenerationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateInput = {
    id?: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
    user: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    userId: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentCreateManyInput = {
    id?: string
    userId: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type WorkspaceListRelationFilter = {
    every?: WorkspaceWhereInput
    some?: WorkspaceWhereInput
    none?: WorkspaceWhereInput
  }

  export type InviteListRelationFilter = {
    every?: InviteWhereInput
    some?: InviteWhereInput
    none?: InviteWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type ChatListRelationFilter = {
    every?: ChatWhereInput
    some?: ChatWhereInput
    none?: ChatWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type StudentNullableRelationFilter = {
    is?: StudentWhereInput | null
    isNot?: StudentWhereInput | null
  }

  export type MentorSessionListRelationFilter = {
    every?: MentorSessionWhereInput
    some?: MentorSessionWhereInput
    none?: MentorSessionWhereInput
  }

  export type InternshipEvaluationListRelationFilter = {
    every?: InternshipEvaluationWhereInput
    some?: InternshipEvaluationWhereInput
    none?: InternshipEvaluationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type WorkspaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InviteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternshipEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    teamRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubUsername?: SortOrder
    githubToken?: SortOrder
    githubConnectedAt?: SortOrder
    lastGithubSync?: SortOrder
    profilePictureUrl?: SortOrder
    resumeUrl?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    teamRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubUsername?: SortOrder
    githubToken?: SortOrder
    githubConnectedAt?: SortOrder
    lastGithubSync?: SortOrder
    profilePictureUrl?: SortOrder
    resumeUrl?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    teamRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    githubUsername?: SortOrder
    githubToken?: SortOrder
    githubConnectedAt?: SortOrder
    lastGithubSync?: SortOrder
    profilePictureUrl?: SortOrder
    resumeUrl?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FolderNullableRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type WorkspaceCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    folderId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type WorkspaceMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    folderId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type WorkspaceMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    folderId?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type WorkspaceRelationFilter = {
    is?: WorkspaceWhereInput
    isNot?: WorkspaceWhereInput
  }

  export type InviteCountOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    inviterId?: SortOrder
  }

  export type InviteMaxOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    inviterId?: SortOrder
  }

  export type InviteMinOrderByAggregateInput = {
    id?: SortOrder
    inviteId?: SortOrder
    workspaceId?: SortOrder
    type?: SortOrder
    inviterId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ChatCountOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
  }

  export type ChatAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ChatMaxOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
  }

  export type ChatMinOrderByAggregateInput = {
    id?: SortOrder
    duration?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    workspaceId?: SortOrder
    userId?: SortOrder
  }

  export type ChatSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type InternshipApplicationListRelationFilter = {
    every?: InternshipApplicationWhereInput
    some?: InternshipApplicationWhereInput
    none?: InternshipApplicationWhereInput
  }

  export type CourseEnrollmentListRelationFilter = {
    every?: CourseEnrollmentWhereInput
    some?: CourseEnrollmentWhereInput
    none?: CourseEnrollmentWhereInput
  }

  export type PortfolioProjectListRelationFilter = {
    every?: PortfolioProjectWhereInput
    some?: PortfolioProjectWhereInput
    none?: PortfolioProjectWhereInput
  }

  export type MentorReviewListRelationFilter = {
    every?: MentorReviewWhereInput
    some?: MentorReviewWhereInput
    none?: MentorReviewWhereInput
  }

  export type LogbookEntryListRelationFilter = {
    every?: LogbookEntryWhereInput
    some?: LogbookEntryWhereInput
    none?: LogbookEntryWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type StudentLearningProgressListRelationFilter = {
    every?: StudentLearningProgressWhereInput
    some?: StudentLearningProgressWhereInput
    none?: StudentLearningProgressWhereInput
  }

  export type CertificationListRelationFilter = {
    every?: CertificationWhereInput
    some?: CertificationWhereInput
    none?: CertificationWhereInput
  }

  export type StudentSkillListRelationFilter = {
    every?: StudentSkillWhereInput
    some?: StudentSkillWhereInput
    none?: StudentSkillWhereInput
  }

  export type CVGenerationListRelationFilter = {
    every?: CVGenerationWhereInput
    some?: CVGenerationWhereInput
    none?: CVGenerationWhereInput
  }

  export type InternshipApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseEnrollmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortfolioProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MentorReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LogbookEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentLearningProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CVGenerationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rollNumber?: SortOrder
    department?: SortOrder
    semester?: SortOrder
    cgpa?: SortOrder
    dateOfBirth?: SortOrder
    phone?: SortOrder
    approved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentAvgOrderByAggregateInput = {
    semester?: SortOrder
    cgpa?: SortOrder
  }

  export type StudentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rollNumber?: SortOrder
    department?: SortOrder
    semester?: SortOrder
    cgpa?: SortOrder
    dateOfBirth?: SortOrder
    phone?: SortOrder
    approved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    rollNumber?: SortOrder
    department?: SortOrder
    semester?: SortOrder
    cgpa?: SortOrder
    dateOfBirth?: SortOrder
    phone?: SortOrder
    approved?: SortOrder
    approvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentSumOrderByAggregateInput = {
    semester?: SortOrder
    cgpa?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StudentRelationFilter = {
    is?: StudentWhereInput
    isNot?: StudentWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    avatarUrl?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    resumeUrl?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    avatarUrl?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    resumeUrl?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    bio?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    avatarUrl?: SortOrder
    github?: SortOrder
    linkedin?: SortOrder
    skills?: SortOrder
    interests?: SortOrder
    resumeUrl?: SortOrder
    department?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type InternshipCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    location?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    stipend?: SortOrder
    requiredSkills?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    applicationDeadline?: SortOrder
    isActive?: SortOrder
    postedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternshipAvgOrderByAggregateInput = {
    duration?: SortOrder
    stipend?: SortOrder
  }

  export type InternshipMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    location?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    stipend?: SortOrder
    requiredSkills?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    applicationDeadline?: SortOrder
    isActive?: SortOrder
    postedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternshipMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    companyName?: SortOrder
    location?: SortOrder
    type?: SortOrder
    duration?: SortOrder
    stipend?: SortOrder
    requiredSkills?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    applicationDeadline?: SortOrder
    isActive?: SortOrder
    postedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InternshipSumOrderByAggregateInput = {
    duration?: SortOrder
    stipend?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type InternshipRelationFilter = {
    is?: InternshipWhereInput
    isNot?: InternshipWhereInput
  }

  export type InternshipApplicationStudentIdInternshipIdCompoundUniqueInput = {
    studentId: string
    internshipId: string
  }

  export type InternshipApplicationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    internshipId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
  }

  export type InternshipApplicationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    internshipId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
  }

  export type InternshipApplicationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    internshipId?: SortOrder
    status?: SortOrder
    coverLetter?: SortOrder
    resumeUrl?: SortOrder
    appliedAt?: SortOrder
    reviewedAt?: SortOrder
    rejectionReason?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InternshipEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    internshipId?: SortOrder
    evaluatorId?: SortOrder
    facultyId?: SortOrder
    rubricJson?: SortOrder
    comments?: SortOrder
    finalScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InternshipEvaluationAvgOrderByAggregateInput = {
    finalScore?: SortOrder
  }

  export type InternshipEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    internshipId?: SortOrder
    evaluatorId?: SortOrder
    facultyId?: SortOrder
    rubricJson?: SortOrder
    comments?: SortOrder
    finalScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InternshipEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    internshipId?: SortOrder
    evaluatorId?: SortOrder
    facultyId?: SortOrder
    rubricJson?: SortOrder
    comments?: SortOrder
    finalScore?: SortOrder
    createdAt?: SortOrder
  }

  export type InternshipEvaluationSumOrderByAggregateInput = {
    finalScore?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type CheckpointListRelationFilter = {
    every?: CheckpointWhereInput
    some?: CheckpointWhereInput
    none?: CheckpointWhereInput
  }

  export type CheckpointOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CourseCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    thumbnail?: SortOrder
    instructorId?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CourseMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    thumbnail?: SortOrder
    instructorId?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    type?: SortOrder
    price?: SortOrder
    thumbnail?: SortOrder
    instructorId?: SortOrder
    thumbnailUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CourseSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type CourseRelationFilter = {
    is?: CourseWhereInput
    isNot?: CourseWhereInput
  }

  export type CourseEnrollmentStudentIdCourseIdCompoundUniqueInput = {
    studentId: string
    courseId: string
  }

  export type CourseEnrollmentCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    progressPercent?: SortOrder
    completedAt?: SortOrder
  }

  export type CourseEnrollmentAvgOrderByAggregateInput = {
    progressPercent?: SortOrder
  }

  export type CourseEnrollmentMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    progressPercent?: SortOrder
    completedAt?: SortOrder
  }

  export type CourseEnrollmentMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    courseId?: SortOrder
    enrolledAt?: SortOrder
    progressPercent?: SortOrder
    completedAt?: SortOrder
  }

  export type CourseEnrollmentSumOrderByAggregateInput = {
    progressPercent?: SortOrder
  }

  export type CheckpointCountOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceUrl?: SortOrder
  }

  export type CheckpointMaxOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceUrl?: SortOrder
  }

  export type CheckpointMinOrderByAggregateInput = {
    id?: SortOrder
    courseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resourceUrl?: SortOrder
  }

  export type PortfolioProjectCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    githubRepoId?: SortOrder
    lastSyncedAt?: SortOrder
    stars?: SortOrder
    forks?: SortOrder
    language?: SortOrder
  }

  export type PortfolioProjectAvgOrderByAggregateInput = {
    stars?: SortOrder
    forks?: SortOrder
  }

  export type PortfolioProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    githubRepoId?: SortOrder
    lastSyncedAt?: SortOrder
    stars?: SortOrder
    forks?: SortOrder
    language?: SortOrder
  }

  export type PortfolioProjectMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    githubUrl?: SortOrder
    liveUrl?: SortOrder
    tags?: SortOrder
    createdAt?: SortOrder
    source?: SortOrder
    githubRepoId?: SortOrder
    lastSyncedAt?: SortOrder
    stars?: SortOrder
    forks?: SortOrder
    language?: SortOrder
  }

  export type PortfolioProjectSumOrderByAggregateInput = {
    stars?: SortOrder
    forks?: SortOrder
  }

  export type MentorSessionCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    createdAt?: SortOrder
  }

  export type MentorSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    createdAt?: SortOrder
  }

  export type MentorSessionMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    mentorId?: SortOrder
    scheduledAt?: SortOrder
    status?: SortOrder
    meetingLink?: SortOrder
    createdAt?: SortOrder
  }

  export type MentorSessionRelationFilter = {
    is?: MentorSessionWhereInput
    isNot?: MentorSessionWhereInput
  }

  export type MentorReviewCountOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
  }

  export type MentorReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type MentorReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
  }

  export type MentorReviewMinOrderByAggregateInput = {
    id?: SortOrder
    sessionId?: SortOrder
    studentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
  }

  export type MentorReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type LogbookEntryCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    task?: SortOrder
    hours?: SortOrder
    description?: SortOrder
    proofUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type LogbookEntryAvgOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type LogbookEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    task?: SortOrder
    hours?: SortOrder
    description?: SortOrder
    proofUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type LogbookEntryMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    date?: SortOrder
    task?: SortOrder
    hours?: SortOrder
    description?: SortOrder
    proofUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type LogbookEntrySumOrderByAggregateInput = {
    hours?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuedAt?: SortOrder
    certificateUrl?: SortOrder
  }

  export type StudentLearningProgressCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    profileId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    checkpointId?: SortOrder
  }

  export type StudentLearningProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    profileId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    checkpointId?: SortOrder
  }

  export type StudentLearningProgressMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    profileId?: SortOrder
    isCompleted?: SortOrder
    completedAt?: SortOrder
    checkpointId?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    domain?: SortOrder
  }

  export type CertificationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    credentialId?: SortOrder
    credentialUrl?: SortOrder
    source?: SortOrder
    documentUrl?: SortOrder
    verified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    credentialId?: SortOrder
    credentialUrl?: SortOrder
    source?: SortOrder
    documentUrl?: SortOrder
    verified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CertificationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    title?: SortOrder
    issuer?: SortOrder
    issueDate?: SortOrder
    expiryDate?: SortOrder
    credentialId?: SortOrder
    credentialUrl?: SortOrder
    source?: SortOrder
    documentUrl?: SortOrder
    verified?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type SkillRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type StudentSkillStudentIdSkillIdCompoundUniqueInput = {
    studentId: string
    skillId: string
  }

  export type StudentSkillCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSkillAvgOrderByAggregateInput = {
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrder
  }

  export type StudentSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSkillMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    skillId?: SortOrder
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
  }

  export type StudentSkillSumOrderByAggregateInput = {
    proficiencyLevel?: SortOrder
    yearsExperience?: SortOrder
  }

  export type CVGenerationCountOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    templateName?: SortOrder
    fileUrl?: SortOrder
    format?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type CVGenerationMaxOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    templateName?: SortOrder
    fileUrl?: SortOrder
    format?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type CVGenerationMinOrderByAggregateInput = {
    id?: SortOrder
    studentId?: SortOrder
    templateName?: SortOrder
    fileUrl?: SortOrder
    format?: SortOrder
    generatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    filename?: SortOrder
    originalFilename?: SortOrder
    fileUrl?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    category?: SortOrder
    uploadedAt?: SortOrder
    metadata?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type WorkspaceCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput> | WorkspaceCreateWithoutUserInput[] | WorkspaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInput | WorkspaceCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceCreateManyUserInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutInviterInput = {
    create?: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput> | InviteCreateWithoutInviterInput[] | InviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInviterInput | InviteCreateOrConnectWithoutInviterInput[]
    createMany?: InviteCreateManyInviterInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutUsersInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput> | TeamCreateWithoutUsersInput[] | TeamUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput | TeamCreateOrConnectWithoutUsersInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ChatCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StudentCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type MentorSessionCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput> | MentorSessionCreateWithoutMentorInput[] | MentorSessionUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutMentorInput | MentorSessionCreateOrConnectWithoutMentorInput[]
    createMany?: MentorSessionCreateManyMentorInputEnvelope
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
  }

  export type InternshipEvaluationCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput> | InternshipEvaluationCreateWithoutEvaluatorInput[] | InternshipEvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutEvaluatorInput | InternshipEvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: InternshipEvaluationCreateManyEvaluatorInputEnvelope
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
  }

  export type WorkspaceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput> | WorkspaceCreateWithoutUserInput[] | WorkspaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInput | WorkspaceCreateOrConnectWithoutUserInput[]
    createMany?: WorkspaceCreateManyUserInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput> | InviteCreateWithoutInviterInput[] | InviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInviterInput | InviteCreateOrConnectWithoutInviterInput[]
    createMany?: InviteCreateManyInviterInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput> | TeamCreateWithoutUsersInput[] | TeamUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput | TeamCreateOrConnectWithoutUsersInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type StudentUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    connect?: StudentWhereUniqueInput
  }

  export type MentorSessionUncheckedCreateNestedManyWithoutMentorInput = {
    create?: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput> | MentorSessionCreateWithoutMentorInput[] | MentorSessionUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutMentorInput | MentorSessionCreateOrConnectWithoutMentorInput[]
    createMany?: MentorSessionCreateManyMentorInputEnvelope
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
  }

  export type InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput = {
    create?: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput> | InternshipEvaluationCreateWithoutEvaluatorInput[] | InternshipEvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutEvaluatorInput | InternshipEvaluationCreateOrConnectWithoutEvaluatorInput[]
    createMany?: InternshipEvaluationCreateManyEvaluatorInputEnvelope
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type WorkspaceUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput> | WorkspaceCreateWithoutUserInput[] | WorkspaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInput | WorkspaceCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutUserInput | WorkspaceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceCreateManyUserInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutUserInput | WorkspaceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutUserInput | WorkspaceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutInviterNestedInput = {
    create?: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput> | InviteCreateWithoutInviterInput[] | InviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInviterInput | InviteCreateOrConnectWithoutInviterInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInviterInput | InviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: InviteCreateManyInviterInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInviterInput | InviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInviterInput | InviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput> | TeamCreateWithoutUsersInput[] | TeamUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput | TeamCreateOrConnectWithoutUsersInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutUsersInput | TeamUpsertWithWhereUniqueWithoutUsersInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutUsersInput | TeamUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutUsersInput | TeamUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ChatUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StudentUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type MentorSessionUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput> | MentorSessionCreateWithoutMentorInput[] | MentorSessionUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutMentorInput | MentorSessionCreateOrConnectWithoutMentorInput[]
    upsert?: MentorSessionUpsertWithWhereUniqueWithoutMentorInput | MentorSessionUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorSessionCreateManyMentorInputEnvelope
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    update?: MentorSessionUpdateWithWhereUniqueWithoutMentorInput | MentorSessionUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorSessionUpdateManyWithWhereWithoutMentorInput | MentorSessionUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
  }

  export type InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput> | InternshipEvaluationCreateWithoutEvaluatorInput[] | InternshipEvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutEvaluatorInput | InternshipEvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: InternshipEvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | InternshipEvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: InternshipEvaluationCreateManyEvaluatorInputEnvelope
    set?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    disconnect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    delete?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    update?: InternshipEvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | InternshipEvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: InternshipEvaluationUpdateManyWithWhereWithoutEvaluatorInput | InternshipEvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
  }

  export type WorkspaceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput> | WorkspaceCreateWithoutUserInput[] | WorkspaceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutUserInput | WorkspaceCreateOrConnectWithoutUserInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutUserInput | WorkspaceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkspaceCreateManyUserInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutUserInput | WorkspaceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutUserInput | WorkspaceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput> | InviteCreateWithoutInviterInput[] | InviteUncheckedCreateWithoutInviterInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutInviterInput | InviteCreateOrConnectWithoutInviterInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutInviterInput | InviteUpsertWithWhereUniqueWithoutInviterInput[]
    createMany?: InviteCreateManyInviterInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutInviterInput | InviteUpdateWithWhereUniqueWithoutInviterInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutInviterInput | InviteUpdateManyWithWhereWithoutInviterInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput> | TeamCreateWithoutUsersInput[] | TeamUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutUsersInput | TeamCreateOrConnectWithoutUsersInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutUsersInput | TeamUpsertWithWhereUniqueWithoutUsersInput[]
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutUsersInput | TeamUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutUsersInput | TeamUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput> | ChatCreateWithoutUserInput[] | ChatUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutUserInput | ChatCreateOrConnectWithoutUserInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutUserInput | ChatUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ChatCreateManyUserInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutUserInput | ChatUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutUserInput | ChatUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput> | DocumentCreateWithoutUserInput[] | DocumentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUserInput | DocumentCreateOrConnectWithoutUserInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUserInput | DocumentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DocumentCreateManyUserInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUserInput | DocumentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUserInput | DocumentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type StudentUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentCreateOrConnectWithoutUserInput
    upsert?: StudentUpsertWithoutUserInput
    disconnect?: StudentWhereInput | boolean
    delete?: StudentWhereInput | boolean
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutUserInput, StudentUpdateWithoutUserInput>, StudentUncheckedUpdateWithoutUserInput>
  }

  export type MentorSessionUncheckedUpdateManyWithoutMentorNestedInput = {
    create?: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput> | MentorSessionCreateWithoutMentorInput[] | MentorSessionUncheckedCreateWithoutMentorInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutMentorInput | MentorSessionCreateOrConnectWithoutMentorInput[]
    upsert?: MentorSessionUpsertWithWhereUniqueWithoutMentorInput | MentorSessionUpsertWithWhereUniqueWithoutMentorInput[]
    createMany?: MentorSessionCreateManyMentorInputEnvelope
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    update?: MentorSessionUpdateWithWhereUniqueWithoutMentorInput | MentorSessionUpdateWithWhereUniqueWithoutMentorInput[]
    updateMany?: MentorSessionUpdateManyWithWhereWithoutMentorInput | MentorSessionUpdateManyWithWhereWithoutMentorInput[]
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
  }

  export type InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput = {
    create?: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput> | InternshipEvaluationCreateWithoutEvaluatorInput[] | InternshipEvaluationUncheckedCreateWithoutEvaluatorInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutEvaluatorInput | InternshipEvaluationCreateOrConnectWithoutEvaluatorInput[]
    upsert?: InternshipEvaluationUpsertWithWhereUniqueWithoutEvaluatorInput | InternshipEvaluationUpsertWithWhereUniqueWithoutEvaluatorInput[]
    createMany?: InternshipEvaluationCreateManyEvaluatorInputEnvelope
    set?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    disconnect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    delete?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    update?: InternshipEvaluationUpdateWithWhereUniqueWithoutEvaluatorInput | InternshipEvaluationUpdateWithWhereUniqueWithoutEvaluatorInput[]
    updateMany?: InternshipEvaluationUpdateManyWithWhereWithoutEvaluatorInput | InternshipEvaluationUpdateManyWithWhereWithoutEvaluatorInput[]
    deleteMany?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<FolderCreateWithoutWorkspacesInput, FolderUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspacesInput
    connect?: FolderWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutWorkspacesInput = {
    create?: XOR<TeamCreateWithoutWorkspacesInput, TeamUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspacesInput
    connect?: TeamWhereUniqueInput
  }

  export type ChatCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type InviteCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput> | InviteCreateWithoutWorkspaceInput[] | InviteUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutWorkspaceInput | InviteCreateOrConnectWithoutWorkspaceInput[]
    createMany?: InviteCreateManyWorkspaceInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type ChatUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
  }

  export type InviteUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput> | InviteCreateWithoutWorkspaceInput[] | InviteUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutWorkspaceInput | InviteCreateOrConnectWithoutWorkspaceInput[]
    createMany?: InviteCreateManyWorkspaceInputEnvelope
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkspacesNestedInput = {
    create?: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspacesInput
    upsert?: UserUpsertWithoutWorkspacesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspacesInput, UserUpdateWithoutWorkspacesInput>, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type FolderUpdateOneWithoutWorkspacesNestedInput = {
    create?: XOR<FolderCreateWithoutWorkspacesInput, FolderUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: FolderCreateOrConnectWithoutWorkspacesInput
    upsert?: FolderUpsertWithoutWorkspacesInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutWorkspacesInput, FolderUpdateWithoutWorkspacesInput>, FolderUncheckedUpdateWithoutWorkspacesInput>
  }

  export type TeamUpdateOneWithoutWorkspacesNestedInput = {
    create?: XOR<TeamCreateWithoutWorkspacesInput, TeamUncheckedCreateWithoutWorkspacesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutWorkspacesInput
    upsert?: TeamUpsertWithoutWorkspacesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutWorkspacesInput, TeamUpdateWithoutWorkspacesInput>, TeamUncheckedUpdateWithoutWorkspacesInput>
  }

  export type ChatUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkspaceInput | ChatUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkspaceInput | ChatUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkspaceInput | ChatUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type InviteUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput> | InviteCreateWithoutWorkspaceInput[] | InviteUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutWorkspaceInput | InviteCreateOrConnectWithoutWorkspaceInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutWorkspaceInput | InviteUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: InviteCreateManyWorkspaceInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutWorkspaceInput | InviteUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutWorkspaceInput | InviteUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type ChatUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput> | ChatCreateWithoutWorkspaceInput[] | ChatUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: ChatCreateOrConnectWithoutWorkspaceInput | ChatCreateOrConnectWithoutWorkspaceInput[]
    upsert?: ChatUpsertWithWhereUniqueWithoutWorkspaceInput | ChatUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: ChatCreateManyWorkspaceInputEnvelope
    set?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    disconnect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    delete?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    connect?: ChatWhereUniqueInput | ChatWhereUniqueInput[]
    update?: ChatUpdateWithWhereUniqueWithoutWorkspaceInput | ChatUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: ChatUpdateManyWithWhereWithoutWorkspaceInput | ChatUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: ChatScalarWhereInput | ChatScalarWhereInput[]
  }

  export type InviteUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput> | InviteCreateWithoutWorkspaceInput[] | InviteUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: InviteCreateOrConnectWithoutWorkspaceInput | InviteCreateOrConnectWithoutWorkspaceInput[]
    upsert?: InviteUpsertWithWhereUniqueWithoutWorkspaceInput | InviteUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: InviteCreateManyWorkspaceInputEnvelope
    set?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    disconnect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    delete?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    connect?: InviteWhereUniqueInput | InviteWhereUniqueInput[]
    update?: InviteUpdateWithWhereUniqueWithoutWorkspaceInput | InviteUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: InviteUpdateManyWithWhereWithoutWorkspaceInput | InviteUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: InviteScalarWhereInput | InviteScalarWhereInput[]
  }

  export type WorkspaceCreateNestedManyWithoutFolderInput = {
    create?: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput> | WorkspaceCreateWithoutFolderInput[] | WorkspaceUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFolderInput | WorkspaceCreateOrConnectWithoutFolderInput[]
    createMany?: WorkspaceCreateManyFolderInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type WorkspaceUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput> | WorkspaceCreateWithoutFolderInput[] | WorkspaceUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFolderInput | WorkspaceCreateOrConnectWithoutFolderInput[]
    createMany?: WorkspaceCreateManyFolderInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type WorkspaceUpdateManyWithoutFolderNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput> | WorkspaceCreateWithoutFolderInput[] | WorkspaceUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFolderInput | WorkspaceCreateOrConnectWithoutFolderInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutFolderInput | WorkspaceUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: WorkspaceCreateManyFolderInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutFolderInput | WorkspaceUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutFolderInput | WorkspaceUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type WorkspaceUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput> | WorkspaceCreateWithoutFolderInput[] | WorkspaceUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutFolderInput | WorkspaceCreateOrConnectWithoutFolderInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutFolderInput | WorkspaceUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: WorkspaceCreateManyFolderInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutFolderInput | WorkspaceUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutFolderInput | WorkspaceUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type WorkspaceCreateNestedManyWithoutTeamInput = {
    create?: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput> | WorkspaceCreateWithoutTeamInput[] | WorkspaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamInput | WorkspaceCreateOrConnectWithoutTeamInput[]
    createMany?: WorkspaceCreateManyTeamInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput> | UserCreateWithoutTeamsInput[] | UserUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput | UserCreateOrConnectWithoutTeamsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WorkspaceUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput> | WorkspaceCreateWithoutTeamInput[] | WorkspaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamInput | WorkspaceCreateOrConnectWithoutTeamInput[]
    createMany?: WorkspaceCreateManyTeamInputEnvelope
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput> | UserCreateWithoutTeamsInput[] | UserUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput | UserCreateOrConnectWithoutTeamsInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type WorkspaceUpdateManyWithoutTeamNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput> | WorkspaceCreateWithoutTeamInput[] | WorkspaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamInput | WorkspaceCreateOrConnectWithoutTeamInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutTeamInput | WorkspaceUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: WorkspaceCreateManyTeamInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutTeamInput | WorkspaceUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutTeamInput | WorkspaceUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type UserUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput> | UserCreateWithoutTeamsInput[] | UserUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput | UserCreateOrConnectWithoutTeamsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamsInput | UserUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamsInput | UserUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamsInput | UserUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WorkspaceUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput> | WorkspaceCreateWithoutTeamInput[] | WorkspaceUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: WorkspaceCreateOrConnectWithoutTeamInput | WorkspaceCreateOrConnectWithoutTeamInput[]
    upsert?: WorkspaceUpsertWithWhereUniqueWithoutTeamInput | WorkspaceUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: WorkspaceCreateManyTeamInputEnvelope
    set?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    disconnect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    delete?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    connect?: WorkspaceWhereUniqueInput | WorkspaceWhereUniqueInput[]
    update?: WorkspaceUpdateWithWhereUniqueWithoutTeamInput | WorkspaceUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: WorkspaceUpdateManyWithWhereWithoutTeamInput | WorkspaceUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput> | UserCreateWithoutTeamsInput[] | UserUncheckedCreateWithoutTeamsInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput | UserCreateOrConnectWithoutTeamsInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTeamsInput | UserUpsertWithWhereUniqueWithoutTeamsInput[]
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTeamsInput | UserUpdateWithWhereUniqueWithoutTeamsInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTeamsInput | UserUpdateManyWithWhereWithoutTeamsInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type WorkspaceCreateNestedOneWithoutInvitesInput = {
    create?: XOR<WorkspaceCreateWithoutInvitesInput, WorkspaceUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitesInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitesInput = {
    create?: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesInput
    connect?: UserWhereUniqueInput
  }

  export type WorkspaceUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<WorkspaceCreateWithoutInvitesInput, WorkspaceUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutInvitesInput
    upsert?: WorkspaceUpsertWithoutInvitesInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutInvitesInput, WorkspaceUpdateWithoutInvitesInput>, WorkspaceUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateOneRequiredWithoutInvitesNestedInput = {
    create?: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitesInput
    upsert?: UserUpsertWithoutInvitesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitesInput, UserUpdateWithoutInvitesInput>, UserUncheckedUpdateWithoutInvitesInput>
  }

  export type WorkspaceCreateNestedOneWithoutChatsInput = {
    create?: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutChatsInput
    connect?: WorkspaceWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutChatsInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type WorkspaceUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    connectOrCreate?: WorkspaceCreateOrConnectWithoutChatsInput
    upsert?: WorkspaceUpsertWithoutChatsInput
    connect?: WorkspaceWhereUniqueInput
    update?: XOR<XOR<WorkspaceUpdateToOneWithWhereWithoutChatsInput, WorkspaceUpdateWithoutChatsInput>, WorkspaceUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateOneRequiredWithoutChatsNestedInput = {
    create?: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    connectOrCreate?: UserCreateOrConnectWithoutChatsInput
    upsert?: UserUpsertWithoutChatsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChatsInput, UserUpdateWithoutChatsInput>, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserCreateNestedOneWithoutStudentInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutStudentInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    connect?: ProfileWhereUniqueInput
  }

  export type InternshipApplicationCreateNestedManyWithoutStudentInput = {
    create?: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput> | InternshipApplicationCreateWithoutStudentInput[] | InternshipApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutStudentInput | InternshipApplicationCreateOrConnectWithoutStudentInput[]
    createMany?: InternshipApplicationCreateManyStudentInputEnvelope
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
  }

  export type CourseEnrollmentCreateNestedManyWithoutStudentInput = {
    create?: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput> | CourseEnrollmentCreateWithoutStudentInput[] | CourseEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutStudentInput | CourseEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: CourseEnrollmentCreateManyStudentInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type PortfolioProjectCreateNestedManyWithoutStudentInput = {
    create?: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput> | PortfolioProjectCreateWithoutStudentInput[] | PortfolioProjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PortfolioProjectCreateOrConnectWithoutStudentInput | PortfolioProjectCreateOrConnectWithoutStudentInput[]
    createMany?: PortfolioProjectCreateManyStudentInputEnvelope
    connect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
  }

  export type MentorSessionCreateNestedManyWithoutStudentInput = {
    create?: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput> | MentorSessionCreateWithoutStudentInput[] | MentorSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutStudentInput | MentorSessionCreateOrConnectWithoutStudentInput[]
    createMany?: MentorSessionCreateManyStudentInputEnvelope
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
  }

  export type MentorReviewCreateNestedManyWithoutStudentInput = {
    create?: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput> | MentorReviewCreateWithoutStudentInput[] | MentorReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutStudentInput | MentorReviewCreateOrConnectWithoutStudentInput[]
    createMany?: MentorReviewCreateManyStudentInputEnvelope
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
  }

  export type LogbookEntryCreateNestedManyWithoutStudentInput = {
    create?: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput> | LogbookEntryCreateWithoutStudentInput[] | LogbookEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LogbookEntryCreateOrConnectWithoutStudentInput | LogbookEntryCreateOrConnectWithoutStudentInput[]
    createMany?: LogbookEntryCreateManyStudentInputEnvelope
    connect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type StudentLearningProgressCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput> | StudentLearningProgressCreateWithoutStudentInput[] | StudentLearningProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentLearningProgressCreateOrConnectWithoutStudentInput | StudentLearningProgressCreateOrConnectWithoutStudentInput[]
    createMany?: StudentLearningProgressCreateManyStudentInputEnvelope
    connect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
  }

  export type CertificationCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput> | CertificationCreateWithoutStudentInput[] | CertificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutStudentInput | CertificationCreateOrConnectWithoutStudentInput[]
    createMany?: CertificationCreateManyStudentInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type StudentSkillCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput> | StudentSkillCreateWithoutStudentInput[] | StudentSkillUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutStudentInput | StudentSkillCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSkillCreateManyStudentInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type CVGenerationCreateNestedManyWithoutStudentInput = {
    create?: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput> | CVGenerationCreateWithoutStudentInput[] | CVGenerationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CVGenerationCreateOrConnectWithoutStudentInput | CVGenerationCreateOrConnectWithoutStudentInput[]
    createMany?: CVGenerationCreateManyStudentInputEnvelope
    connect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutStudentInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    connect?: ProfileWhereUniqueInput
  }

  export type InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput> | InternshipApplicationCreateWithoutStudentInput[] | InternshipApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutStudentInput | InternshipApplicationCreateOrConnectWithoutStudentInput[]
    createMany?: InternshipApplicationCreateManyStudentInputEnvelope
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput> | CourseEnrollmentCreateWithoutStudentInput[] | CourseEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutStudentInput | CourseEnrollmentCreateOrConnectWithoutStudentInput[]
    createMany?: CourseEnrollmentCreateManyStudentInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput> | PortfolioProjectCreateWithoutStudentInput[] | PortfolioProjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PortfolioProjectCreateOrConnectWithoutStudentInput | PortfolioProjectCreateOrConnectWithoutStudentInput[]
    createMany?: PortfolioProjectCreateManyStudentInputEnvelope
    connect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
  }

  export type MentorSessionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput> | MentorSessionCreateWithoutStudentInput[] | MentorSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutStudentInput | MentorSessionCreateOrConnectWithoutStudentInput[]
    createMany?: MentorSessionCreateManyStudentInputEnvelope
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
  }

  export type MentorReviewUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput> | MentorReviewCreateWithoutStudentInput[] | MentorReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutStudentInput | MentorReviewCreateOrConnectWithoutStudentInput[]
    createMany?: MentorReviewCreateManyStudentInputEnvelope
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
  }

  export type LogbookEntryUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput> | LogbookEntryCreateWithoutStudentInput[] | LogbookEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LogbookEntryCreateOrConnectWithoutStudentInput | LogbookEntryCreateOrConnectWithoutStudentInput[]
    createMany?: LogbookEntryCreateManyStudentInputEnvelope
    connect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput> | StudentLearningProgressCreateWithoutStudentInput[] | StudentLearningProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentLearningProgressCreateOrConnectWithoutStudentInput | StudentLearningProgressCreateOrConnectWithoutStudentInput[]
    createMany?: StudentLearningProgressCreateManyStudentInputEnvelope
    connect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
  }

  export type CertificationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput> | CertificationCreateWithoutStudentInput[] | CertificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutStudentInput | CertificationCreateOrConnectWithoutStudentInput[]
    createMany?: CertificationCreateManyStudentInputEnvelope
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
  }

  export type StudentSkillUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput> | StudentSkillCreateWithoutStudentInput[] | StudentSkillUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutStudentInput | StudentSkillCreateOrConnectWithoutStudentInput[]
    createMany?: StudentSkillCreateManyStudentInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type CVGenerationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput> | CVGenerationCreateWithoutStudentInput[] | CVGenerationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CVGenerationCreateOrConnectWithoutStudentInput | CVGenerationCreateOrConnectWithoutStudentInput[]
    createMany?: CVGenerationCreateManyStudentInputEnvelope
    connect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutStudentNestedInput = {
    create?: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentInput
    upsert?: UserUpsertWithoutStudentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentInput, UserUpdateWithoutStudentInput>, UserUncheckedUpdateWithoutStudentInput>
  }

  export type ProfileUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    upsert?: ProfileUpsertWithoutStudentInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutStudentInput, ProfileUpdateWithoutStudentInput>, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type InternshipApplicationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput> | InternshipApplicationCreateWithoutStudentInput[] | InternshipApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutStudentInput | InternshipApplicationCreateOrConnectWithoutStudentInput[]
    upsert?: InternshipApplicationUpsertWithWhereUniqueWithoutStudentInput | InternshipApplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InternshipApplicationCreateManyStudentInputEnvelope
    set?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    disconnect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    delete?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    update?: InternshipApplicationUpdateWithWhereUniqueWithoutStudentInput | InternshipApplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InternshipApplicationUpdateManyWithWhereWithoutStudentInput | InternshipApplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput> | CourseEnrollmentCreateWithoutStudentInput[] | CourseEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutStudentInput | CourseEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutStudentInput | CourseEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CourseEnrollmentCreateManyStudentInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutStudentInput | CourseEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutStudentInput | CourseEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type PortfolioProjectUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput> | PortfolioProjectCreateWithoutStudentInput[] | PortfolioProjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PortfolioProjectCreateOrConnectWithoutStudentInput | PortfolioProjectCreateOrConnectWithoutStudentInput[]
    upsert?: PortfolioProjectUpsertWithWhereUniqueWithoutStudentInput | PortfolioProjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PortfolioProjectCreateManyStudentInputEnvelope
    set?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    disconnect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    delete?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    connect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    update?: PortfolioProjectUpdateWithWhereUniqueWithoutStudentInput | PortfolioProjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PortfolioProjectUpdateManyWithWhereWithoutStudentInput | PortfolioProjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PortfolioProjectScalarWhereInput | PortfolioProjectScalarWhereInput[]
  }

  export type MentorSessionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput> | MentorSessionCreateWithoutStudentInput[] | MentorSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutStudentInput | MentorSessionCreateOrConnectWithoutStudentInput[]
    upsert?: MentorSessionUpsertWithWhereUniqueWithoutStudentInput | MentorSessionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MentorSessionCreateManyStudentInputEnvelope
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    update?: MentorSessionUpdateWithWhereUniqueWithoutStudentInput | MentorSessionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MentorSessionUpdateManyWithWhereWithoutStudentInput | MentorSessionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
  }

  export type MentorReviewUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput> | MentorReviewCreateWithoutStudentInput[] | MentorReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutStudentInput | MentorReviewCreateOrConnectWithoutStudentInput[]
    upsert?: MentorReviewUpsertWithWhereUniqueWithoutStudentInput | MentorReviewUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MentorReviewCreateManyStudentInputEnvelope
    set?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    disconnect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    delete?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    update?: MentorReviewUpdateWithWhereUniqueWithoutStudentInput | MentorReviewUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MentorReviewUpdateManyWithWhereWithoutStudentInput | MentorReviewUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
  }

  export type LogbookEntryUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput> | LogbookEntryCreateWithoutStudentInput[] | LogbookEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LogbookEntryCreateOrConnectWithoutStudentInput | LogbookEntryCreateOrConnectWithoutStudentInput[]
    upsert?: LogbookEntryUpsertWithWhereUniqueWithoutStudentInput | LogbookEntryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LogbookEntryCreateManyStudentInputEnvelope
    set?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    disconnect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    delete?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    connect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    update?: LogbookEntryUpdateWithWhereUniqueWithoutStudentInput | LogbookEntryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LogbookEntryUpdateManyWithWhereWithoutStudentInput | LogbookEntryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LogbookEntryScalarWhereInput | LogbookEntryScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type StudentLearningProgressUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput> | StudentLearningProgressCreateWithoutStudentInput[] | StudentLearningProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentLearningProgressCreateOrConnectWithoutStudentInput | StudentLearningProgressCreateOrConnectWithoutStudentInput[]
    upsert?: StudentLearningProgressUpsertWithWhereUniqueWithoutStudentInput | StudentLearningProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentLearningProgressCreateManyStudentInputEnvelope
    set?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    disconnect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    delete?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    connect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    update?: StudentLearningProgressUpdateWithWhereUniqueWithoutStudentInput | StudentLearningProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentLearningProgressUpdateManyWithWhereWithoutStudentInput | StudentLearningProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentLearningProgressScalarWhereInput | StudentLearningProgressScalarWhereInput[]
  }

  export type CertificationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput> | CertificationCreateWithoutStudentInput[] | CertificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutStudentInput | CertificationCreateOrConnectWithoutStudentInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutStudentInput | CertificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificationCreateManyStudentInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutStudentInput | CertificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutStudentInput | CertificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type StudentSkillUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput> | StudentSkillCreateWithoutStudentInput[] | StudentSkillUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutStudentInput | StudentSkillCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutStudentInput | StudentSkillUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSkillCreateManyStudentInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutStudentInput | StudentSkillUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutStudentInput | StudentSkillUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type CVGenerationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput> | CVGenerationCreateWithoutStudentInput[] | CVGenerationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CVGenerationCreateOrConnectWithoutStudentInput | CVGenerationCreateOrConnectWithoutStudentInput[]
    upsert?: CVGenerationUpsertWithWhereUniqueWithoutStudentInput | CVGenerationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CVGenerationCreateManyStudentInputEnvelope
    set?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    disconnect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    delete?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    connect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    update?: CVGenerationUpdateWithWhereUniqueWithoutStudentInput | CVGenerationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CVGenerationUpdateManyWithWhereWithoutStudentInput | CVGenerationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CVGenerationScalarWhereInput | CVGenerationScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutStudentNestedInput = {
    create?: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStudentInput
    upsert?: ProfileUpsertWithoutStudentInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutStudentInput, ProfileUpdateWithoutStudentInput>, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput> | InternshipApplicationCreateWithoutStudentInput[] | InternshipApplicationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutStudentInput | InternshipApplicationCreateOrConnectWithoutStudentInput[]
    upsert?: InternshipApplicationUpsertWithWhereUniqueWithoutStudentInput | InternshipApplicationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: InternshipApplicationCreateManyStudentInputEnvelope
    set?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    disconnect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    delete?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    update?: InternshipApplicationUpdateWithWhereUniqueWithoutStudentInput | InternshipApplicationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: InternshipApplicationUpdateManyWithWhereWithoutStudentInput | InternshipApplicationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput> | CourseEnrollmentCreateWithoutStudentInput[] | CourseEnrollmentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutStudentInput | CourseEnrollmentCreateOrConnectWithoutStudentInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutStudentInput | CourseEnrollmentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CourseEnrollmentCreateManyStudentInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutStudentInput | CourseEnrollmentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutStudentInput | CourseEnrollmentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput> | PortfolioProjectCreateWithoutStudentInput[] | PortfolioProjectUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PortfolioProjectCreateOrConnectWithoutStudentInput | PortfolioProjectCreateOrConnectWithoutStudentInput[]
    upsert?: PortfolioProjectUpsertWithWhereUniqueWithoutStudentInput | PortfolioProjectUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PortfolioProjectCreateManyStudentInputEnvelope
    set?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    disconnect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    delete?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    connect?: PortfolioProjectWhereUniqueInput | PortfolioProjectWhereUniqueInput[]
    update?: PortfolioProjectUpdateWithWhereUniqueWithoutStudentInput | PortfolioProjectUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PortfolioProjectUpdateManyWithWhereWithoutStudentInput | PortfolioProjectUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PortfolioProjectScalarWhereInput | PortfolioProjectScalarWhereInput[]
  }

  export type MentorSessionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput> | MentorSessionCreateWithoutStudentInput[] | MentorSessionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorSessionCreateOrConnectWithoutStudentInput | MentorSessionCreateOrConnectWithoutStudentInput[]
    upsert?: MentorSessionUpsertWithWhereUniqueWithoutStudentInput | MentorSessionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MentorSessionCreateManyStudentInputEnvelope
    set?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    disconnect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    delete?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    connect?: MentorSessionWhereUniqueInput | MentorSessionWhereUniqueInput[]
    update?: MentorSessionUpdateWithWhereUniqueWithoutStudentInput | MentorSessionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MentorSessionUpdateManyWithWhereWithoutStudentInput | MentorSessionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
  }

  export type MentorReviewUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput> | MentorReviewCreateWithoutStudentInput[] | MentorReviewUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutStudentInput | MentorReviewCreateOrConnectWithoutStudentInput[]
    upsert?: MentorReviewUpsertWithWhereUniqueWithoutStudentInput | MentorReviewUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: MentorReviewCreateManyStudentInputEnvelope
    set?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    disconnect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    delete?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    update?: MentorReviewUpdateWithWhereUniqueWithoutStudentInput | MentorReviewUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: MentorReviewUpdateManyWithWhereWithoutStudentInput | MentorReviewUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
  }

  export type LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput> | LogbookEntryCreateWithoutStudentInput[] | LogbookEntryUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: LogbookEntryCreateOrConnectWithoutStudentInput | LogbookEntryCreateOrConnectWithoutStudentInput[]
    upsert?: LogbookEntryUpsertWithWhereUniqueWithoutStudentInput | LogbookEntryUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: LogbookEntryCreateManyStudentInputEnvelope
    set?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    disconnect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    delete?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    connect?: LogbookEntryWhereUniqueInput | LogbookEntryWhereUniqueInput[]
    update?: LogbookEntryUpdateWithWhereUniqueWithoutStudentInput | LogbookEntryUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: LogbookEntryUpdateManyWithWhereWithoutStudentInput | LogbookEntryUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: LogbookEntryScalarWhereInput | LogbookEntryScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput> | CertificateCreateWithoutStudentInput[] | CertificateUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutStudentInput | CertificateCreateOrConnectWithoutStudentInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutStudentInput | CertificateUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificateCreateManyStudentInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutStudentInput | CertificateUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutStudentInput | CertificateUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput> | StudentLearningProgressCreateWithoutStudentInput[] | StudentLearningProgressUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentLearningProgressCreateOrConnectWithoutStudentInput | StudentLearningProgressCreateOrConnectWithoutStudentInput[]
    upsert?: StudentLearningProgressUpsertWithWhereUniqueWithoutStudentInput | StudentLearningProgressUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentLearningProgressCreateManyStudentInputEnvelope
    set?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    disconnect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    delete?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    connect?: StudentLearningProgressWhereUniqueInput | StudentLearningProgressWhereUniqueInput[]
    update?: StudentLearningProgressUpdateWithWhereUniqueWithoutStudentInput | StudentLearningProgressUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentLearningProgressUpdateManyWithWhereWithoutStudentInput | StudentLearningProgressUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentLearningProgressScalarWhereInput | StudentLearningProgressScalarWhereInput[]
  }

  export type CertificationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput> | CertificationCreateWithoutStudentInput[] | CertificationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CertificationCreateOrConnectWithoutStudentInput | CertificationCreateOrConnectWithoutStudentInput[]
    upsert?: CertificationUpsertWithWhereUniqueWithoutStudentInput | CertificationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CertificationCreateManyStudentInputEnvelope
    set?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    disconnect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    delete?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    connect?: CertificationWhereUniqueInput | CertificationWhereUniqueInput[]
    update?: CertificationUpdateWithWhereUniqueWithoutStudentInput | CertificationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CertificationUpdateManyWithWhereWithoutStudentInput | CertificationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
  }

  export type StudentSkillUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput> | StudentSkillCreateWithoutStudentInput[] | StudentSkillUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutStudentInput | StudentSkillCreateOrConnectWithoutStudentInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutStudentInput | StudentSkillUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentSkillCreateManyStudentInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutStudentInput | StudentSkillUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutStudentInput | StudentSkillUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type CVGenerationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput> | CVGenerationCreateWithoutStudentInput[] | CVGenerationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: CVGenerationCreateOrConnectWithoutStudentInput | CVGenerationCreateOrConnectWithoutStudentInput[]
    upsert?: CVGenerationUpsertWithWhereUniqueWithoutStudentInput | CVGenerationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: CVGenerationCreateManyStudentInputEnvelope
    set?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    disconnect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    delete?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    connect?: CVGenerationWhereUniqueInput | CVGenerationWhereUniqueInput[]
    update?: CVGenerationUpdateWithWhereUniqueWithoutStudentInput | CVGenerationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: CVGenerationUpdateManyWithWhereWithoutStudentInput | CVGenerationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: CVGenerationScalarWhereInput | CVGenerationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutProfileInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProfileInput
    upsert?: StudentUpsertWithoutProfileInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProfileInput, StudentUpdateWithoutProfileInput>, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type InternshipApplicationCreateNestedManyWithoutInternshipInput = {
    create?: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput> | InternshipApplicationCreateWithoutInternshipInput[] | InternshipApplicationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutInternshipInput | InternshipApplicationCreateOrConnectWithoutInternshipInput[]
    createMany?: InternshipApplicationCreateManyInternshipInputEnvelope
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
  }

  export type InternshipEvaluationCreateNestedManyWithoutInternshipInput = {
    create?: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput> | InternshipEvaluationCreateWithoutInternshipInput[] | InternshipEvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutInternshipInput | InternshipEvaluationCreateOrConnectWithoutInternshipInput[]
    createMany?: InternshipEvaluationCreateManyInternshipInputEnvelope
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
  }

  export type InternshipApplicationUncheckedCreateNestedManyWithoutInternshipInput = {
    create?: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput> | InternshipApplicationCreateWithoutInternshipInput[] | InternshipApplicationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutInternshipInput | InternshipApplicationCreateOrConnectWithoutInternshipInput[]
    createMany?: InternshipApplicationCreateManyInternshipInputEnvelope
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
  }

  export type InternshipEvaluationUncheckedCreateNestedManyWithoutInternshipInput = {
    create?: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput> | InternshipEvaluationCreateWithoutInternshipInput[] | InternshipEvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutInternshipInput | InternshipEvaluationCreateOrConnectWithoutInternshipInput[]
    createMany?: InternshipEvaluationCreateManyInternshipInputEnvelope
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InternshipApplicationUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput> | InternshipApplicationCreateWithoutInternshipInput[] | InternshipApplicationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutInternshipInput | InternshipApplicationCreateOrConnectWithoutInternshipInput[]
    upsert?: InternshipApplicationUpsertWithWhereUniqueWithoutInternshipInput | InternshipApplicationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: InternshipApplicationCreateManyInternshipInputEnvelope
    set?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    disconnect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    delete?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    update?: InternshipApplicationUpdateWithWhereUniqueWithoutInternshipInput | InternshipApplicationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: InternshipApplicationUpdateManyWithWhereWithoutInternshipInput | InternshipApplicationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
  }

  export type InternshipEvaluationUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput> | InternshipEvaluationCreateWithoutInternshipInput[] | InternshipEvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutInternshipInput | InternshipEvaluationCreateOrConnectWithoutInternshipInput[]
    upsert?: InternshipEvaluationUpsertWithWhereUniqueWithoutInternshipInput | InternshipEvaluationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: InternshipEvaluationCreateManyInternshipInputEnvelope
    set?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    disconnect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    delete?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    update?: InternshipEvaluationUpdateWithWhereUniqueWithoutInternshipInput | InternshipEvaluationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: InternshipEvaluationUpdateManyWithWhereWithoutInternshipInput | InternshipEvaluationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
  }

  export type InternshipApplicationUncheckedUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput> | InternshipApplicationCreateWithoutInternshipInput[] | InternshipApplicationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipApplicationCreateOrConnectWithoutInternshipInput | InternshipApplicationCreateOrConnectWithoutInternshipInput[]
    upsert?: InternshipApplicationUpsertWithWhereUniqueWithoutInternshipInput | InternshipApplicationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: InternshipApplicationCreateManyInternshipInputEnvelope
    set?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    disconnect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    delete?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    connect?: InternshipApplicationWhereUniqueInput | InternshipApplicationWhereUniqueInput[]
    update?: InternshipApplicationUpdateWithWhereUniqueWithoutInternshipInput | InternshipApplicationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: InternshipApplicationUpdateManyWithWhereWithoutInternshipInput | InternshipApplicationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
  }

  export type InternshipEvaluationUncheckedUpdateManyWithoutInternshipNestedInput = {
    create?: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput> | InternshipEvaluationCreateWithoutInternshipInput[] | InternshipEvaluationUncheckedCreateWithoutInternshipInput[]
    connectOrCreate?: InternshipEvaluationCreateOrConnectWithoutInternshipInput | InternshipEvaluationCreateOrConnectWithoutInternshipInput[]
    upsert?: InternshipEvaluationUpsertWithWhereUniqueWithoutInternshipInput | InternshipEvaluationUpsertWithWhereUniqueWithoutInternshipInput[]
    createMany?: InternshipEvaluationCreateManyInternshipInputEnvelope
    set?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    disconnect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    delete?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    connect?: InternshipEvaluationWhereUniqueInput | InternshipEvaluationWhereUniqueInput[]
    update?: InternshipEvaluationUpdateWithWhereUniqueWithoutInternshipInput | InternshipEvaluationUpdateWithWhereUniqueWithoutInternshipInput[]
    updateMany?: InternshipEvaluationUpdateManyWithWhereWithoutInternshipInput | InternshipEvaluationUpdateManyWithWhereWithoutInternshipInput[]
    deleteMany?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<StudentCreateWithoutApplicationsInput, StudentUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutApplicationsInput
    connect?: StudentWhereUniqueInput
  }

  export type InternshipCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<InternshipCreateWithoutApplicationsInput, InternshipUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutApplicationsInput
    connect?: InternshipWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<StudentCreateWithoutApplicationsInput, StudentUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutApplicationsInput
    upsert?: StudentUpsertWithoutApplicationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutApplicationsInput, StudentUpdateWithoutApplicationsInput>, StudentUncheckedUpdateWithoutApplicationsInput>
  }

  export type InternshipUpdateOneRequiredWithoutApplicationsNestedInput = {
    create?: XOR<InternshipCreateWithoutApplicationsInput, InternshipUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutApplicationsInput
    upsert?: InternshipUpsertWithoutApplicationsInput
    connect?: InternshipWhereUniqueInput
    update?: XOR<XOR<InternshipUpdateToOneWithWhereWithoutApplicationsInput, InternshipUpdateWithoutApplicationsInput>, InternshipUncheckedUpdateWithoutApplicationsInput>
  }

  export type InternshipCreateNestedOneWithoutEvaluationsInput = {
    create?: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutEvaluationsInput
    connect?: InternshipWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEvaluationsGivenInput = {
    create?: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsGivenInput
    connect?: UserWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InternshipUpdateOneRequiredWithoutEvaluationsNestedInput = {
    create?: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    connectOrCreate?: InternshipCreateOrConnectWithoutEvaluationsInput
    upsert?: InternshipUpsertWithoutEvaluationsInput
    connect?: InternshipWhereUniqueInput
    update?: XOR<XOR<InternshipUpdateToOneWithWhereWithoutEvaluationsInput, InternshipUpdateWithoutEvaluationsInput>, InternshipUncheckedUpdateWithoutEvaluationsInput>
  }

  export type UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput = {
    create?: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    connectOrCreate?: UserCreateOrConnectWithoutEvaluationsGivenInput
    upsert?: UserUpsertWithoutEvaluationsGivenInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEvaluationsGivenInput, UserUpdateWithoutEvaluationsGivenInput>, UserUncheckedUpdateWithoutEvaluationsGivenInput>
  }

  export type CourseEnrollmentCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type CheckpointCreateNestedManyWithoutCourseInput = {
    create?: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput> | CheckpointCreateWithoutCourseInput[] | CheckpointUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CheckpointCreateOrConnectWithoutCourseInput | CheckpointCreateOrConnectWithoutCourseInput[]
    createMany?: CheckpointCreateManyCourseInputEnvelope
    connect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
  }

  export type CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
  }

  export type CheckpointUncheckedCreateNestedManyWithoutCourseInput = {
    create?: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput> | CheckpointCreateWithoutCourseInput[] | CheckpointUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CheckpointCreateOrConnectWithoutCourseInput | CheckpointCreateOrConnectWithoutCourseInput[]
    createMany?: CheckpointCreateManyCourseInputEnvelope
    connect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
  }

  export type CourseEnrollmentUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type CheckpointUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput> | CheckpointCreateWithoutCourseInput[] | CheckpointUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CheckpointCreateOrConnectWithoutCourseInput | CheckpointCreateOrConnectWithoutCourseInput[]
    upsert?: CheckpointUpsertWithWhereUniqueWithoutCourseInput | CheckpointUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CheckpointCreateManyCourseInputEnvelope
    set?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    disconnect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    delete?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    connect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    update?: CheckpointUpdateWithWhereUniqueWithoutCourseInput | CheckpointUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CheckpointUpdateManyWithWhereWithoutCourseInput | CheckpointUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CheckpointScalarWhereInput | CheckpointScalarWhereInput[]
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput> | CourseEnrollmentCreateWithoutCourseInput[] | CourseEnrollmentUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CourseEnrollmentCreateOrConnectWithoutCourseInput | CourseEnrollmentCreateOrConnectWithoutCourseInput[]
    upsert?: CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CourseEnrollmentCreateManyCourseInputEnvelope
    set?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    disconnect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    delete?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    connect?: CourseEnrollmentWhereUniqueInput | CourseEnrollmentWhereUniqueInput[]
    update?: CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput | CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CourseEnrollmentUpdateManyWithWhereWithoutCourseInput | CourseEnrollmentUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
  }

  export type CheckpointUncheckedUpdateManyWithoutCourseNestedInput = {
    create?: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput> | CheckpointCreateWithoutCourseInput[] | CheckpointUncheckedCreateWithoutCourseInput[]
    connectOrCreate?: CheckpointCreateOrConnectWithoutCourseInput | CheckpointCreateOrConnectWithoutCourseInput[]
    upsert?: CheckpointUpsertWithWhereUniqueWithoutCourseInput | CheckpointUpsertWithWhereUniqueWithoutCourseInput[]
    createMany?: CheckpointCreateManyCourseInputEnvelope
    set?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    disconnect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    delete?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    connect?: CheckpointWhereUniqueInput | CheckpointWhereUniqueInput[]
    update?: CheckpointUpdateWithWhereUniqueWithoutCourseInput | CheckpointUpdateWithWhereUniqueWithoutCourseInput[]
    updateMany?: CheckpointUpdateManyWithWhereWithoutCourseInput | CheckpointUpdateManyWithWhereWithoutCourseInput[]
    deleteMany?: CheckpointScalarWhereInput | CheckpointScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
  }

  export type CourseCreateNestedOneWithoutEnrollmentsInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutEnrollmentsInput
    upsert?: StudentUpsertWithoutEnrollmentsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutEnrollmentsInput, StudentUpdateWithoutEnrollmentsInput>, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateOneRequiredWithoutEnrollmentsNestedInput = {
    create?: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutEnrollmentsInput
    upsert?: CourseUpsertWithoutEnrollmentsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutEnrollmentsInput, CourseUpdateWithoutEnrollmentsInput>, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseCreateNestedOneWithoutCheckpointsInput = {
    create?: XOR<CourseCreateWithoutCheckpointsInput, CourseUncheckedCreateWithoutCheckpointsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCheckpointsInput
    connect?: CourseWhereUniqueInput
  }

  export type CourseUpdateOneRequiredWithoutCheckpointsNestedInput = {
    create?: XOR<CourseCreateWithoutCheckpointsInput, CourseUncheckedCreateWithoutCheckpointsInput>
    connectOrCreate?: CourseCreateOrConnectWithoutCheckpointsInput
    upsert?: CourseUpsertWithoutCheckpointsInput
    connect?: CourseWhereUniqueInput
    update?: XOR<XOR<CourseUpdateToOneWithWhereWithoutCheckpointsInput, CourseUpdateWithoutCheckpointsInput>, CourseUncheckedUpdateWithoutCheckpointsInput>
  }

  export type StudentCreateNestedOneWithoutProjectsInput = {
    create?: XOR<StudentCreateWithoutProjectsInput, StudentUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProjectsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<StudentCreateWithoutProjectsInput, StudentUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutProjectsInput
    upsert?: StudentUpsertWithoutProjectsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutProjectsInput, StudentUpdateWithoutProjectsInput>, StudentUncheckedUpdateWithoutProjectsInput>
  }

  export type StudentCreateNestedOneWithoutMentorSessionsInput = {
    create?: XOR<StudentCreateWithoutMentorSessionsInput, StudentUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMentorSessionsInput
    connect?: StudentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMentorSessionsInput = {
    create?: XOR<UserCreateWithoutMentorSessionsInput, UserUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type MentorReviewCreateNestedManyWithoutSessionInput = {
    create?: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput> | MentorReviewCreateWithoutSessionInput[] | MentorReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutSessionInput | MentorReviewCreateOrConnectWithoutSessionInput[]
    createMany?: MentorReviewCreateManySessionInputEnvelope
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
  }

  export type MentorReviewUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput> | MentorReviewCreateWithoutSessionInput[] | MentorReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutSessionInput | MentorReviewCreateOrConnectWithoutSessionInput[]
    createMany?: MentorReviewCreateManySessionInputEnvelope
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
  }

  export type StudentUpdateOneRequiredWithoutMentorSessionsNestedInput = {
    create?: XOR<StudentCreateWithoutMentorSessionsInput, StudentUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutMentorSessionsInput
    upsert?: StudentUpsertWithoutMentorSessionsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutMentorSessionsInput, StudentUpdateWithoutMentorSessionsInput>, StudentUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type UserUpdateOneRequiredWithoutMentorSessionsNestedInput = {
    create?: XOR<UserCreateWithoutMentorSessionsInput, UserUncheckedCreateWithoutMentorSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMentorSessionsInput
    upsert?: UserUpsertWithoutMentorSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMentorSessionsInput, UserUpdateWithoutMentorSessionsInput>, UserUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type MentorReviewUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput> | MentorReviewCreateWithoutSessionInput[] | MentorReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutSessionInput | MentorReviewCreateOrConnectWithoutSessionInput[]
    upsert?: MentorReviewUpsertWithWhereUniqueWithoutSessionInput | MentorReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MentorReviewCreateManySessionInputEnvelope
    set?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    disconnect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    delete?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    update?: MentorReviewUpdateWithWhereUniqueWithoutSessionInput | MentorReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MentorReviewUpdateManyWithWhereWithoutSessionInput | MentorReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
  }

  export type MentorReviewUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput> | MentorReviewCreateWithoutSessionInput[] | MentorReviewUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: MentorReviewCreateOrConnectWithoutSessionInput | MentorReviewCreateOrConnectWithoutSessionInput[]
    upsert?: MentorReviewUpsertWithWhereUniqueWithoutSessionInput | MentorReviewUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: MentorReviewCreateManySessionInputEnvelope
    set?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    disconnect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    delete?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    connect?: MentorReviewWhereUniqueInput | MentorReviewWhereUniqueInput[]
    update?: MentorReviewUpdateWithWhereUniqueWithoutSessionInput | MentorReviewUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: MentorReviewUpdateManyWithWhereWithoutSessionInput | MentorReviewUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
  }

  export type MentorSessionCreateNestedOneWithoutReviewsInput = {
    create?: XOR<MentorSessionCreateWithoutReviewsInput, MentorSessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MentorSessionCreateOrConnectWithoutReviewsInput
    connect?: MentorSessionWhereUniqueInput
  }

  export type StudentCreateNestedOneWithoutReviewsInput = {
    create?: XOR<StudentCreateWithoutReviewsInput, StudentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReviewsInput
    connect?: StudentWhereUniqueInput
  }

  export type MentorSessionUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<MentorSessionCreateWithoutReviewsInput, MentorSessionUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: MentorSessionCreateOrConnectWithoutReviewsInput
    upsert?: MentorSessionUpsertWithoutReviewsInput
    connect?: MentorSessionWhereUniqueInput
    update?: XOR<XOR<MentorSessionUpdateToOneWithWhereWithoutReviewsInput, MentorSessionUpdateWithoutReviewsInput>, MentorSessionUncheckedUpdateWithoutReviewsInput>
  }

  export type StudentUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<StudentCreateWithoutReviewsInput, StudentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutReviewsInput
    upsert?: StudentUpsertWithoutReviewsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutReviewsInput, StudentUpdateWithoutReviewsInput>, StudentUncheckedUpdateWithoutReviewsInput>
  }

  export type StudentCreateNestedOneWithoutLogbookEntriesInput = {
    create?: XOR<StudentCreateWithoutLogbookEntriesInput, StudentUncheckedCreateWithoutLogbookEntriesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLogbookEntriesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutLogbookEntriesNestedInput = {
    create?: XOR<StudentCreateWithoutLogbookEntriesInput, StudentUncheckedCreateWithoutLogbookEntriesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLogbookEntriesInput
    upsert?: StudentUpsertWithoutLogbookEntriesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLogbookEntriesInput, StudentUpdateWithoutLogbookEntriesInput>, StudentUncheckedUpdateWithoutLogbookEntriesInput>
  }

  export type StudentCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificatesInput
    upsert?: StudentUpsertWithoutCertificatesInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCertificatesInput, StudentUpdateWithoutCertificatesInput>, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentCreateNestedOneWithoutLearningProgressInput = {
    create?: XOR<StudentCreateWithoutLearningProgressInput, StudentUncheckedCreateWithoutLearningProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLearningProgressInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutLearningProgressNestedInput = {
    create?: XOR<StudentCreateWithoutLearningProgressInput, StudentUncheckedCreateWithoutLearningProgressInput>
    connectOrCreate?: StudentCreateOrConnectWithoutLearningProgressInput
    upsert?: StudentUpsertWithoutLearningProgressInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutLearningProgressInput, StudentUpdateWithoutLearningProgressInput>, StudentUncheckedUpdateWithoutLearningProgressInput>
  }

  export type StudentCreateNestedOneWithoutCertificationsInput = {
    create?: XOR<StudentCreateWithoutCertificationsInput, StudentUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificationsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutCertificationsNestedInput = {
    create?: XOR<StudentCreateWithoutCertificationsInput, StudentUncheckedCreateWithoutCertificationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCertificationsInput
    upsert?: StudentUpsertWithoutCertificationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCertificationsInput, StudentUpdateWithoutCertificationsInput>, StudentUncheckedUpdateWithoutCertificationsInput>
  }

  export type StudentSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput> | StudentSkillCreateWithoutSkillInput[] | StudentSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutSkillInput | StudentSkillCreateOrConnectWithoutSkillInput[]
    createMany?: StudentSkillCreateManySkillInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type StudentSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput> | StudentSkillCreateWithoutSkillInput[] | StudentSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutSkillInput | StudentSkillCreateOrConnectWithoutSkillInput[]
    createMany?: StudentSkillCreateManySkillInputEnvelope
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
  }

  export type StudentSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput> | StudentSkillCreateWithoutSkillInput[] | StudentSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutSkillInput | StudentSkillCreateOrConnectWithoutSkillInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutSkillInput | StudentSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: StudentSkillCreateManySkillInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutSkillInput | StudentSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutSkillInput | StudentSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type StudentSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput> | StudentSkillCreateWithoutSkillInput[] | StudentSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: StudentSkillCreateOrConnectWithoutSkillInput | StudentSkillCreateOrConnectWithoutSkillInput[]
    upsert?: StudentSkillUpsertWithWhereUniqueWithoutSkillInput | StudentSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: StudentSkillCreateManySkillInputEnvelope
    set?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    disconnect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    delete?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    connect?: StudentSkillWhereUniqueInput | StudentSkillWhereUniqueInput[]
    update?: StudentSkillUpdateWithWhereUniqueWithoutSkillInput | StudentSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: StudentSkillUpdateManyWithWhereWithoutSkillInput | StudentSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
  }

  export type StudentCreateNestedOneWithoutStudentSkillsInput = {
    create?: XOR<StudentCreateWithoutStudentSkillsInput, StudentUncheckedCreateWithoutStudentSkillsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSkillsInput
    connect?: StudentWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutStudentSkillsInput = {
    create?: XOR<SkillCreateWithoutStudentSkillsInput, SkillUncheckedCreateWithoutStudentSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStudentSkillsInput
    connect?: SkillWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutStudentSkillsNestedInput = {
    create?: XOR<StudentCreateWithoutStudentSkillsInput, StudentUncheckedCreateWithoutStudentSkillsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutStudentSkillsInput
    upsert?: StudentUpsertWithoutStudentSkillsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutStudentSkillsInput, StudentUpdateWithoutStudentSkillsInput>, StudentUncheckedUpdateWithoutStudentSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutStudentSkillsNestedInput = {
    create?: XOR<SkillCreateWithoutStudentSkillsInput, SkillUncheckedCreateWithoutStudentSkillsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutStudentSkillsInput
    upsert?: SkillUpsertWithoutStudentSkillsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutStudentSkillsInput, SkillUpdateWithoutStudentSkillsInput>, SkillUncheckedUpdateWithoutStudentSkillsInput>
  }

  export type StudentCreateNestedOneWithoutCvGenerationsInput = {
    create?: XOR<StudentCreateWithoutCvGenerationsInput, StudentUncheckedCreateWithoutCvGenerationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCvGenerationsInput
    connect?: StudentWhereUniqueInput
  }

  export type StudentUpdateOneRequiredWithoutCvGenerationsNestedInput = {
    create?: XOR<StudentCreateWithoutCvGenerationsInput, StudentUncheckedCreateWithoutCvGenerationsInput>
    connectOrCreate?: StudentCreateOrConnectWithoutCvGenerationsInput
    upsert?: StudentUpsertWithoutCvGenerationsInput
    connect?: StudentWhereUniqueInput
    update?: XOR<XOR<StudentUpdateToOneWithWhereWithoutCvGenerationsInput, StudentUpdateWithoutCvGenerationsInput>, StudentUncheckedUpdateWithoutCvGenerationsInput>
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type WorkspaceCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    folder?: FolderCreateNestedOneWithoutWorkspacesInput
    team?: TeamCreateNestedOneWithoutWorkspacesInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    invites?: InviteCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutUserInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    invites?: InviteUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutUserInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceCreateManyUserInputEnvelope = {
    data: WorkspaceCreateManyUserInput | WorkspaceCreateManyUserInput[]
  }

  export type InviteCreateWithoutInviterInput = {
    id?: string
    inviteId: string
    type: string
    workspace: WorkspaceCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateWithoutInviterInput = {
    id?: string
    inviteId: string
    workspaceId: string
    type: string
  }

  export type InviteCreateOrConnectWithoutInviterInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput>
  }

  export type InviteCreateManyInviterInputEnvelope = {
    data: InviteCreateManyInviterInput | InviteCreateManyInviterInput[]
  }

  export type TeamCreateWithoutUsersInput = {
    id?: string
    name: string
    workspaces?: WorkspaceCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutUsersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type ChatCreateWithoutUserInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspace: WorkspaceCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutUserInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspaceId: string
  }

  export type ChatCreateOrConnectWithoutUserInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatCreateManyUserInputEnvelope = {
    data: ChatCreateManyUserInput | ChatCreateManyUserInput[]
  }

  export type DocumentCreateWithoutUserInput = {
    id?: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
  }

  export type DocumentUncheckedCreateWithoutUserInput = {
    id?: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
  }

  export type DocumentCreateOrConnectWithoutUserInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentCreateManyUserInputEnvelope = {
    data: DocumentCreateManyUserInput | DocumentCreateManyUserInput[]
  }

  export type StudentCreateWithoutUserInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutUserInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutUserInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
  }

  export type MentorSessionCreateWithoutMentorInput = {
    id?: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutMentorSessionsInput
    reviews?: MentorReviewCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionUncheckedCreateWithoutMentorInput = {
    id?: string
    studentId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionCreateOrConnectWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput
    create: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
  }

  export type MentorSessionCreateManyMentorInputEnvelope = {
    data: MentorSessionCreateManyMentorInput | MentorSessionCreateManyMentorInput[]
  }

  export type InternshipEvaluationCreateWithoutEvaluatorInput = {
    id?: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
    internship: InternshipCreateNestedOneWithoutEvaluationsInput
  }

  export type InternshipEvaluationUncheckedCreateWithoutEvaluatorInput = {
    id?: string
    internshipId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type InternshipEvaluationCreateOrConnectWithoutEvaluatorInput = {
    where: InternshipEvaluationWhereUniqueInput
    create: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type InternshipEvaluationCreateManyEvaluatorInputEnvelope = {
    data: InternshipEvaluationCreateManyEvaluatorInput | InternshipEvaluationCreateManyEvaluatorInput[]
  }

  export type WorkspaceUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkspaceWhereUniqueInput
    update: XOR<WorkspaceUpdateWithoutUserInput, WorkspaceUncheckedUpdateWithoutUserInput>
    create: XOR<WorkspaceCreateWithoutUserInput, WorkspaceUncheckedCreateWithoutUserInput>
  }

  export type WorkspaceUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkspaceWhereUniqueInput
    data: XOR<WorkspaceUpdateWithoutUserInput, WorkspaceUncheckedUpdateWithoutUserInput>
  }

  export type WorkspaceUpdateManyWithWhereWithoutUserInput = {
    where: WorkspaceScalarWhereInput
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkspaceScalarWhereInput = {
    AND?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    OR?: WorkspaceScalarWhereInput[]
    NOT?: WorkspaceScalarWhereInput | WorkspaceScalarWhereInput[]
    id?: StringFilter<"Workspace"> | string
    createdAt?: DateTimeFilter<"Workspace"> | Date | string
    folderId?: StringNullableFilter<"Workspace"> | string | null
    teamId?: StringNullableFilter<"Workspace"> | string | null
    userId?: StringFilter<"Workspace"> | string
  }

  export type InviteUpsertWithWhereUniqueWithoutInviterInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutInviterInput, InviteUncheckedUpdateWithoutInviterInput>
    create: XOR<InviteCreateWithoutInviterInput, InviteUncheckedCreateWithoutInviterInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutInviterInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutInviterInput, InviteUncheckedUpdateWithoutInviterInput>
  }

  export type InviteUpdateManyWithWhereWithoutInviterInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutInviterInput>
  }

  export type InviteScalarWhereInput = {
    AND?: InviteScalarWhereInput | InviteScalarWhereInput[]
    OR?: InviteScalarWhereInput[]
    NOT?: InviteScalarWhereInput | InviteScalarWhereInput[]
    id?: StringFilter<"Invite"> | string
    inviteId?: StringFilter<"Invite"> | string
    workspaceId?: StringFilter<"Invite"> | string
    type?: StringFilter<"Invite"> | string
    inviterId?: StringFilter<"Invite"> | string
  }

  export type TeamUpsertWithWhereUniqueWithoutUsersInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
    create: XOR<TeamCreateWithoutUsersInput, TeamUncheckedCreateWithoutUsersInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutUsersInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutUsersInput, TeamUncheckedUpdateWithoutUsersInput>
  }

  export type TeamUpdateManyWithWhereWithoutUsersInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutUsersInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    name?: StringFilter<"Team"> | string
  }

  export type ChatUpsertWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
    create: XOR<ChatCreateWithoutUserInput, ChatUncheckedCreateWithoutUserInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutUserInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutUserInput, ChatUncheckedUpdateWithoutUserInput>
  }

  export type ChatUpdateManyWithWhereWithoutUserInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutUserInput>
  }

  export type ChatScalarWhereInput = {
    AND?: ChatScalarWhereInput | ChatScalarWhereInput[]
    OR?: ChatScalarWhereInput[]
    NOT?: ChatScalarWhereInput | ChatScalarWhereInput[]
    id?: StringFilter<"Chat"> | string
    duration?: IntNullableFilter<"Chat"> | number | null
    startedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"Chat"> | Date | string | null
    workspaceId?: StringFilter<"Chat"> | string
    userId?: StringFilter<"Chat"> | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
    create: XOR<DocumentCreateWithoutUserInput, DocumentUncheckedCreateWithoutUserInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUserInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUserInput, DocumentUncheckedUpdateWithoutUserInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUserInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUserInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    userId?: StringFilter<"Document"> | string
    filename?: StringFilter<"Document"> | string
    originalFilename?: StringFilter<"Document"> | string
    fileUrl?: StringFilter<"Document"> | string
    fileType?: StringNullableFilter<"Document"> | string | null
    fileSize?: BigIntNullableFilter<"Document"> | bigint | number | null
    category?: StringNullableFilter<"Document"> | string | null
    uploadedAt?: DateTimeFilter<"Document"> | Date | string
    metadata?: StringNullableFilter<"Document"> | string | null
  }

  export type StudentUpsertWithoutUserInput = {
    update: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
    create: XOR<StudentCreateWithoutUserInput, StudentUncheckedCreateWithoutUserInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutUserInput, StudentUncheckedUpdateWithoutUserInput>
  }

  export type StudentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type MentorSessionUpsertWithWhereUniqueWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput
    update: XOR<MentorSessionUpdateWithoutMentorInput, MentorSessionUncheckedUpdateWithoutMentorInput>
    create: XOR<MentorSessionCreateWithoutMentorInput, MentorSessionUncheckedCreateWithoutMentorInput>
  }

  export type MentorSessionUpdateWithWhereUniqueWithoutMentorInput = {
    where: MentorSessionWhereUniqueInput
    data: XOR<MentorSessionUpdateWithoutMentorInput, MentorSessionUncheckedUpdateWithoutMentorInput>
  }

  export type MentorSessionUpdateManyWithWhereWithoutMentorInput = {
    where: MentorSessionScalarWhereInput
    data: XOR<MentorSessionUpdateManyMutationInput, MentorSessionUncheckedUpdateManyWithoutMentorInput>
  }

  export type MentorSessionScalarWhereInput = {
    AND?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
    OR?: MentorSessionScalarWhereInput[]
    NOT?: MentorSessionScalarWhereInput | MentorSessionScalarWhereInput[]
    id?: StringFilter<"MentorSession"> | string
    studentId?: StringFilter<"MentorSession"> | string
    mentorId?: StringFilter<"MentorSession"> | string
    scheduledAt?: DateTimeFilter<"MentorSession"> | Date | string
    status?: StringFilter<"MentorSession"> | string
    meetingLink?: StringNullableFilter<"MentorSession"> | string | null
    createdAt?: DateTimeFilter<"MentorSession"> | Date | string
  }

  export type InternshipEvaluationUpsertWithWhereUniqueWithoutEvaluatorInput = {
    where: InternshipEvaluationWhereUniqueInput
    update: XOR<InternshipEvaluationUpdateWithoutEvaluatorInput, InternshipEvaluationUncheckedUpdateWithoutEvaluatorInput>
    create: XOR<InternshipEvaluationCreateWithoutEvaluatorInput, InternshipEvaluationUncheckedCreateWithoutEvaluatorInput>
  }

  export type InternshipEvaluationUpdateWithWhereUniqueWithoutEvaluatorInput = {
    where: InternshipEvaluationWhereUniqueInput
    data: XOR<InternshipEvaluationUpdateWithoutEvaluatorInput, InternshipEvaluationUncheckedUpdateWithoutEvaluatorInput>
  }

  export type InternshipEvaluationUpdateManyWithWhereWithoutEvaluatorInput = {
    where: InternshipEvaluationScalarWhereInput
    data: XOR<InternshipEvaluationUpdateManyMutationInput, InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorInput>
  }

  export type InternshipEvaluationScalarWhereInput = {
    AND?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
    OR?: InternshipEvaluationScalarWhereInput[]
    NOT?: InternshipEvaluationScalarWhereInput | InternshipEvaluationScalarWhereInput[]
    id?: StringFilter<"InternshipEvaluation"> | string
    internshipId?: StringFilter<"InternshipEvaluation"> | string
    evaluatorId?: StringFilter<"InternshipEvaluation"> | string
    facultyId?: StringFilter<"InternshipEvaluation"> | string
    rubricJson?: StringFilter<"InternshipEvaluation"> | string
    comments?: StringNullableFilter<"InternshipEvaluation"> | string | null
    finalScore?: FloatFilter<"InternshipEvaluation"> | number
    createdAt?: DateTimeFilter<"InternshipEvaluation"> | Date | string
  }

  export type UserCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutWorkspacesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
  }

  export type FolderCreateWithoutWorkspacesInput = {
    id?: string
    name: string
  }

  export type FolderUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
  }

  export type FolderCreateOrConnectWithoutWorkspacesInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutWorkspacesInput, FolderUncheckedCreateWithoutWorkspacesInput>
  }

  export type TeamCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    users?: UserCreateNestedManyWithoutTeamsInput
  }

  export type TeamUncheckedCreateWithoutWorkspacesInput = {
    id?: string
    name: string
    users?: UserUncheckedCreateNestedManyWithoutTeamsInput
  }

  export type TeamCreateOrConnectWithoutWorkspacesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutWorkspacesInput, TeamUncheckedCreateWithoutWorkspacesInput>
  }

  export type ChatCreateWithoutWorkspaceInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    user: UserCreateNestedOneWithoutChatsInput
  }

  export type ChatUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    userId: string
  }

  export type ChatCreateOrConnectWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    create: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput>
  }

  export type ChatCreateManyWorkspaceInputEnvelope = {
    data: ChatCreateManyWorkspaceInput | ChatCreateManyWorkspaceInput[]
  }

  export type InviteCreateWithoutWorkspaceInput = {
    id?: string
    inviteId: string
    type: string
    inviter: UserCreateNestedOneWithoutInvitesInput
  }

  export type InviteUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    inviteId: string
    type: string
    inviterId: string
  }

  export type InviteCreateOrConnectWithoutWorkspaceInput = {
    where: InviteWhereUniqueInput
    create: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput>
  }

  export type InviteCreateManyWorkspaceInputEnvelope = {
    data: InviteCreateManyWorkspaceInput | InviteCreateManyWorkspaceInput[]
  }

  export type UserUpsertWithoutWorkspacesInput = {
    update: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<UserCreateWithoutWorkspacesInput, UserUncheckedCreateWithoutWorkspacesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspacesInput, UserUncheckedUpdateWithoutWorkspacesInput>
  }

  export type UserUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type FolderUpsertWithoutWorkspacesInput = {
    update: XOR<FolderUpdateWithoutWorkspacesInput, FolderUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<FolderCreateWithoutWorkspacesInput, FolderUncheckedCreateWithoutWorkspacesInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutWorkspacesInput, FolderUncheckedUpdateWithoutWorkspacesInput>
  }

  export type FolderUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FolderUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpsertWithoutWorkspacesInput = {
    update: XOR<TeamUpdateWithoutWorkspacesInput, TeamUncheckedUpdateWithoutWorkspacesInput>
    create: XOR<TeamCreateWithoutWorkspacesInput, TeamUncheckedCreateWithoutWorkspacesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutWorkspacesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutWorkspacesInput, TeamUncheckedUpdateWithoutWorkspacesInput>
  }

  export type TeamUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUpdateManyWithoutTeamsNestedInput
  }

  export type TeamUncheckedUpdateWithoutWorkspacesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    users?: UserUncheckedUpdateManyWithoutTeamsNestedInput
  }

  export type ChatUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    update: XOR<ChatUpdateWithoutWorkspaceInput, ChatUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<ChatCreateWithoutWorkspaceInput, ChatUncheckedCreateWithoutWorkspaceInput>
  }

  export type ChatUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: ChatWhereUniqueInput
    data: XOR<ChatUpdateWithoutWorkspaceInput, ChatUncheckedUpdateWithoutWorkspaceInput>
  }

  export type ChatUpdateManyWithWhereWithoutWorkspaceInput = {
    where: ChatScalarWhereInput
    data: XOR<ChatUpdateManyMutationInput, ChatUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type InviteUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: InviteWhereUniqueInput
    update: XOR<InviteUpdateWithoutWorkspaceInput, InviteUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<InviteCreateWithoutWorkspaceInput, InviteUncheckedCreateWithoutWorkspaceInput>
  }

  export type InviteUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: InviteWhereUniqueInput
    data: XOR<InviteUpdateWithoutWorkspaceInput, InviteUncheckedUpdateWithoutWorkspaceInput>
  }

  export type InviteUpdateManyWithWhereWithoutWorkspaceInput = {
    where: InviteScalarWhereInput
    data: XOR<InviteUpdateManyMutationInput, InviteUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkspaceCreateWithoutFolderInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    team?: TeamCreateNestedOneWithoutWorkspacesInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    invites?: InviteCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutFolderInput = {
    id?: string
    createdAt?: Date | string
    teamId?: string | null
    userId: string
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    invites?: InviteUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutFolderInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput>
  }

  export type WorkspaceCreateManyFolderInputEnvelope = {
    data: WorkspaceCreateManyFolderInput | WorkspaceCreateManyFolderInput[]
  }

  export type WorkspaceUpsertWithWhereUniqueWithoutFolderInput = {
    where: WorkspaceWhereUniqueInput
    update: XOR<WorkspaceUpdateWithoutFolderInput, WorkspaceUncheckedUpdateWithoutFolderInput>
    create: XOR<WorkspaceCreateWithoutFolderInput, WorkspaceUncheckedCreateWithoutFolderInput>
  }

  export type WorkspaceUpdateWithWhereUniqueWithoutFolderInput = {
    where: WorkspaceWhereUniqueInput
    data: XOR<WorkspaceUpdateWithoutFolderInput, WorkspaceUncheckedUpdateWithoutFolderInput>
  }

  export type WorkspaceUpdateManyWithWhereWithoutFolderInput = {
    where: WorkspaceScalarWhereInput
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyWithoutFolderInput>
  }

  export type WorkspaceCreateWithoutTeamInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    folder?: FolderCreateNestedOneWithoutWorkspacesInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
    invites?: InviteCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutTeamInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    userId: string
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
    invites?: InviteUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutTeamInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput>
  }

  export type WorkspaceCreateManyTeamInputEnvelope = {
    data: WorkspaceCreateManyTeamInput | WorkspaceCreateManyTeamInput[]
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type WorkspaceUpsertWithWhereUniqueWithoutTeamInput = {
    where: WorkspaceWhereUniqueInput
    update: XOR<WorkspaceUpdateWithoutTeamInput, WorkspaceUncheckedUpdateWithoutTeamInput>
    create: XOR<WorkspaceCreateWithoutTeamInput, WorkspaceUncheckedCreateWithoutTeamInput>
  }

  export type WorkspaceUpdateWithWhereUniqueWithoutTeamInput = {
    where: WorkspaceWhereUniqueInput
    data: XOR<WorkspaceUpdateWithoutTeamInput, WorkspaceUncheckedUpdateWithoutTeamInput>
  }

  export type WorkspaceUpdateManyWithWhereWithoutTeamInput = {
    where: WorkspaceScalarWhereInput
    data: XOR<WorkspaceUpdateManyMutationInput, WorkspaceUncheckedUpdateManyWithoutTeamInput>
  }

  export type UserUpsertWithWhereUniqueWithoutTeamsInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTeamsInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateManyWithWhereWithoutTeamsInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTeamsInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    teamRole?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    githubUsername?: StringNullableFilter<"User"> | string | null
    githubToken?: StringNullableFilter<"User"> | string | null
    githubConnectedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    lastGithubSync?: DateTimeNullableFilter<"User"> | Date | string | null
    profilePictureUrl?: StringNullableFilter<"User"> | string | null
    resumeUrl?: StringNullableFilter<"User"> | string | null
  }

  export type WorkspaceCreateWithoutInvitesInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    folder?: FolderCreateNestedOneWithoutWorkspacesInput
    team?: TeamCreateNestedOneWithoutWorkspacesInput
    chats?: ChatCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutInvitesInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
    userId: string
    chats?: ChatUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutInvitesInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutInvitesInput, WorkspaceUncheckedCreateWithoutInvitesInput>
  }

  export type UserCreateWithoutInvitesInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutInvitesInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutInvitesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
  }

  export type WorkspaceUpsertWithoutInvitesInput = {
    update: XOR<WorkspaceUpdateWithoutInvitesInput, WorkspaceUncheckedUpdateWithoutInvitesInput>
    create: XOR<WorkspaceCreateWithoutInvitesInput, WorkspaceUncheckedCreateWithoutInvitesInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutInvitesInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutInvitesInput, WorkspaceUncheckedUpdateWithoutInvitesInput>
  }

  export type WorkspaceUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    folder?: FolderUpdateOneWithoutWorkspacesNestedInput
    team?: TeamUpdateOneWithoutWorkspacesNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutInvitesInput = {
    update: XOR<UserUpdateWithoutInvitesInput, UserUncheckedUpdateWithoutInvitesInput>
    create: XOR<UserCreateWithoutInvitesInput, UserUncheckedCreateWithoutInvitesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitesInput, UserUncheckedUpdateWithoutInvitesInput>
  }

  export type UserUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type WorkspaceCreateWithoutChatsInput = {
    id?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspacesInput
    folder?: FolderCreateNestedOneWithoutWorkspacesInput
    team?: TeamCreateNestedOneWithoutWorkspacesInput
    invites?: InviteCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceUncheckedCreateWithoutChatsInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
    userId: string
    invites?: InviteUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkspaceCreateOrConnectWithoutChatsInput = {
    where: WorkspaceWhereUniqueInput
    create: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
  }

  export type UserCreateWithoutChatsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutChatsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutChatsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
  }

  export type WorkspaceUpsertWithoutChatsInput = {
    update: XOR<WorkspaceUpdateWithoutChatsInput, WorkspaceUncheckedUpdateWithoutChatsInput>
    create: XOR<WorkspaceCreateWithoutChatsInput, WorkspaceUncheckedCreateWithoutChatsInput>
    where?: WorkspaceWhereInput
  }

  export type WorkspaceUpdateToOneWithWhereWithoutChatsInput = {
    where?: WorkspaceWhereInput
    data: XOR<WorkspaceUpdateWithoutChatsInput, WorkspaceUncheckedUpdateWithoutChatsInput>
  }

  export type WorkspaceUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    folder?: FolderUpdateOneWithoutWorkspacesNestedInput
    team?: TeamUpdateOneWithoutWorkspacesNestedInput
    invites?: InviteUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    invites?: InviteUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserUpsertWithoutChatsInput = {
    update: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
    create: XOR<UserCreateWithoutChatsInput, UserUncheckedCreateWithoutChatsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChatsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChatsInput, UserUncheckedUpdateWithoutChatsInput>
  }

  export type UserUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutStudentInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutStudentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
  }

  export type ProfileCreateWithoutStudentInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    avatarUrl?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: string | null
    interests?: string | null
    resumeUrl?: string | null
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutStudentInput = {
    id?: string
    bio?: string | null
    gender?: string | null
    dob?: Date | string | null
    avatarUrl?: string | null
    github?: string | null
    linkedin?: string | null
    skills?: string | null
    interests?: string | null
    resumeUrl?: string | null
    department?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutStudentInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
  }

  export type InternshipApplicationCreateWithoutStudentInput = {
    id?: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    internship: InternshipCreateNestedOneWithoutApplicationsInput
  }

  export type InternshipApplicationUncheckedCreateWithoutStudentInput = {
    id?: string
    internshipId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type InternshipApplicationCreateOrConnectWithoutStudentInput = {
    where: InternshipApplicationWhereUniqueInput
    create: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput>
  }

  export type InternshipApplicationCreateManyStudentInputEnvelope = {
    data: InternshipApplicationCreateManyStudentInput | InternshipApplicationCreateManyStudentInput[]
  }

  export type CourseEnrollmentCreateWithoutStudentInput = {
    id?: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
    course: CourseCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutStudentInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type CourseEnrollmentCreateOrConnectWithoutStudentInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type CourseEnrollmentCreateManyStudentInputEnvelope = {
    data: CourseEnrollmentCreateManyStudentInput | CourseEnrollmentCreateManyStudentInput[]
  }

  export type PortfolioProjectCreateWithoutStudentInput = {
    id?: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
  }

  export type PortfolioProjectUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
  }

  export type PortfolioProjectCreateOrConnectWithoutStudentInput = {
    where: PortfolioProjectWhereUniqueInput
    create: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput>
  }

  export type PortfolioProjectCreateManyStudentInputEnvelope = {
    data: PortfolioProjectCreateManyStudentInput | PortfolioProjectCreateManyStudentInput[]
  }

  export type MentorSessionCreateWithoutStudentInput = {
    id?: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    mentor: UserCreateNestedOneWithoutMentorSessionsInput
    reviews?: MentorReviewCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionUncheckedCreateWithoutStudentInput = {
    id?: string
    mentorId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutSessionInput
  }

  export type MentorSessionCreateOrConnectWithoutStudentInput = {
    where: MentorSessionWhereUniqueInput
    create: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput>
  }

  export type MentorSessionCreateManyStudentInputEnvelope = {
    data: MentorSessionCreateManyStudentInput | MentorSessionCreateManyStudentInput[]
  }

  export type MentorReviewCreateWithoutStudentInput = {
    id?: string
    rating: number
    review?: string | null
    session: MentorSessionCreateNestedOneWithoutReviewsInput
  }

  export type MentorReviewUncheckedCreateWithoutStudentInput = {
    id?: string
    sessionId: string
    rating: number
    review?: string | null
  }

  export type MentorReviewCreateOrConnectWithoutStudentInput = {
    where: MentorReviewWhereUniqueInput
    create: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput>
  }

  export type MentorReviewCreateManyStudentInputEnvelope = {
    data: MentorReviewCreateManyStudentInput | MentorReviewCreateManyStudentInput[]
  }

  export type LogbookEntryCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
  }

  export type LogbookEntryUncheckedCreateWithoutStudentInput = {
    id?: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
  }

  export type LogbookEntryCreateOrConnectWithoutStudentInput = {
    where: LogbookEntryWhereUniqueInput
    create: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput>
  }

  export type LogbookEntryCreateManyStudentInputEnvelope = {
    data: LogbookEntryCreateManyStudentInput | LogbookEntryCreateManyStudentInput[]
  }

  export type CertificateCreateWithoutStudentInput = {
    id?: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
  }

  export type CertificateUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
  }

  export type CertificateCreateOrConnectWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateCreateManyStudentInputEnvelope = {
    data: CertificateCreateManyStudentInput | CertificateCreateManyStudentInput[]
  }

  export type StudentLearningProgressCreateWithoutStudentInput = {
    id?: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
  }

  export type StudentLearningProgressUncheckedCreateWithoutStudentInput = {
    id?: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
  }

  export type StudentLearningProgressCreateOrConnectWithoutStudentInput = {
    where: StudentLearningProgressWhereUniqueInput
    create: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput>
  }

  export type StudentLearningProgressCreateManyStudentInputEnvelope = {
    data: StudentLearningProgressCreateManyStudentInput | StudentLearningProgressCreateManyStudentInput[]
  }

  export type CertificationCreateWithoutStudentInput = {
    id?: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificationCreateOrConnectWithoutStudentInput = {
    where: CertificationWhereUniqueInput
    create: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput>
  }

  export type CertificationCreateManyStudentInputEnvelope = {
    data: CertificationCreateManyStudentInput | CertificationCreateManyStudentInput[]
  }

  export type StudentSkillCreateWithoutStudentInput = {
    id?: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
    skill: SkillCreateNestedOneWithoutStudentSkillsInput
  }

  export type StudentSkillUncheckedCreateWithoutStudentInput = {
    id?: string
    skillId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type StudentSkillCreateOrConnectWithoutStudentInput = {
    where: StudentSkillWhereUniqueInput
    create: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput>
  }

  export type StudentSkillCreateManyStudentInputEnvelope = {
    data: StudentSkillCreateManyStudentInput | StudentSkillCreateManyStudentInput[]
  }

  export type CVGenerationCreateWithoutStudentInput = {
    id?: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
  }

  export type CVGenerationUncheckedCreateWithoutStudentInput = {
    id?: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
  }

  export type CVGenerationCreateOrConnectWithoutStudentInput = {
    where: CVGenerationWhereUniqueInput
    create: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput>
  }

  export type CVGenerationCreateManyStudentInputEnvelope = {
    data: CVGenerationCreateManyStudentInput | CVGenerationCreateManyStudentInput[]
  }

  export type UserUpsertWithoutStudentInput = {
    update: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
    create: XOR<UserCreateWithoutStudentInput, UserUncheckedCreateWithoutStudentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentInput, UserUncheckedUpdateWithoutStudentInput>
  }

  export type UserUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type ProfileUpsertWithoutStudentInput = {
    update: XOR<ProfileUpdateWithoutStudentInput, ProfileUncheckedUpdateWithoutStudentInput>
    create: XOR<ProfileCreateWithoutStudentInput, ProfileUncheckedCreateWithoutStudentInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutStudentInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutStudentInput, ProfileUncheckedUpdateWithoutStudentInput>
  }

  export type ProfileUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    linkedin?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableStringFieldUpdateOperationsInput | string | null
    interests?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipApplicationUpsertWithWhereUniqueWithoutStudentInput = {
    where: InternshipApplicationWhereUniqueInput
    update: XOR<InternshipApplicationUpdateWithoutStudentInput, InternshipApplicationUncheckedUpdateWithoutStudentInput>
    create: XOR<InternshipApplicationCreateWithoutStudentInput, InternshipApplicationUncheckedCreateWithoutStudentInput>
  }

  export type InternshipApplicationUpdateWithWhereUniqueWithoutStudentInput = {
    where: InternshipApplicationWhereUniqueInput
    data: XOR<InternshipApplicationUpdateWithoutStudentInput, InternshipApplicationUncheckedUpdateWithoutStudentInput>
  }

  export type InternshipApplicationUpdateManyWithWhereWithoutStudentInput = {
    where: InternshipApplicationScalarWhereInput
    data: XOR<InternshipApplicationUpdateManyMutationInput, InternshipApplicationUncheckedUpdateManyWithoutStudentInput>
  }

  export type InternshipApplicationScalarWhereInput = {
    AND?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
    OR?: InternshipApplicationScalarWhereInput[]
    NOT?: InternshipApplicationScalarWhereInput | InternshipApplicationScalarWhereInput[]
    id?: StringFilter<"InternshipApplication"> | string
    studentId?: StringFilter<"InternshipApplication"> | string
    internshipId?: StringFilter<"InternshipApplication"> | string
    status?: StringFilter<"InternshipApplication"> | string
    coverLetter?: StringNullableFilter<"InternshipApplication"> | string | null
    resumeUrl?: StringNullableFilter<"InternshipApplication"> | string | null
    appliedAt?: DateTimeFilter<"InternshipApplication"> | Date | string
    reviewedAt?: DateTimeNullableFilter<"InternshipApplication"> | Date | string | null
    rejectionReason?: StringNullableFilter<"InternshipApplication"> | string | null
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutStudentInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutStudentInput, CourseEnrollmentUncheckedUpdateWithoutStudentInput>
    create: XOR<CourseEnrollmentCreateWithoutStudentInput, CourseEnrollmentUncheckedCreateWithoutStudentInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutStudentInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutStudentInput, CourseEnrollmentUncheckedUpdateWithoutStudentInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutStudentInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutStudentInput>
  }

  export type CourseEnrollmentScalarWhereInput = {
    AND?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    OR?: CourseEnrollmentScalarWhereInput[]
    NOT?: CourseEnrollmentScalarWhereInput | CourseEnrollmentScalarWhereInput[]
    id?: StringFilter<"CourseEnrollment"> | string
    studentId?: StringFilter<"CourseEnrollment"> | string
    courseId?: StringFilter<"CourseEnrollment"> | string
    enrolledAt?: DateTimeFilter<"CourseEnrollment"> | Date | string
    progressPercent?: IntFilter<"CourseEnrollment"> | number
    completedAt?: DateTimeNullableFilter<"CourseEnrollment"> | Date | string | null
  }

  export type PortfolioProjectUpsertWithWhereUniqueWithoutStudentInput = {
    where: PortfolioProjectWhereUniqueInput
    update: XOR<PortfolioProjectUpdateWithoutStudentInput, PortfolioProjectUncheckedUpdateWithoutStudentInput>
    create: XOR<PortfolioProjectCreateWithoutStudentInput, PortfolioProjectUncheckedCreateWithoutStudentInput>
  }

  export type PortfolioProjectUpdateWithWhereUniqueWithoutStudentInput = {
    where: PortfolioProjectWhereUniqueInput
    data: XOR<PortfolioProjectUpdateWithoutStudentInput, PortfolioProjectUncheckedUpdateWithoutStudentInput>
  }

  export type PortfolioProjectUpdateManyWithWhereWithoutStudentInput = {
    where: PortfolioProjectScalarWhereInput
    data: XOR<PortfolioProjectUpdateManyMutationInput, PortfolioProjectUncheckedUpdateManyWithoutStudentInput>
  }

  export type PortfolioProjectScalarWhereInput = {
    AND?: PortfolioProjectScalarWhereInput | PortfolioProjectScalarWhereInput[]
    OR?: PortfolioProjectScalarWhereInput[]
    NOT?: PortfolioProjectScalarWhereInput | PortfolioProjectScalarWhereInput[]
    id?: StringFilter<"PortfolioProject"> | string
    studentId?: StringFilter<"PortfolioProject"> | string
    title?: StringFilter<"PortfolioProject"> | string
    description?: StringFilter<"PortfolioProject"> | string
    githubUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    liveUrl?: StringNullableFilter<"PortfolioProject"> | string | null
    tags?: StringNullableFilter<"PortfolioProject"> | string | null
    createdAt?: DateTimeFilter<"PortfolioProject"> | Date | string
    source?: StringFilter<"PortfolioProject"> | string
    githubRepoId?: StringNullableFilter<"PortfolioProject"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"PortfolioProject"> | Date | string | null
    stars?: IntFilter<"PortfolioProject"> | number
    forks?: IntFilter<"PortfolioProject"> | number
    language?: StringNullableFilter<"PortfolioProject"> | string | null
  }

  export type MentorSessionUpsertWithWhereUniqueWithoutStudentInput = {
    where: MentorSessionWhereUniqueInput
    update: XOR<MentorSessionUpdateWithoutStudentInput, MentorSessionUncheckedUpdateWithoutStudentInput>
    create: XOR<MentorSessionCreateWithoutStudentInput, MentorSessionUncheckedCreateWithoutStudentInput>
  }

  export type MentorSessionUpdateWithWhereUniqueWithoutStudentInput = {
    where: MentorSessionWhereUniqueInput
    data: XOR<MentorSessionUpdateWithoutStudentInput, MentorSessionUncheckedUpdateWithoutStudentInput>
  }

  export type MentorSessionUpdateManyWithWhereWithoutStudentInput = {
    where: MentorSessionScalarWhereInput
    data: XOR<MentorSessionUpdateManyMutationInput, MentorSessionUncheckedUpdateManyWithoutStudentInput>
  }

  export type MentorReviewUpsertWithWhereUniqueWithoutStudentInput = {
    where: MentorReviewWhereUniqueInput
    update: XOR<MentorReviewUpdateWithoutStudentInput, MentorReviewUncheckedUpdateWithoutStudentInput>
    create: XOR<MentorReviewCreateWithoutStudentInput, MentorReviewUncheckedCreateWithoutStudentInput>
  }

  export type MentorReviewUpdateWithWhereUniqueWithoutStudentInput = {
    where: MentorReviewWhereUniqueInput
    data: XOR<MentorReviewUpdateWithoutStudentInput, MentorReviewUncheckedUpdateWithoutStudentInput>
  }

  export type MentorReviewUpdateManyWithWhereWithoutStudentInput = {
    where: MentorReviewScalarWhereInput
    data: XOR<MentorReviewUpdateManyMutationInput, MentorReviewUncheckedUpdateManyWithoutStudentInput>
  }

  export type MentorReviewScalarWhereInput = {
    AND?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
    OR?: MentorReviewScalarWhereInput[]
    NOT?: MentorReviewScalarWhereInput | MentorReviewScalarWhereInput[]
    id?: StringFilter<"MentorReview"> | string
    sessionId?: StringFilter<"MentorReview"> | string
    studentId?: StringFilter<"MentorReview"> | string
    rating?: FloatFilter<"MentorReview"> | number
    review?: StringNullableFilter<"MentorReview"> | string | null
  }

  export type LogbookEntryUpsertWithWhereUniqueWithoutStudentInput = {
    where: LogbookEntryWhereUniqueInput
    update: XOR<LogbookEntryUpdateWithoutStudentInput, LogbookEntryUncheckedUpdateWithoutStudentInput>
    create: XOR<LogbookEntryCreateWithoutStudentInput, LogbookEntryUncheckedCreateWithoutStudentInput>
  }

  export type LogbookEntryUpdateWithWhereUniqueWithoutStudentInput = {
    where: LogbookEntryWhereUniqueInput
    data: XOR<LogbookEntryUpdateWithoutStudentInput, LogbookEntryUncheckedUpdateWithoutStudentInput>
  }

  export type LogbookEntryUpdateManyWithWhereWithoutStudentInput = {
    where: LogbookEntryScalarWhereInput
    data: XOR<LogbookEntryUpdateManyMutationInput, LogbookEntryUncheckedUpdateManyWithoutStudentInput>
  }

  export type LogbookEntryScalarWhereInput = {
    AND?: LogbookEntryScalarWhereInput | LogbookEntryScalarWhereInput[]
    OR?: LogbookEntryScalarWhereInput[]
    NOT?: LogbookEntryScalarWhereInput | LogbookEntryScalarWhereInput[]
    id?: StringFilter<"LogbookEntry"> | string
    studentId?: StringFilter<"LogbookEntry"> | string
    date?: DateTimeFilter<"LogbookEntry"> | Date | string
    task?: StringFilter<"LogbookEntry"> | string
    hours?: IntFilter<"LogbookEntry"> | number
    description?: StringFilter<"LogbookEntry"> | string
    proofUrl?: StringNullableFilter<"LogbookEntry"> | string | null
    createdAt?: DateTimeFilter<"LogbookEntry"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
    create: XOR<CertificateCreateWithoutStudentInput, CertificateUncheckedCreateWithoutStudentInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutStudentInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutStudentInput, CertificateUncheckedUpdateWithoutStudentInput>
  }

  export type CertificateUpdateManyWithWhereWithoutStudentInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutStudentInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    studentId?: StringFilter<"Certificate"> | string
    title?: StringFilter<"Certificate"> | string
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    certificateUrl?: StringFilter<"Certificate"> | string
  }

  export type StudentLearningProgressUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentLearningProgressWhereUniqueInput
    update: XOR<StudentLearningProgressUpdateWithoutStudentInput, StudentLearningProgressUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentLearningProgressCreateWithoutStudentInput, StudentLearningProgressUncheckedCreateWithoutStudentInput>
  }

  export type StudentLearningProgressUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentLearningProgressWhereUniqueInput
    data: XOR<StudentLearningProgressUpdateWithoutStudentInput, StudentLearningProgressUncheckedUpdateWithoutStudentInput>
  }

  export type StudentLearningProgressUpdateManyWithWhereWithoutStudentInput = {
    where: StudentLearningProgressScalarWhereInput
    data: XOR<StudentLearningProgressUpdateManyMutationInput, StudentLearningProgressUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentLearningProgressScalarWhereInput = {
    AND?: StudentLearningProgressScalarWhereInput | StudentLearningProgressScalarWhereInput[]
    OR?: StudentLearningProgressScalarWhereInput[]
    NOT?: StudentLearningProgressScalarWhereInput | StudentLearningProgressScalarWhereInput[]
    id?: StringFilter<"StudentLearningProgress"> | string
    studentId?: StringFilter<"StudentLearningProgress"> | string
    profileId?: StringFilter<"StudentLearningProgress"> | string
    isCompleted?: BoolFilter<"StudentLearningProgress"> | boolean
    completedAt?: DateTimeNullableFilter<"StudentLearningProgress"> | Date | string | null
    checkpointId?: StringFilter<"StudentLearningProgress"> | string
  }

  export type CertificationUpsertWithWhereUniqueWithoutStudentInput = {
    where: CertificationWhereUniqueInput
    update: XOR<CertificationUpdateWithoutStudentInput, CertificationUncheckedUpdateWithoutStudentInput>
    create: XOR<CertificationCreateWithoutStudentInput, CertificationUncheckedCreateWithoutStudentInput>
  }

  export type CertificationUpdateWithWhereUniqueWithoutStudentInput = {
    where: CertificationWhereUniqueInput
    data: XOR<CertificationUpdateWithoutStudentInput, CertificationUncheckedUpdateWithoutStudentInput>
  }

  export type CertificationUpdateManyWithWhereWithoutStudentInput = {
    where: CertificationScalarWhereInput
    data: XOR<CertificationUpdateManyMutationInput, CertificationUncheckedUpdateManyWithoutStudentInput>
  }

  export type CertificationScalarWhereInput = {
    AND?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    OR?: CertificationScalarWhereInput[]
    NOT?: CertificationScalarWhereInput | CertificationScalarWhereInput[]
    id?: StringFilter<"Certification"> | string
    studentId?: StringFilter<"Certification"> | string
    title?: StringFilter<"Certification"> | string
    issuer?: StringNullableFilter<"Certification"> | string | null
    issueDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    expiryDate?: DateTimeNullableFilter<"Certification"> | Date | string | null
    credentialId?: StringNullableFilter<"Certification"> | string | null
    credentialUrl?: StringNullableFilter<"Certification"> | string | null
    source?: StringFilter<"Certification"> | string
    documentUrl?: StringNullableFilter<"Certification"> | string | null
    verified?: BoolFilter<"Certification"> | boolean
    metadata?: StringNullableFilter<"Certification"> | string | null
    createdAt?: DateTimeFilter<"Certification"> | Date | string
    updatedAt?: DateTimeFilter<"Certification"> | Date | string
  }

  export type StudentSkillUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentSkillWhereUniqueInput
    update: XOR<StudentSkillUpdateWithoutStudentInput, StudentSkillUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentSkillCreateWithoutStudentInput, StudentSkillUncheckedCreateWithoutStudentInput>
  }

  export type StudentSkillUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentSkillWhereUniqueInput
    data: XOR<StudentSkillUpdateWithoutStudentInput, StudentSkillUncheckedUpdateWithoutStudentInput>
  }

  export type StudentSkillUpdateManyWithWhereWithoutStudentInput = {
    where: StudentSkillScalarWhereInput
    data: XOR<StudentSkillUpdateManyMutationInput, StudentSkillUncheckedUpdateManyWithoutStudentInput>
  }

  export type StudentSkillScalarWhereInput = {
    AND?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
    OR?: StudentSkillScalarWhereInput[]
    NOT?: StudentSkillScalarWhereInput | StudentSkillScalarWhereInput[]
    id?: StringFilter<"StudentSkill"> | string
    studentId?: StringFilter<"StudentSkill"> | string
    skillId?: StringFilter<"StudentSkill"> | string
    proficiencyLevel?: IntFilter<"StudentSkill"> | number
    yearsExperience?: FloatNullableFilter<"StudentSkill"> | number | null
    source?: StringFilter<"StudentSkill"> | string
    createdAt?: DateTimeFilter<"StudentSkill"> | Date | string
  }

  export type CVGenerationUpsertWithWhereUniqueWithoutStudentInput = {
    where: CVGenerationWhereUniqueInput
    update: XOR<CVGenerationUpdateWithoutStudentInput, CVGenerationUncheckedUpdateWithoutStudentInput>
    create: XOR<CVGenerationCreateWithoutStudentInput, CVGenerationUncheckedCreateWithoutStudentInput>
  }

  export type CVGenerationUpdateWithWhereUniqueWithoutStudentInput = {
    where: CVGenerationWhereUniqueInput
    data: XOR<CVGenerationUpdateWithoutStudentInput, CVGenerationUncheckedUpdateWithoutStudentInput>
  }

  export type CVGenerationUpdateManyWithWhereWithoutStudentInput = {
    where: CVGenerationScalarWhereInput
    data: XOR<CVGenerationUpdateManyMutationInput, CVGenerationUncheckedUpdateManyWithoutStudentInput>
  }

  export type CVGenerationScalarWhereInput = {
    AND?: CVGenerationScalarWhereInput | CVGenerationScalarWhereInput[]
    OR?: CVGenerationScalarWhereInput[]
    NOT?: CVGenerationScalarWhereInput | CVGenerationScalarWhereInput[]
    id?: StringFilter<"CVGeneration"> | string
    studentId?: StringFilter<"CVGeneration"> | string
    templateName?: StringFilter<"CVGeneration"> | string
    fileUrl?: StringFilter<"CVGeneration"> | string
    format?: StringFilter<"CVGeneration"> | string
    generatedAt?: DateTimeFilter<"CVGeneration"> | Date | string
    metadata?: StringNullableFilter<"CVGeneration"> | string | null
  }

  export type StudentCreateWithoutProfileInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProfileInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProfileInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
  }

  export type StudentUpsertWithoutProfileInput = {
    update: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
    create: XOR<StudentCreateWithoutProfileInput, StudentUncheckedCreateWithoutProfileInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProfileInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProfileInput, StudentUncheckedUpdateWithoutProfileInput>
  }

  export type StudentUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type InternshipApplicationCreateWithoutInternshipInput = {
    id?: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
    student: StudentCreateNestedOneWithoutApplicationsInput
  }

  export type InternshipApplicationUncheckedCreateWithoutInternshipInput = {
    id?: string
    studentId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type InternshipApplicationCreateOrConnectWithoutInternshipInput = {
    where: InternshipApplicationWhereUniqueInput
    create: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput>
  }

  export type InternshipApplicationCreateManyInternshipInputEnvelope = {
    data: InternshipApplicationCreateManyInternshipInput | InternshipApplicationCreateManyInternshipInput[]
  }

  export type InternshipEvaluationCreateWithoutInternshipInput = {
    id?: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
    evaluator: UserCreateNestedOneWithoutEvaluationsGivenInput
  }

  export type InternshipEvaluationUncheckedCreateWithoutInternshipInput = {
    id?: string
    evaluatorId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type InternshipEvaluationCreateOrConnectWithoutInternshipInput = {
    where: InternshipEvaluationWhereUniqueInput
    create: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput>
  }

  export type InternshipEvaluationCreateManyInternshipInputEnvelope = {
    data: InternshipEvaluationCreateManyInternshipInput | InternshipEvaluationCreateManyInternshipInput[]
  }

  export type InternshipApplicationUpsertWithWhereUniqueWithoutInternshipInput = {
    where: InternshipApplicationWhereUniqueInput
    update: XOR<InternshipApplicationUpdateWithoutInternshipInput, InternshipApplicationUncheckedUpdateWithoutInternshipInput>
    create: XOR<InternshipApplicationCreateWithoutInternshipInput, InternshipApplicationUncheckedCreateWithoutInternshipInput>
  }

  export type InternshipApplicationUpdateWithWhereUniqueWithoutInternshipInput = {
    where: InternshipApplicationWhereUniqueInput
    data: XOR<InternshipApplicationUpdateWithoutInternshipInput, InternshipApplicationUncheckedUpdateWithoutInternshipInput>
  }

  export type InternshipApplicationUpdateManyWithWhereWithoutInternshipInput = {
    where: InternshipApplicationScalarWhereInput
    data: XOR<InternshipApplicationUpdateManyMutationInput, InternshipApplicationUncheckedUpdateManyWithoutInternshipInput>
  }

  export type InternshipEvaluationUpsertWithWhereUniqueWithoutInternshipInput = {
    where: InternshipEvaluationWhereUniqueInput
    update: XOR<InternshipEvaluationUpdateWithoutInternshipInput, InternshipEvaluationUncheckedUpdateWithoutInternshipInput>
    create: XOR<InternshipEvaluationCreateWithoutInternshipInput, InternshipEvaluationUncheckedCreateWithoutInternshipInput>
  }

  export type InternshipEvaluationUpdateWithWhereUniqueWithoutInternshipInput = {
    where: InternshipEvaluationWhereUniqueInput
    data: XOR<InternshipEvaluationUpdateWithoutInternshipInput, InternshipEvaluationUncheckedUpdateWithoutInternshipInput>
  }

  export type InternshipEvaluationUpdateManyWithWhereWithoutInternshipInput = {
    where: InternshipEvaluationScalarWhereInput
    data: XOR<InternshipEvaluationUpdateManyMutationInput, InternshipEvaluationUncheckedUpdateManyWithoutInternshipInput>
  }

  export type StudentCreateWithoutApplicationsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutApplicationsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutApplicationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutApplicationsInput, StudentUncheckedCreateWithoutApplicationsInput>
  }

  export type InternshipCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: InternshipEvaluationCreateNestedManyWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutApplicationsInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    evaluations?: InternshipEvaluationUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutApplicationsInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutApplicationsInput, InternshipUncheckedCreateWithoutApplicationsInput>
  }

  export type StudentUpsertWithoutApplicationsInput = {
    update: XOR<StudentUpdateWithoutApplicationsInput, StudentUncheckedUpdateWithoutApplicationsInput>
    create: XOR<StudentCreateWithoutApplicationsInput, StudentUncheckedCreateWithoutApplicationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutApplicationsInput, StudentUncheckedUpdateWithoutApplicationsInput>
  }

  export type StudentUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type InternshipUpsertWithoutApplicationsInput = {
    update: XOR<InternshipUpdateWithoutApplicationsInput, InternshipUncheckedUpdateWithoutApplicationsInput>
    create: XOR<InternshipCreateWithoutApplicationsInput, InternshipUncheckedCreateWithoutApplicationsInput>
    where?: InternshipWhereInput
  }

  export type InternshipUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: InternshipWhereInput
    data: XOR<InternshipUpdateWithoutApplicationsInput, InternshipUncheckedUpdateWithoutApplicationsInput>
  }

  export type InternshipUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: InternshipEvaluationUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutApplicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluations?: InternshipEvaluationUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipCreateWithoutEvaluationsInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: InternshipApplicationCreateNestedManyWithoutInternshipInput
  }

  export type InternshipUncheckedCreateWithoutEvaluationsInput = {
    id?: string
    title: string
    description: string
    companyName: string
    location: string
    type: string
    duration: number
    stipend?: number | null
    requiredSkills: string
    startDate?: Date | string | null
    endDate?: Date | string | null
    applicationDeadline?: Date | string | null
    isActive?: boolean
    postedBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutInternshipInput
  }

  export type InternshipCreateOrConnectWithoutEvaluationsInput = {
    where: InternshipWhereUniqueInput
    create: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
  }

  export type UserCreateWithoutEvaluationsGivenInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
  }

  export type UserUncheckedCreateWithoutEvaluationsGivenInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
  }

  export type UserCreateOrConnectWithoutEvaluationsGivenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
  }

  export type InternshipUpsertWithoutEvaluationsInput = {
    update: XOR<InternshipUpdateWithoutEvaluationsInput, InternshipUncheckedUpdateWithoutEvaluationsInput>
    create: XOR<InternshipCreateWithoutEvaluationsInput, InternshipUncheckedCreateWithoutEvaluationsInput>
    where?: InternshipWhereInput
  }

  export type InternshipUpdateToOneWithWhereWithoutEvaluationsInput = {
    where?: InternshipWhereInput
    data: XOR<InternshipUpdateWithoutEvaluationsInput, InternshipUncheckedUpdateWithoutEvaluationsInput>
  }

  export type InternshipUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: InternshipApplicationUpdateManyWithoutInternshipNestedInput
  }

  export type InternshipUncheckedUpdateWithoutEvaluationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    companyName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    duration?: IntFieldUpdateOperationsInput | number
    stipend?: NullableIntFieldUpdateOperationsInput | number | null
    requiredSkills?: StringFieldUpdateOperationsInput | string
    startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    applicationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    postedBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    applications?: InternshipApplicationUncheckedUpdateManyWithoutInternshipNestedInput
  }

  export type UserUpsertWithoutEvaluationsGivenInput = {
    update: XOR<UserUpdateWithoutEvaluationsGivenInput, UserUncheckedUpdateWithoutEvaluationsGivenInput>
    create: XOR<UserCreateWithoutEvaluationsGivenInput, UserUncheckedCreateWithoutEvaluationsGivenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEvaluationsGivenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEvaluationsGivenInput, UserUncheckedUpdateWithoutEvaluationsGivenInput>
  }

  export type UserUpdateWithoutEvaluationsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
  }

  export type UserUncheckedUpdateWithoutEvaluationsGivenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
  }

  export type CourseEnrollmentCreateWithoutCourseInput = {
    id?: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
    student: StudentCreateNestedOneWithoutEnrollmentsInput
  }

  export type CourseEnrollmentUncheckedCreateWithoutCourseInput = {
    id?: string
    studentId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type CourseEnrollmentCreateOrConnectWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentCreateManyCourseInputEnvelope = {
    data: CourseEnrollmentCreateManyCourseInput | CourseEnrollmentCreateManyCourseInput[]
  }

  export type CheckpointCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    resourceUrl?: string | null
  }

  export type CheckpointUncheckedCreateWithoutCourseInput = {
    id?: string
    title: string
    description?: string | null
    resourceUrl?: string | null
  }

  export type CheckpointCreateOrConnectWithoutCourseInput = {
    where: CheckpointWhereUniqueInput
    create: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput>
  }

  export type CheckpointCreateManyCourseInputEnvelope = {
    data: CheckpointCreateManyCourseInput | CheckpointCreateManyCourseInput[]
  }

  export type CourseEnrollmentUpsertWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    update: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
    create: XOR<CourseEnrollmentCreateWithoutCourseInput, CourseEnrollmentUncheckedCreateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateWithWhereUniqueWithoutCourseInput = {
    where: CourseEnrollmentWhereUniqueInput
    data: XOR<CourseEnrollmentUpdateWithoutCourseInput, CourseEnrollmentUncheckedUpdateWithoutCourseInput>
  }

  export type CourseEnrollmentUpdateManyWithWhereWithoutCourseInput = {
    where: CourseEnrollmentScalarWhereInput
    data: XOR<CourseEnrollmentUpdateManyMutationInput, CourseEnrollmentUncheckedUpdateManyWithoutCourseInput>
  }

  export type CheckpointUpsertWithWhereUniqueWithoutCourseInput = {
    where: CheckpointWhereUniqueInput
    update: XOR<CheckpointUpdateWithoutCourseInput, CheckpointUncheckedUpdateWithoutCourseInput>
    create: XOR<CheckpointCreateWithoutCourseInput, CheckpointUncheckedCreateWithoutCourseInput>
  }

  export type CheckpointUpdateWithWhereUniqueWithoutCourseInput = {
    where: CheckpointWhereUniqueInput
    data: XOR<CheckpointUpdateWithoutCourseInput, CheckpointUncheckedUpdateWithoutCourseInput>
  }

  export type CheckpointUpdateManyWithWhereWithoutCourseInput = {
    where: CheckpointScalarWhereInput
    data: XOR<CheckpointUpdateManyMutationInput, CheckpointUncheckedUpdateManyWithoutCourseInput>
  }

  export type CheckpointScalarWhereInput = {
    AND?: CheckpointScalarWhereInput | CheckpointScalarWhereInput[]
    OR?: CheckpointScalarWhereInput[]
    NOT?: CheckpointScalarWhereInput | CheckpointScalarWhereInput[]
    id?: StringFilter<"Checkpoint"> | string
    courseId?: StringFilter<"Checkpoint"> | string
    title?: StringFilter<"Checkpoint"> | string
    description?: StringNullableFilter<"Checkpoint"> | string | null
    resourceUrl?: StringNullableFilter<"Checkpoint"> | string | null
  }

  export type StudentCreateWithoutEnrollmentsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutEnrollmentsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
  }

  export type CourseCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    checkpoints?: CheckpointCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutEnrollmentsInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    checkpoints?: CheckpointUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutEnrollmentsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
  }

  export type StudentUpsertWithoutEnrollmentsInput = {
    update: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<StudentCreateWithoutEnrollmentsInput, StudentUncheckedCreateWithoutEnrollmentsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutEnrollmentsInput, StudentUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type StudentUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type CourseUpsertWithoutEnrollmentsInput = {
    update: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
    create: XOR<CourseCreateWithoutEnrollmentsInput, CourseUncheckedCreateWithoutEnrollmentsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutEnrollmentsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutEnrollmentsInput, CourseUncheckedUpdateWithoutEnrollmentsInput>
  }

  export type CourseUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkpoints?: CheckpointUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutEnrollmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checkpoints?: CheckpointUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type CourseCreateWithoutCheckpointsInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    enrollments?: CourseEnrollmentCreateNestedManyWithoutCourseInput
  }

  export type CourseUncheckedCreateWithoutCheckpointsInput = {
    id?: string
    title: string
    description: string
    type: string
    price?: number | null
    thumbnail?: string | null
    instructorId: string
    thumbnailUrl?: string | null
    createdAt?: Date | string
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutCourseInput
  }

  export type CourseCreateOrConnectWithoutCheckpointsInput = {
    where: CourseWhereUniqueInput
    create: XOR<CourseCreateWithoutCheckpointsInput, CourseUncheckedCreateWithoutCheckpointsInput>
  }

  export type CourseUpsertWithoutCheckpointsInput = {
    update: XOR<CourseUpdateWithoutCheckpointsInput, CourseUncheckedUpdateWithoutCheckpointsInput>
    create: XOR<CourseCreateWithoutCheckpointsInput, CourseUncheckedCreateWithoutCheckpointsInput>
    where?: CourseWhereInput
  }

  export type CourseUpdateToOneWithWhereWithoutCheckpointsInput = {
    where?: CourseWhereInput
    data: XOR<CourseUpdateWithoutCheckpointsInput, CourseUncheckedUpdateWithoutCheckpointsInput>
  }

  export type CourseUpdateWithoutCheckpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: CourseEnrollmentUpdateManyWithoutCourseNestedInput
  }

  export type CourseUncheckedUpdateWithoutCheckpointsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    instructorId?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutCourseNestedInput
  }

  export type StudentCreateWithoutProjectsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutProjectsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutProjectsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutProjectsInput, StudentUncheckedCreateWithoutProjectsInput>
  }

  export type StudentUpsertWithoutProjectsInput = {
    update: XOR<StudentUpdateWithoutProjectsInput, StudentUncheckedUpdateWithoutProjectsInput>
    create: XOR<StudentCreateWithoutProjectsInput, StudentUncheckedCreateWithoutProjectsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutProjectsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutProjectsInput, StudentUncheckedUpdateWithoutProjectsInput>
  }

  export type StudentUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutMentorSessionsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutMentorSessionsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutMentorSessionsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutMentorSessionsInput, StudentUncheckedCreateWithoutMentorSessionsInput>
  }

  export type UserCreateWithoutMentorSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    documents?: DocumentCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutMentorSessionsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    documents?: DocumentUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutMentorSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMentorSessionsInput, UserUncheckedCreateWithoutMentorSessionsInput>
  }

  export type MentorReviewCreateWithoutSessionInput = {
    id?: string
    rating: number
    review?: string | null
    student: StudentCreateNestedOneWithoutReviewsInput
  }

  export type MentorReviewUncheckedCreateWithoutSessionInput = {
    id?: string
    studentId: string
    rating: number
    review?: string | null
  }

  export type MentorReviewCreateOrConnectWithoutSessionInput = {
    where: MentorReviewWhereUniqueInput
    create: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput>
  }

  export type MentorReviewCreateManySessionInputEnvelope = {
    data: MentorReviewCreateManySessionInput | MentorReviewCreateManySessionInput[]
  }

  export type StudentUpsertWithoutMentorSessionsInput = {
    update: XOR<StudentUpdateWithoutMentorSessionsInput, StudentUncheckedUpdateWithoutMentorSessionsInput>
    create: XOR<StudentCreateWithoutMentorSessionsInput, StudentUncheckedCreateWithoutMentorSessionsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutMentorSessionsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutMentorSessionsInput, StudentUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type StudentUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserUpsertWithoutMentorSessionsInput = {
    update: XOR<UserUpdateWithoutMentorSessionsInput, UserUncheckedUpdateWithoutMentorSessionsInput>
    create: XOR<UserCreateWithoutMentorSessionsInput, UserUncheckedCreateWithoutMentorSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMentorSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMentorSessionsInput, UserUncheckedUpdateWithoutMentorSessionsInput>
  }

  export type UserUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutMentorSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type MentorReviewUpsertWithWhereUniqueWithoutSessionInput = {
    where: MentorReviewWhereUniqueInput
    update: XOR<MentorReviewUpdateWithoutSessionInput, MentorReviewUncheckedUpdateWithoutSessionInput>
    create: XOR<MentorReviewCreateWithoutSessionInput, MentorReviewUncheckedCreateWithoutSessionInput>
  }

  export type MentorReviewUpdateWithWhereUniqueWithoutSessionInput = {
    where: MentorReviewWhereUniqueInput
    data: XOR<MentorReviewUpdateWithoutSessionInput, MentorReviewUncheckedUpdateWithoutSessionInput>
  }

  export type MentorReviewUpdateManyWithWhereWithoutSessionInput = {
    where: MentorReviewScalarWhereInput
    data: XOR<MentorReviewUpdateManyMutationInput, MentorReviewUncheckedUpdateManyWithoutSessionInput>
  }

  export type MentorSessionCreateWithoutReviewsInput = {
    id?: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutMentorSessionsInput
    mentor: UserCreateNestedOneWithoutMentorSessionsInput
  }

  export type MentorSessionUncheckedCreateWithoutReviewsInput = {
    id?: string
    studentId: string
    mentorId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
  }

  export type MentorSessionCreateOrConnectWithoutReviewsInput = {
    where: MentorSessionWhereUniqueInput
    create: XOR<MentorSessionCreateWithoutReviewsInput, MentorSessionUncheckedCreateWithoutReviewsInput>
  }

  export type StudentCreateWithoutReviewsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutReviewsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutReviewsInput, StudentUncheckedCreateWithoutReviewsInput>
  }

  export type MentorSessionUpsertWithoutReviewsInput = {
    update: XOR<MentorSessionUpdateWithoutReviewsInput, MentorSessionUncheckedUpdateWithoutReviewsInput>
    create: XOR<MentorSessionCreateWithoutReviewsInput, MentorSessionUncheckedCreateWithoutReviewsInput>
    where?: MentorSessionWhereInput
  }

  export type MentorSessionUpdateToOneWithWhereWithoutReviewsInput = {
    where?: MentorSessionWhereInput
    data: XOR<MentorSessionUpdateWithoutReviewsInput, MentorSessionUncheckedUpdateWithoutReviewsInput>
  }

  export type MentorSessionUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMentorSessionsNestedInput
    mentor?: UserUpdateOneRequiredWithoutMentorSessionsNestedInput
  }

  export type MentorSessionUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentUpsertWithoutReviewsInput = {
    update: XOR<StudentUpdateWithoutReviewsInput, StudentUncheckedUpdateWithoutReviewsInput>
    create: XOR<StudentCreateWithoutReviewsInput, StudentUncheckedCreateWithoutReviewsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutReviewsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutReviewsInput, StudentUncheckedUpdateWithoutReviewsInput>
  }

  export type StudentUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutLogbookEntriesInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutLogbookEntriesInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutLogbookEntriesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLogbookEntriesInput, StudentUncheckedCreateWithoutLogbookEntriesInput>
  }

  export type StudentUpsertWithoutLogbookEntriesInput = {
    update: XOR<StudentUpdateWithoutLogbookEntriesInput, StudentUncheckedUpdateWithoutLogbookEntriesInput>
    create: XOR<StudentCreateWithoutLogbookEntriesInput, StudentUncheckedCreateWithoutLogbookEntriesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLogbookEntriesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLogbookEntriesInput, StudentUncheckedUpdateWithoutLogbookEntriesInput>
  }

  export type StudentUpdateWithoutLogbookEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutLogbookEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutCertificatesInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCertificatesInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCertificatesInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
  }

  export type StudentUpsertWithoutCertificatesInput = {
    update: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
    create: XOR<StudentCreateWithoutCertificatesInput, StudentUncheckedCreateWithoutCertificatesInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCertificatesInput, StudentUncheckedUpdateWithoutCertificatesInput>
  }

  export type StudentUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutLearningProgressInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutLearningProgressInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutLearningProgressInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutLearningProgressInput, StudentUncheckedCreateWithoutLearningProgressInput>
  }

  export type StudentUpsertWithoutLearningProgressInput = {
    update: XOR<StudentUpdateWithoutLearningProgressInput, StudentUncheckedUpdateWithoutLearningProgressInput>
    create: XOR<StudentCreateWithoutLearningProgressInput, StudentUncheckedCreateWithoutLearningProgressInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutLearningProgressInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutLearningProgressInput, StudentUncheckedUpdateWithoutLearningProgressInput>
  }

  export type StudentUpdateWithoutLearningProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutLearningProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentCreateWithoutCertificationsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCertificationsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCertificationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCertificationsInput, StudentUncheckedCreateWithoutCertificationsInput>
  }

  export type StudentUpsertWithoutCertificationsInput = {
    update: XOR<StudentUpdateWithoutCertificationsInput, StudentUncheckedUpdateWithoutCertificationsInput>
    create: XOR<StudentCreateWithoutCertificationsInput, StudentUncheckedCreateWithoutCertificationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCertificationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCertificationsInput, StudentUncheckedUpdateWithoutCertificationsInput>
  }

  export type StudentUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCertificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentSkillCreateWithoutSkillInput = {
    id?: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
    student: StudentCreateNestedOneWithoutStudentSkillsInput
  }

  export type StudentSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    studentId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type StudentSkillCreateOrConnectWithoutSkillInput = {
    where: StudentSkillWhereUniqueInput
    create: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput>
  }

  export type StudentSkillCreateManySkillInputEnvelope = {
    data: StudentSkillCreateManySkillInput | StudentSkillCreateManySkillInput[]
  }

  export type StudentSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: StudentSkillWhereUniqueInput
    update: XOR<StudentSkillUpdateWithoutSkillInput, StudentSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<StudentSkillCreateWithoutSkillInput, StudentSkillUncheckedCreateWithoutSkillInput>
  }

  export type StudentSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: StudentSkillWhereUniqueInput
    data: XOR<StudentSkillUpdateWithoutSkillInput, StudentSkillUncheckedUpdateWithoutSkillInput>
  }

  export type StudentSkillUpdateManyWithWhereWithoutSkillInput = {
    where: StudentSkillScalarWhereInput
    data: XOR<StudentSkillUpdateManyMutationInput, StudentSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type StudentCreateWithoutStudentSkillsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutStudentSkillsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    cvGenerations?: CVGenerationUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutStudentSkillsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutStudentSkillsInput, StudentUncheckedCreateWithoutStudentSkillsInput>
  }

  export type SkillCreateWithoutStudentSkillsInput = {
    id?: string
    name: string
    category?: string | null
    createdAt?: Date | string
  }

  export type SkillUncheckedCreateWithoutStudentSkillsInput = {
    id?: string
    name: string
    category?: string | null
    createdAt?: Date | string
  }

  export type SkillCreateOrConnectWithoutStudentSkillsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutStudentSkillsInput, SkillUncheckedCreateWithoutStudentSkillsInput>
  }

  export type StudentUpsertWithoutStudentSkillsInput = {
    update: XOR<StudentUpdateWithoutStudentSkillsInput, StudentUncheckedUpdateWithoutStudentSkillsInput>
    create: XOR<StudentCreateWithoutStudentSkillsInput, StudentUncheckedCreateWithoutStudentSkillsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutStudentSkillsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutStudentSkillsInput, StudentUncheckedUpdateWithoutStudentSkillsInput>
  }

  export type StudentUpdateWithoutStudentSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutStudentSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    cvGenerations?: CVGenerationUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type SkillUpsertWithoutStudentSkillsInput = {
    update: XOR<SkillUpdateWithoutStudentSkillsInput, SkillUncheckedUpdateWithoutStudentSkillsInput>
    create: XOR<SkillCreateWithoutStudentSkillsInput, SkillUncheckedCreateWithoutStudentSkillsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutStudentSkillsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutStudentSkillsInput, SkillUncheckedUpdateWithoutStudentSkillsInput>
  }

  export type SkillUpdateWithoutStudentSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillUncheckedUpdateWithoutStudentSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentCreateWithoutCvGenerationsInput = {
    id?: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStudentInput
    profile?: ProfileCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryCreateNestedManyWithoutStudentInput
    certificates?: CertificateCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressCreateNestedManyWithoutStudentInput
    certifications?: CertificationCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillCreateNestedManyWithoutStudentInput
  }

  export type StudentUncheckedCreateWithoutCvGenerationsInput = {
    id?: string
    userId: string
    rollNumber?: string | null
    department?: string | null
    semester?: number | null
    cgpa?: number | null
    dateOfBirth?: Date | string | null
    phone?: string | null
    approved?: boolean
    approvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutStudentInput
    applications?: InternshipApplicationUncheckedCreateNestedManyWithoutStudentInput
    enrollments?: CourseEnrollmentUncheckedCreateNestedManyWithoutStudentInput
    projects?: PortfolioProjectUncheckedCreateNestedManyWithoutStudentInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutStudentInput
    reviews?: MentorReviewUncheckedCreateNestedManyWithoutStudentInput
    logbookEntries?: LogbookEntryUncheckedCreateNestedManyWithoutStudentInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutStudentInput
    learningProgress?: StudentLearningProgressUncheckedCreateNestedManyWithoutStudentInput
    certifications?: CertificationUncheckedCreateNestedManyWithoutStudentInput
    studentSkills?: StudentSkillUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentCreateOrConnectWithoutCvGenerationsInput = {
    where: StudentWhereUniqueInput
    create: XOR<StudentCreateWithoutCvGenerationsInput, StudentUncheckedCreateWithoutCvGenerationsInput>
  }

  export type StudentUpsertWithoutCvGenerationsInput = {
    update: XOR<StudentUpdateWithoutCvGenerationsInput, StudentUncheckedUpdateWithoutCvGenerationsInput>
    create: XOR<StudentCreateWithoutCvGenerationsInput, StudentUncheckedCreateWithoutCvGenerationsInput>
    where?: StudentWhereInput
  }

  export type StudentUpdateToOneWithWhereWithoutCvGenerationsInput = {
    where?: StudentWhereInput
    data: XOR<StudentUpdateWithoutCvGenerationsInput, StudentUncheckedUpdateWithoutCvGenerationsInput>
  }

  export type StudentUpdateWithoutCvGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStudentNestedInput
    profile?: ProfileUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUpdateManyWithoutStudentNestedInput
  }

  export type StudentUncheckedUpdateWithoutCvGenerationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rollNumber?: NullableStringFieldUpdateOperationsInput | string | null
    department?: NullableStringFieldUpdateOperationsInput | string | null
    semester?: NullableIntFieldUpdateOperationsInput | number | null
    cgpa?: NullableFloatFieldUpdateOperationsInput | number | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    approved?: BoolFieldUpdateOperationsInput | boolean
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutStudentNestedInput
    applications?: InternshipApplicationUncheckedUpdateManyWithoutStudentNestedInput
    enrollments?: CourseEnrollmentUncheckedUpdateManyWithoutStudentNestedInput
    projects?: PortfolioProjectUncheckedUpdateManyWithoutStudentNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutStudentNestedInput
    reviews?: MentorReviewUncheckedUpdateManyWithoutStudentNestedInput
    logbookEntries?: LogbookEntryUncheckedUpdateManyWithoutStudentNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutStudentNestedInput
    learningProgress?: StudentLearningProgressUncheckedUpdateManyWithoutStudentNestedInput
    certifications?: CertificationUncheckedUpdateManyWithoutStudentNestedInput
    studentSkills?: StudentSkillUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceCreateNestedManyWithoutUserInput
    invites?: InviteCreateNestedManyWithoutInviterInput
    teams?: TeamCreateNestedManyWithoutUsersInput
    chats?: ChatCreateNestedManyWithoutUserInput
    student?: StudentCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationCreateNestedManyWithoutEvaluatorInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    name: string
    email: string
    password: string
    teamRole?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    githubUsername?: string | null
    githubToken?: string | null
    githubConnectedAt?: Date | string | null
    lastGithubSync?: Date | string | null
    profilePictureUrl?: string | null
    resumeUrl?: string | null
    workspaces?: WorkspaceUncheckedCreateNestedManyWithoutUserInput
    invites?: InviteUncheckedCreateNestedManyWithoutInviterInput
    teams?: TeamUncheckedCreateNestedManyWithoutUsersInput
    chats?: ChatUncheckedCreateNestedManyWithoutUserInput
    student?: StudentUncheckedCreateNestedOneWithoutUserInput
    mentorSessions?: MentorSessionUncheckedCreateNestedManyWithoutMentorInput
    evaluationsGiven?: InternshipEvaluationUncheckedCreateNestedManyWithoutEvaluatorInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    teams?: TeamUpdateManyWithoutUsersNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    teams?: TeamUncheckedUpdateManyWithoutUsersNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type WorkspaceCreateManyUserInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    teamId?: string | null
  }

  export type InviteCreateManyInviterInput = {
    id?: string
    inviteId: string
    workspaceId: string
    type: string
  }

  export type ChatCreateManyUserInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    workspaceId: string
  }

  export type DocumentCreateManyUserInput = {
    id?: string
    filename: string
    originalFilename: string
    fileUrl: string
    fileType?: string | null
    fileSize?: bigint | number | null
    category?: string | null
    uploadedAt?: Date | string
    metadata?: string | null
  }

  export type MentorSessionCreateManyMentorInput = {
    id?: string
    studentId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
  }

  export type InternshipEvaluationCreateManyEvaluatorInput = {
    id?: string
    internshipId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type WorkspaceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutWorkspacesNestedInput
    team?: TeamUpdateOneWithoutWorkspacesNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InviteUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    workspace?: WorkspaceUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InviteUncheckedUpdateManyWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type TeamUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    workspaces?: WorkspaceUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace?: WorkspaceUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DocumentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalFilename?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    uploadedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorSessionUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutMentorSessionsNestedInput
    reviews?: MentorReviewUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionUncheckedUpdateWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: MentorReviewUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionUncheckedUpdateManyWithoutMentorInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipEvaluationUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    internship?: InternshipUpdateOneRequiredWithoutEvaluationsNestedInput
  }

  export type InternshipEvaluationUncheckedUpdateWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatCreateManyWorkspaceInput = {
    id?: string
    duration?: number | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    userId: string
  }

  export type InviteCreateManyWorkspaceInput = {
    id?: string
    inviteId: string
    type: string
    inviterId: string
  }

  export type ChatUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutChatsNestedInput
  }

  export type ChatUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ChatUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type InviteUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    inviter?: UserUpdateOneRequiredWithoutInvitesNestedInput
  }

  export type InviteUncheckedUpdateWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type InviteUncheckedUpdateManyWithoutWorkspaceInput = {
    id?: StringFieldUpdateOperationsInput | string
    inviteId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    inviterId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkspaceCreateManyFolderInput = {
    id?: string
    createdAt?: Date | string
    teamId?: string | null
    userId: string
  }

  export type WorkspaceUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    team?: TeamUpdateOneWithoutWorkspacesNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type WorkspaceCreateManyTeamInput = {
    id?: string
    createdAt?: Date | string
    folderId?: string | null
    userId: string
  }

  export type WorkspaceUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspacesNestedInput
    folder?: FolderUpdateOneWithoutWorkspacesNestedInput
    chats?: ChatUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    chats?: ChatUncheckedUpdateManyWithoutWorkspaceNestedInput
    invites?: InviteUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkspaceUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type UserUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUpdateManyWithoutUserNestedInput
    invites?: InviteUpdateManyWithoutInviterNestedInput
    chats?: ChatUpdateManyWithoutUserNestedInput
    documents?: DocumentUpdateManyWithoutUserNestedInput
    student?: StudentUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    workspaces?: WorkspaceUncheckedUpdateManyWithoutUserNestedInput
    invites?: InviteUncheckedUpdateManyWithoutInviterNestedInput
    chats?: ChatUncheckedUpdateManyWithoutUserNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutUserNestedInput
    student?: StudentUncheckedUpdateOneWithoutUserNestedInput
    mentorSessions?: MentorSessionUncheckedUpdateManyWithoutMentorNestedInput
    evaluationsGiven?: InternshipEvaluationUncheckedUpdateManyWithoutEvaluatorNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    teamRole?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    githubUsername?: NullableStringFieldUpdateOperationsInput | string | null
    githubToken?: NullableStringFieldUpdateOperationsInput | string | null
    githubConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastGithubSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    profilePictureUrl?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationCreateManyStudentInput = {
    id?: string
    internshipId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type CourseEnrollmentCreateManyStudentInput = {
    id?: string
    courseId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type PortfolioProjectCreateManyStudentInput = {
    id?: string
    title: string
    description: string
    githubUrl?: string | null
    liveUrl?: string | null
    tags?: string | null
    createdAt?: Date | string
    source?: string
    githubRepoId?: string | null
    lastSyncedAt?: Date | string | null
    stars?: number
    forks?: number
    language?: string | null
  }

  export type MentorSessionCreateManyStudentInput = {
    id?: string
    mentorId: string
    scheduledAt: Date | string
    status?: string
    meetingLink?: string | null
    createdAt?: Date | string
  }

  export type MentorReviewCreateManyStudentInput = {
    id?: string
    sessionId: string
    rating: number
    review?: string | null
  }

  export type LogbookEntryCreateManyStudentInput = {
    id?: string
    date: Date | string
    task: string
    hours: number
    description: string
    proofUrl?: string | null
    createdAt?: Date | string
  }

  export type CertificateCreateManyStudentInput = {
    id?: string
    title: string
    issuedAt?: Date | string
    certificateUrl: string
  }

  export type StudentLearningProgressCreateManyStudentInput = {
    id?: string
    profileId: string
    isCompleted?: boolean
    completedAt?: Date | string | null
    checkpointId: string
  }

  export type CertificationCreateManyStudentInput = {
    id?: string
    title: string
    issuer?: string | null
    issueDate?: Date | string | null
    expiryDate?: Date | string | null
    credentialId?: string | null
    credentialUrl?: string | null
    source?: string
    documentUrl?: string | null
    verified?: boolean
    metadata?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentSkillCreateManyStudentInput = {
    id?: string
    skillId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type CVGenerationCreateManyStudentInput = {
    id?: string
    templateName: string
    fileUrl: string
    format: string
    generatedAt?: Date | string
    metadata?: string | null
  }

  export type InternshipApplicationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    internship?: InternshipUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type InternshipApplicationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    internshipId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CourseEnrollmentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    course?: CourseUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    courseId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PortfolioProjectUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioProjectUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortfolioProjectUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    liveUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    source?: StringFieldUpdateOperationsInput | string
    githubRepoId?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    stars?: IntFieldUpdateOperationsInput | number
    forks?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorSessionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    mentor?: UserUpdateOneRequiredWithoutMentorSessionsNestedInput
    reviews?: MentorReviewUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: MentorReviewUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type MentorSessionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mentorId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MentorReviewUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    session?: MentorSessionUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type MentorReviewUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorReviewUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogbookEntryUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogbookEntryUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LogbookEntryUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    task?: StringFieldUpdateOperationsInput | string
    hours?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    proofUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    certificateUrl?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentLearningProgressUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkpointId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    issuer?: NullableStringFieldUpdateOperationsInput | string | null
    issueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expiryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialId?: NullableStringFieldUpdateOperationsInput | string | null
    credentialUrl?: NullableStringFieldUpdateOperationsInput | string | null
    source?: StringFieldUpdateOperationsInput | string
    documentUrl?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutStudentSkillsNestedInput
  }

  export type StudentSkillUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CVGenerationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CVGenerationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CVGenerationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateName?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    format?: StringFieldUpdateOperationsInput | string
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationCreateManyInternshipInput = {
    id?: string
    studentId: string
    status?: string
    coverLetter?: string | null
    resumeUrl?: string | null
    appliedAt?: Date | string
    reviewedAt?: Date | string | null
    rejectionReason?: string | null
  }

  export type InternshipEvaluationCreateManyInternshipInput = {
    id?: string
    evaluatorId: string
    facultyId: string
    rubricJson: string
    comments?: string | null
    finalScore: number
    createdAt?: Date | string
  }

  export type InternshipApplicationUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutApplicationsNestedInput
  }

  export type InternshipApplicationUncheckedUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipApplicationUncheckedUpdateManyWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    coverLetter?: NullableStringFieldUpdateOperationsInput | string | null
    resumeUrl?: NullableStringFieldUpdateOperationsInput | string | null
    appliedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternshipEvaluationUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluator?: UserUpdateOneRequiredWithoutEvaluationsGivenNestedInput
  }

  export type InternshipEvaluationUncheckedUpdateWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InternshipEvaluationUncheckedUpdateManyWithoutInternshipInput = {
    id?: StringFieldUpdateOperationsInput | string
    evaluatorId?: StringFieldUpdateOperationsInput | string
    facultyId?: StringFieldUpdateOperationsInput | string
    rubricJson?: StringFieldUpdateOperationsInput | string
    comments?: NullableStringFieldUpdateOperationsInput | string | null
    finalScore?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CourseEnrollmentCreateManyCourseInput = {
    id?: string
    studentId: string
    enrolledAt?: Date | string
    progressPercent?: number
    completedAt?: Date | string | null
  }

  export type CheckpointCreateManyCourseInput = {
    id?: string
    title: string
    description?: string | null
    resourceUrl?: string | null
  }

  export type CourseEnrollmentUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    student?: StudentUpdateOneRequiredWithoutEnrollmentsNestedInput
  }

  export type CourseEnrollmentUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CourseEnrollmentUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progressPercent?: IntFieldUpdateOperationsInput | number
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CheckpointUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckpointUncheckedUpdateWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CheckpointUncheckedUpdateManyWithoutCourseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorReviewCreateManySessionInput = {
    id?: string
    studentId: string
    rating: number
    review?: string | null
  }

  export type MentorReviewUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type MentorReviewUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MentorReviewUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentSkillCreateManySkillInput = {
    id?: string
    studentId: string
    proficiencyLevel: number
    yearsExperience?: number | null
    source?: string
    createdAt?: Date | string
  }

  export type StudentSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentUpdateOneRequiredWithoutStudentSkillsNestedInput
  }

  export type StudentSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    proficiencyLevel?: IntFieldUpdateOperationsInput | number
    yearsExperience?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceCountOutputTypeDefaultArgs instead
     */
    export type WorkspaceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FolderCountOutputTypeDefaultArgs instead
     */
    export type FolderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FolderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentCountOutputTypeDefaultArgs instead
     */
    export type StudentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipCountOutputTypeDefaultArgs instead
     */
    export type InternshipCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseCountOutputTypeDefaultArgs instead
     */
    export type CourseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorSessionCountOutputTypeDefaultArgs instead
     */
    export type MentorSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillCountOutputTypeDefaultArgs instead
     */
    export type SkillCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WorkspaceDefaultArgs instead
     */
    export type WorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WorkspaceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FolderDefaultArgs instead
     */
    export type FolderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FolderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InviteDefaultArgs instead
     */
    export type InviteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InviteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatDefaultArgs instead
     */
    export type ChatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentDefaultArgs instead
     */
    export type StudentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipDefaultArgs instead
     */
    export type InternshipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipApplicationDefaultArgs instead
     */
    export type InternshipApplicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipApplicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternshipEvaluationDefaultArgs instead
     */
    export type InternshipEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternshipEvaluationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseDefaultArgs instead
     */
    export type CourseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CourseEnrollmentDefaultArgs instead
     */
    export type CourseEnrollmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CourseEnrollmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CheckpointDefaultArgs instead
     */
    export type CheckpointArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CheckpointDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PortfolioProjectDefaultArgs instead
     */
    export type PortfolioProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PortfolioProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorSessionDefaultArgs instead
     */
    export type MentorSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MentorReviewDefaultArgs instead
     */
    export type MentorReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MentorReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LogbookEntryDefaultArgs instead
     */
    export type LogbookEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LogbookEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentLearningProgressDefaultArgs instead
     */
    export type StudentLearningProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentLearningProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapDefaultArgs instead
     */
    export type RoadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificationDefaultArgs instead
     */
    export type CertificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SkillDefaultArgs instead
     */
    export type SkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StudentSkillDefaultArgs instead
     */
    export type StudentSkillArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StudentSkillDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CVGenerationDefaultArgs instead
     */
    export type CVGenerationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CVGenerationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentDefaultArgs instead
     */
    export type DocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}